
/**
 * Client
**/

import * as runtime from '@prisma/client/runtime/library.js';
import $Types = runtime.Types // general types
import $Public = runtime.Types.Public
import $Utils = runtime.Types.Utils
import $Extensions = runtime.Types.Extensions
import $Result = runtime.Types.Result

export type PrismaPromise<T> = $Public.PrismaPromise<T>


/**
 * Model User
 * 
 */
export type User = $Result.DefaultSelection<Prisma.$UserPayload>
/**
 * Model Agent
 * 
 */
export type Agent = $Result.DefaultSelection<Prisma.$AgentPayload>
/**
 * Model AgentDocument
 * 
 */
export type AgentDocument = $Result.DefaultSelection<Prisma.$AgentDocumentPayload>
/**
 * Model AgentLocation
 * 
 */
export type AgentLocation = $Result.DefaultSelection<Prisma.$AgentLocationPayload>
/**
 * Model Partner
 * 
 */
export type Partner = $Result.DefaultSelection<Prisma.$PartnerPayload>
/**
 * Model Order
 * 
 */
export type Order = $Result.DefaultSelection<Prisma.$OrderPayload>
/**
 * Model NotificationToken
 * 
 */
export type NotificationToken = $Result.DefaultSelection<Prisma.$NotificationTokenPayload>
/**
 * Model SupportTicket
 * 
 */
export type SupportTicket = $Result.DefaultSelection<Prisma.$SupportTicketPayload>
/**
 * Model AppEvent
 * 
 */
export type AppEvent = $Result.DefaultSelection<Prisma.$AppEventPayload>
/**
 * Model DailyStats
 * 
 */
export type DailyStats = $Result.DefaultSelection<Prisma.$DailyStatsPayload>
/**
 * Model PartnerDailyStats
 * 
 */
export type PartnerDailyStats = $Result.DefaultSelection<Prisma.$PartnerDailyStatsPayload>
/**
 * Model PartnerRevenue
 * 
 */
export type PartnerRevenue = $Result.DefaultSelection<Prisma.$PartnerRevenuePayload>
/**
 * Model PlatformRevenue
 * 
 */
export type PlatformRevenue = $Result.DefaultSelection<Prisma.$PlatformRevenuePayload>
/**
 * Model AdminWallet
 * 
 */
export type AdminWallet = $Result.DefaultSelection<Prisma.$AdminWalletPayload>
/**
 * Model AgentWallet
 * 
 */
export type AgentWallet = $Result.DefaultSelection<Prisma.$AgentWalletPayload>
/**
 * Model WalletTransaction
 * 
 */
export type WalletTransaction = $Result.DefaultSelection<Prisma.$WalletTransactionPayload>
/**
 * Model WalletPayout
 * 
 */
export type WalletPayout = $Result.DefaultSelection<Prisma.$WalletPayoutPayload>
/**
 * Model Notification
 * 
 */
export type Notification = $Result.DefaultSelection<Prisma.$NotificationPayload>
/**
 * Model AgentRating
 * 
 */
export type AgentRating = $Result.DefaultSelection<Prisma.$AgentRatingPayload>
/**
 * Model Payment
 * 
 */
export type Payment = $Result.DefaultSelection<Prisma.$PaymentPayload>
/**
 * Model Payroll
 * 
 */
export type Payroll = $Result.DefaultSelection<Prisma.$PayrollPayload>
/**
 * Model AgentSchedule
 * 
 */
export type AgentSchedule = $Result.DefaultSelection<Prisma.$AgentSchedulePayload>
/**
 * Model PayStructure
 * 
 */
export type PayStructure = $Result.DefaultSelection<Prisma.$PayStructurePayload>

/**
 * Enums
 */
export namespace $Enums {
  export const UserRole: {
  AGENT: 'AGENT',
  PARTNER: 'PARTNER',
  ADMIN: 'ADMIN'
};

export type UserRole = (typeof UserRole)[keyof typeof UserRole]


export const VehicleType: {
  BIKE: 'BIKE',
  SCOOTER: 'SCOOTER',
  CAR: 'CAR',
  BICYCLE: 'BICYCLE'
};

export type VehicleType = (typeof VehicleType)[keyof typeof VehicleType]


export const AgentStatus: {
  OFFLINE: 'OFFLINE',
  ONLINE: 'ONLINE',
  ON_TRIP: 'ON_TRIP'
};

export type AgentStatus = (typeof AgentStatus)[keyof typeof AgentStatus]


export const OrderStatus: {
  SEARCHING_AGENT: 'SEARCHING_AGENT',
  ASSIGNED: 'ASSIGNED',
  PICKED_UP: 'PICKED_UP',
  OUT_FOR_DELIVERY: 'OUT_FOR_DELIVERY',
  DELIVERED: 'DELIVERED',
  CANCELLED: 'CANCELLED',
  DELAYED: 'DELAYED'
};

export type OrderStatus = (typeof OrderStatus)[keyof typeof OrderStatus]


export const TicketStatus: {
  OPEN: 'OPEN',
  IN_PROGRESS: 'IN_PROGRESS',
  RESOLVED: 'RESOLVED',
  CLOSED: 'CLOSED'
};

export type TicketStatus = (typeof TicketStatus)[keyof typeof TicketStatus]


export const EventType: {
  AGENT_ONLINE: 'AGENT_ONLINE',
  AGENT_OFFLINE: 'AGENT_OFFLINE',
  ORDER_CREATED: 'ORDER_CREATED',
  ORDER_ASSIGNED: 'ORDER_ASSIGNED',
  ORDER_ACCEPTED: 'ORDER_ACCEPTED',
  ORDER_REJECTED: 'ORDER_REJECTED',
  ORDER_PICKED_UP: 'ORDER_PICKED_UP',
  ORDER_OUT_FOR_DELIVERY: 'ORDER_OUT_FOR_DELIVERY',
  ORDER_DELIVERED: 'ORDER_DELIVERED',
  ORDER_CANCELLED: 'ORDER_CANCELLED',
  AGENT_LOCATION_UPDATE: 'AGENT_LOCATION_UPDATE'
};

export type EventType = (typeof EventType)[keyof typeof EventType]


export const ActorType: {
  AGENT: 'AGENT',
  PARTNER: 'PARTNER',
  SYSTEM: 'SYSTEM',
  ADMIN: 'ADMIN'
};

export type ActorType = (typeof ActorType)[keyof typeof ActorType]

}

export type UserRole = $Enums.UserRole

export const UserRole: typeof $Enums.UserRole

export type VehicleType = $Enums.VehicleType

export const VehicleType: typeof $Enums.VehicleType

export type AgentStatus = $Enums.AgentStatus

export const AgentStatus: typeof $Enums.AgentStatus

export type OrderStatus = $Enums.OrderStatus

export const OrderStatus: typeof $Enums.OrderStatus

export type TicketStatus = $Enums.TicketStatus

export const TicketStatus: typeof $Enums.TicketStatus

export type EventType = $Enums.EventType

export const EventType: typeof $Enums.EventType

export type ActorType = $Enums.ActorType

export const ActorType: typeof $Enums.ActorType

/**
 * ##  Prisma Client ʲˢ
 *
 * Type-safe database client for TypeScript & Node.js
 * @example
 * ```
 * const prisma = new PrismaClient()
 * // Fetch zero or more Users
 * const users = await prisma.user.findMany()
 * ```
 *
 *
 * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client).
 */
export class PrismaClient<
  ClientOptions extends Prisma.PrismaClientOptions = Prisma.PrismaClientOptions,
  const U = 'log' extends keyof ClientOptions ? ClientOptions['log'] extends Array<Prisma.LogLevel | Prisma.LogDefinition> ? Prisma.GetEvents<ClientOptions['log']> : never : never,
  ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
> {
  [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['other'] }

    /**
   * ##  Prisma Client ʲˢ
   *
   * Type-safe database client for TypeScript & Node.js
   * @example
   * ```
   * const prisma = new PrismaClient()
   * // Fetch zero or more Users
   * const users = await prisma.user.findMany()
   * ```
   *
   *
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client).
   */

  constructor(optionsArg ?: Prisma.Subset<ClientOptions, Prisma.PrismaClientOptions>);
  $on<V extends U>(eventType: V, callback: (event: V extends 'query' ? Prisma.QueryEvent : Prisma.LogEvent) => void): PrismaClient;

  /**
   * Connect with the database
   */
  $connect(): $Utils.JsPromise<void>;

  /**
   * Disconnect from the database
   */
  $disconnect(): $Utils.JsPromise<void>;

/**
   * Executes a prepared raw query and returns the number of affected rows.
   * @example
   * ```
   * const result = await prisma.$executeRaw`UPDATE User SET cool = ${true} WHERE email = ${'user@email.com'};`
   * ```
   *
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $executeRaw<T = unknown>(query: TemplateStringsArray | Prisma.Sql, ...values: any[]): Prisma.PrismaPromise<number>;

  /**
   * Executes a raw query and returns the number of affected rows.
   * Susceptible to SQL injections, see documentation.
   * @example
   * ```
   * const result = await prisma.$executeRawUnsafe('UPDATE User SET cool = $1 WHERE email = $2 ;', true, 'user@email.com')
   * ```
   *
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $executeRawUnsafe<T = unknown>(query: string, ...values: any[]): Prisma.PrismaPromise<number>;

  /**
   * Performs a prepared raw query and returns the `SELECT` data.
   * @example
   * ```
   * const result = await prisma.$queryRaw`SELECT * FROM User WHERE id = ${1} OR email = ${'user@email.com'};`
   * ```
   *
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $queryRaw<T = unknown>(query: TemplateStringsArray | Prisma.Sql, ...values: any[]): Prisma.PrismaPromise<T>;

  /**
   * Performs a raw query and returns the `SELECT` data.
   * Susceptible to SQL injections, see documentation.
   * @example
   * ```
   * const result = await prisma.$queryRawUnsafe('SELECT * FROM User WHERE id = $1 OR email = $2;', 1, 'user@email.com')
   * ```
   *
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $queryRawUnsafe<T = unknown>(query: string, ...values: any[]): Prisma.PrismaPromise<T>;


  /**
   * Allows the running of a sequence of read/write operations that are guaranteed to either succeed or fail as a whole.
   * @example
   * ```
   * const [george, bob, alice] = await prisma.$transaction([
   *   prisma.user.create({ data: { name: 'George' } }),
   *   prisma.user.create({ data: { name: 'Bob' } }),
   *   prisma.user.create({ data: { name: 'Alice' } }),
   * ])
   * ```
   * 
   * Read more in our [docs](https://www.prisma.io/docs/concepts/components/prisma-client/transactions).
   */
  $transaction<P extends Prisma.PrismaPromise<any>[]>(arg: [...P], options?: { isolationLevel?: Prisma.TransactionIsolationLevel }): $Utils.JsPromise<runtime.Types.Utils.UnwrapTuple<P>>

  $transaction<R>(fn: (prisma: Omit<PrismaClient, runtime.ITXClientDenyList>) => $Utils.JsPromise<R>, options?: { maxWait?: number, timeout?: number, isolationLevel?: Prisma.TransactionIsolationLevel }): $Utils.JsPromise<R>


  $extends: $Extensions.ExtendsHook<"extends", Prisma.TypeMapCb<ClientOptions>, ExtArgs, $Utils.Call<Prisma.TypeMapCb<ClientOptions>, {
    extArgs: ExtArgs
  }>>

      /**
   * `prisma.user`: Exposes CRUD operations for the **User** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Users
    * const users = await prisma.user.findMany()
    * ```
    */
  get user(): Prisma.UserDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.agent`: Exposes CRUD operations for the **Agent** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Agents
    * const agents = await prisma.agent.findMany()
    * ```
    */
  get agent(): Prisma.AgentDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.agentDocument`: Exposes CRUD operations for the **AgentDocument** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more AgentDocuments
    * const agentDocuments = await prisma.agentDocument.findMany()
    * ```
    */
  get agentDocument(): Prisma.AgentDocumentDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.agentLocation`: Exposes CRUD operations for the **AgentLocation** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more AgentLocations
    * const agentLocations = await prisma.agentLocation.findMany()
    * ```
    */
  get agentLocation(): Prisma.AgentLocationDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.partner`: Exposes CRUD operations for the **Partner** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Partners
    * const partners = await prisma.partner.findMany()
    * ```
    */
  get partner(): Prisma.PartnerDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.order`: Exposes CRUD operations for the **Order** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Orders
    * const orders = await prisma.order.findMany()
    * ```
    */
  get order(): Prisma.OrderDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.notificationToken`: Exposes CRUD operations for the **NotificationToken** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more NotificationTokens
    * const notificationTokens = await prisma.notificationToken.findMany()
    * ```
    */
  get notificationToken(): Prisma.NotificationTokenDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.supportTicket`: Exposes CRUD operations for the **SupportTicket** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more SupportTickets
    * const supportTickets = await prisma.supportTicket.findMany()
    * ```
    */
  get supportTicket(): Prisma.SupportTicketDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.appEvent`: Exposes CRUD operations for the **AppEvent** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more AppEvents
    * const appEvents = await prisma.appEvent.findMany()
    * ```
    */
  get appEvent(): Prisma.AppEventDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.dailyStats`: Exposes CRUD operations for the **DailyStats** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more DailyStats
    * const dailyStats = await prisma.dailyStats.findMany()
    * ```
    */
  get dailyStats(): Prisma.DailyStatsDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.partnerDailyStats`: Exposes CRUD operations for the **PartnerDailyStats** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more PartnerDailyStats
    * const partnerDailyStats = await prisma.partnerDailyStats.findMany()
    * ```
    */
  get partnerDailyStats(): Prisma.PartnerDailyStatsDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.partnerRevenue`: Exposes CRUD operations for the **PartnerRevenue** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more PartnerRevenues
    * const partnerRevenues = await prisma.partnerRevenue.findMany()
    * ```
    */
  get partnerRevenue(): Prisma.PartnerRevenueDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.platformRevenue`: Exposes CRUD operations for the **PlatformRevenue** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more PlatformRevenues
    * const platformRevenues = await prisma.platformRevenue.findMany()
    * ```
    */
  get platformRevenue(): Prisma.PlatformRevenueDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.adminWallet`: Exposes CRUD operations for the **AdminWallet** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more AdminWallets
    * const adminWallets = await prisma.adminWallet.findMany()
    * ```
    */
  get adminWallet(): Prisma.AdminWalletDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.agentWallet`: Exposes CRUD operations for the **AgentWallet** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more AgentWallets
    * const agentWallets = await prisma.agentWallet.findMany()
    * ```
    */
  get agentWallet(): Prisma.AgentWalletDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.walletTransaction`: Exposes CRUD operations for the **WalletTransaction** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more WalletTransactions
    * const walletTransactions = await prisma.walletTransaction.findMany()
    * ```
    */
  get walletTransaction(): Prisma.WalletTransactionDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.walletPayout`: Exposes CRUD operations for the **WalletPayout** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more WalletPayouts
    * const walletPayouts = await prisma.walletPayout.findMany()
    * ```
    */
  get walletPayout(): Prisma.WalletPayoutDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.notification`: Exposes CRUD operations for the **Notification** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Notifications
    * const notifications = await prisma.notification.findMany()
    * ```
    */
  get notification(): Prisma.NotificationDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.agentRating`: Exposes CRUD operations for the **AgentRating** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more AgentRatings
    * const agentRatings = await prisma.agentRating.findMany()
    * ```
    */
  get agentRating(): Prisma.AgentRatingDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.payment`: Exposes CRUD operations for the **Payment** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Payments
    * const payments = await prisma.payment.findMany()
    * ```
    */
  get payment(): Prisma.PaymentDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.payroll`: Exposes CRUD operations for the **Payroll** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Payrolls
    * const payrolls = await prisma.payroll.findMany()
    * ```
    */
  get payroll(): Prisma.PayrollDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.agentSchedule`: Exposes CRUD operations for the **AgentSchedule** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more AgentSchedules
    * const agentSchedules = await prisma.agentSchedule.findMany()
    * ```
    */
  get agentSchedule(): Prisma.AgentScheduleDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.payStructure`: Exposes CRUD operations for the **PayStructure** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more PayStructures
    * const payStructures = await prisma.payStructure.findMany()
    * ```
    */
  get payStructure(): Prisma.PayStructureDelegate<ExtArgs, ClientOptions>;
}

export namespace Prisma {
  export import DMMF = runtime.DMMF

  export type PrismaPromise<T> = $Public.PrismaPromise<T>

  /**
   * Validator
   */
  export import validator = runtime.Public.validator

  /**
   * Prisma Errors
   */
  export import PrismaClientKnownRequestError = runtime.PrismaClientKnownRequestError
  export import PrismaClientUnknownRequestError = runtime.PrismaClientUnknownRequestError
  export import PrismaClientRustPanicError = runtime.PrismaClientRustPanicError
  export import PrismaClientInitializationError = runtime.PrismaClientInitializationError
  export import PrismaClientValidationError = runtime.PrismaClientValidationError

  /**
   * Re-export of sql-template-tag
   */
  export import sql = runtime.sqltag
  export import empty = runtime.empty
  export import join = runtime.join
  export import raw = runtime.raw
  export import Sql = runtime.Sql



  /**
   * Decimal.js
   */
  export import Decimal = runtime.Decimal

  export type DecimalJsLike = runtime.DecimalJsLike

  /**
   * Metrics
   */
  export type Metrics = runtime.Metrics
  export type Metric<T> = runtime.Metric<T>
  export type MetricHistogram = runtime.MetricHistogram
  export type MetricHistogramBucket = runtime.MetricHistogramBucket

  /**
  * Extensions
  */
  export import Extension = $Extensions.UserArgs
  export import getExtensionContext = runtime.Extensions.getExtensionContext
  export import Args = $Public.Args
  export import Payload = $Public.Payload
  export import Result = $Public.Result
  export import Exact = $Public.Exact

  /**
   * Prisma Client JS version: 6.19.0
   * Query Engine version: 2ba551f319ab1df4bc874a89965d8b3641056773
   */
  export type PrismaVersion = {
    client: string
  }

  export const prismaVersion: PrismaVersion

  /**
   * Utility Types
   */


  export import Bytes = runtime.Bytes
  export import JsonObject = runtime.JsonObject
  export import JsonArray = runtime.JsonArray
  export import JsonValue = runtime.JsonValue
  export import InputJsonObject = runtime.InputJsonObject
  export import InputJsonArray = runtime.InputJsonArray
  export import InputJsonValue = runtime.InputJsonValue

  /**
   * Types of the values used to represent different kinds of `null` values when working with JSON fields.
   *
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  namespace NullTypes {
    /**
    * Type of `Prisma.DbNull`.
    *
    * You cannot use other instances of this class. Please use the `Prisma.DbNull` value.
    *
    * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
    */
    class DbNull {
      private DbNull: never
      private constructor()
    }

    /**
    * Type of `Prisma.JsonNull`.
    *
    * You cannot use other instances of this class. Please use the `Prisma.JsonNull` value.
    *
    * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
    */
    class JsonNull {
      private JsonNull: never
      private constructor()
    }

    /**
    * Type of `Prisma.AnyNull`.
    *
    * You cannot use other instances of this class. Please use the `Prisma.AnyNull` value.
    *
    * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
    */
    class AnyNull {
      private AnyNull: never
      private constructor()
    }
  }

  /**
   * Helper for filtering JSON entries that have `null` on the database (empty on the db)
   *
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  export const DbNull: NullTypes.DbNull

  /**
   * Helper for filtering JSON entries that have JSON `null` values (not empty on the db)
   *
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  export const JsonNull: NullTypes.JsonNull

  /**
   * Helper for filtering JSON entries that are `Prisma.DbNull` or `Prisma.JsonNull`
   *
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  export const AnyNull: NullTypes.AnyNull

  type SelectAndInclude = {
    select: any
    include: any
  }

  type SelectAndOmit = {
    select: any
    omit: any
  }

  /**
   * Get the type of the value, that the Promise holds.
   */
  export type PromiseType<T extends PromiseLike<any>> = T extends PromiseLike<infer U> ? U : T;

  /**
   * Get the return type of a function which returns a Promise.
   */
  export type PromiseReturnType<T extends (...args: any) => $Utils.JsPromise<any>> = PromiseType<ReturnType<T>>

  /**
   * From T, pick a set of properties whose keys are in the union K
   */
  type Prisma__Pick<T, K extends keyof T> = {
      [P in K]: T[P];
  };


  export type Enumerable<T> = T | Array<T>;

  export type RequiredKeys<T> = {
    [K in keyof T]-?: {} extends Prisma__Pick<T, K> ? never : K
  }[keyof T]

  export type TruthyKeys<T> = keyof {
    [K in keyof T as T[K] extends false | undefined | null ? never : K]: K
  }

  export type TrueKeys<T> = TruthyKeys<Prisma__Pick<T, RequiredKeys<T>>>

  /**
   * Subset
   * @desc From `T` pick properties that exist in `U`. Simple version of Intersection
   */
  export type Subset<T, U> = {
    [key in keyof T]: key extends keyof U ? T[key] : never;
  };

  /**
   * SelectSubset
   * @desc From `T` pick properties that exist in `U`. Simple version of Intersection.
   * Additionally, it validates, if both select and include are present. If the case, it errors.
   */
  export type SelectSubset<T, U> = {
    [key in keyof T]: key extends keyof U ? T[key] : never
  } &
    (T extends SelectAndInclude
      ? 'Please either choose `select` or `include`.'
      : T extends SelectAndOmit
        ? 'Please either choose `select` or `omit`.'
        : {})

  /**
   * Subset + Intersection
   * @desc From `T` pick properties that exist in `U` and intersect `K`
   */
  export type SubsetIntersection<T, U, K> = {
    [key in keyof T]: key extends keyof U ? T[key] : never
  } &
    K

  type Without<T, U> = { [P in Exclude<keyof T, keyof U>]?: never };

  /**
   * XOR is needed to have a real mutually exclusive union type
   * https://stackoverflow.com/questions/42123407/does-typescript-support-mutually-exclusive-types
   */
  type XOR<T, U> =
    T extends object ?
    U extends object ?
      (Without<T, U> & U) | (Without<U, T> & T)
    : U : T


  /**
   * Is T a Record?
   */
  type IsObject<T extends any> = T extends Array<any>
  ? False
  : T extends Date
  ? False
  : T extends Uint8Array
  ? False
  : T extends BigInt
  ? False
  : T extends object
  ? True
  : False


  /**
   * If it's T[], return T
   */
  export type UnEnumerate<T extends unknown> = T extends Array<infer U> ? U : T

  /**
   * From ts-toolbelt
   */

  type __Either<O extends object, K extends Key> = Omit<O, K> &
    {
      // Merge all but K
      [P in K]: Prisma__Pick<O, P & keyof O> // With K possibilities
    }[K]

  type EitherStrict<O extends object, K extends Key> = Strict<__Either<O, K>>

  type EitherLoose<O extends object, K extends Key> = ComputeRaw<__Either<O, K>>

  type _Either<
    O extends object,
    K extends Key,
    strict extends Boolean
  > = {
    1: EitherStrict<O, K>
    0: EitherLoose<O, K>
  }[strict]

  type Either<
    O extends object,
    K extends Key,
    strict extends Boolean = 1
  > = O extends unknown ? _Either<O, K, strict> : never

  export type Union = any

  type PatchUndefined<O extends object, O1 extends object> = {
    [K in keyof O]: O[K] extends undefined ? At<O1, K> : O[K]
  } & {}

  /** Helper Types for "Merge" **/
  export type IntersectOf<U extends Union> = (
    U extends unknown ? (k: U) => void : never
  ) extends (k: infer I) => void
    ? I
    : never

  export type Overwrite<O extends object, O1 extends object> = {
      [K in keyof O]: K extends keyof O1 ? O1[K] : O[K];
  } & {};

  type _Merge<U extends object> = IntersectOf<Overwrite<U, {
      [K in keyof U]-?: At<U, K>;
  }>>;

  type Key = string | number | symbol;
  type AtBasic<O extends object, K extends Key> = K extends keyof O ? O[K] : never;
  type AtStrict<O extends object, K extends Key> = O[K & keyof O];
  type AtLoose<O extends object, K extends Key> = O extends unknown ? AtStrict<O, K> : never;
  export type At<O extends object, K extends Key, strict extends Boolean = 1> = {
      1: AtStrict<O, K>;
      0: AtLoose<O, K>;
  }[strict];

  export type ComputeRaw<A extends any> = A extends Function ? A : {
    [K in keyof A]: A[K];
  } & {};

  export type OptionalFlat<O> = {
    [K in keyof O]?: O[K];
  } & {};

  type _Record<K extends keyof any, T> = {
    [P in K]: T;
  };

  // cause typescript not to expand types and preserve names
  type NoExpand<T> = T extends unknown ? T : never;

  // this type assumes the passed object is entirely optional
  type AtLeast<O extends object, K extends string> = NoExpand<
    O extends unknown
    ? | (K extends keyof O ? { [P in K]: O[P] } & O : O)
      | {[P in keyof O as P extends K ? P : never]-?: O[P]} & O
    : never>;

  type _Strict<U, _U = U> = U extends unknown ? U & OptionalFlat<_Record<Exclude<Keys<_U>, keyof U>, never>> : never;

  export type Strict<U extends object> = ComputeRaw<_Strict<U>>;
  /** End Helper Types for "Merge" **/

  export type Merge<U extends object> = ComputeRaw<_Merge<Strict<U>>>;

  /**
  A [[Boolean]]
  */
  export type Boolean = True | False

  // /**
  // 1
  // */
  export type True = 1

  /**
  0
  */
  export type False = 0

  export type Not<B extends Boolean> = {
    0: 1
    1: 0
  }[B]

  export type Extends<A1 extends any, A2 extends any> = [A1] extends [never]
    ? 0 // anything `never` is false
    : A1 extends A2
    ? 1
    : 0

  export type Has<U extends Union, U1 extends Union> = Not<
    Extends<Exclude<U1, U>, U1>
  >

  export type Or<B1 extends Boolean, B2 extends Boolean> = {
    0: {
      0: 0
      1: 1
    }
    1: {
      0: 1
      1: 1
    }
  }[B1][B2]

  export type Keys<U extends Union> = U extends unknown ? keyof U : never

  type Cast<A, B> = A extends B ? A : B;

  export const type: unique symbol;



  /**
   * Used by group by
   */

  export type GetScalarType<T, O> = O extends object ? {
    [P in keyof T]: P extends keyof O
      ? O[P]
      : never
  } : never

  type FieldPaths<
    T,
    U = Omit<T, '_avg' | '_sum' | '_count' | '_min' | '_max'>
  > = IsObject<T> extends True ? U : T

  type GetHavingFields<T> = {
    [K in keyof T]: Or<
      Or<Extends<'OR', K>, Extends<'AND', K>>,
      Extends<'NOT', K>
    > extends True
      ? // infer is only needed to not hit TS limit
        // based on the brilliant idea of Pierre-Antoine Mills
        // https://github.com/microsoft/TypeScript/issues/30188#issuecomment-478938437
        T[K] extends infer TK
        ? GetHavingFields<UnEnumerate<TK> extends object ? Merge<UnEnumerate<TK>> : never>
        : never
      : {} extends FieldPaths<T[K]>
      ? never
      : K
  }[keyof T]

  /**
   * Convert tuple to union
   */
  type _TupleToUnion<T> = T extends (infer E)[] ? E : never
  type TupleToUnion<K extends readonly any[]> = _TupleToUnion<K>
  type MaybeTupleToUnion<T> = T extends any[] ? TupleToUnion<T> : T

  /**
   * Like `Pick`, but additionally can also accept an array of keys
   */
  type PickEnumerable<T, K extends Enumerable<keyof T> | keyof T> = Prisma__Pick<T, MaybeTupleToUnion<K>>

  /**
   * Exclude all keys with underscores
   */
  type ExcludeUnderscoreKeys<T extends string> = T extends `_${string}` ? never : T


  export type FieldRef<Model, FieldType> = runtime.FieldRef<Model, FieldType>

  type FieldRefInputType<Model, FieldType> = Model extends never ? never : FieldRef<Model, FieldType>


  export const ModelName: {
    User: 'User',
    Agent: 'Agent',
    AgentDocument: 'AgentDocument',
    AgentLocation: 'AgentLocation',
    Partner: 'Partner',
    Order: 'Order',
    NotificationToken: 'NotificationToken',
    SupportTicket: 'SupportTicket',
    AppEvent: 'AppEvent',
    DailyStats: 'DailyStats',
    PartnerDailyStats: 'PartnerDailyStats',
    PartnerRevenue: 'PartnerRevenue',
    PlatformRevenue: 'PlatformRevenue',
    AdminWallet: 'AdminWallet',
    AgentWallet: 'AgentWallet',
    WalletTransaction: 'WalletTransaction',
    WalletPayout: 'WalletPayout',
    Notification: 'Notification',
    AgentRating: 'AgentRating',
    Payment: 'Payment',
    Payroll: 'Payroll',
    AgentSchedule: 'AgentSchedule',
    PayStructure: 'PayStructure'
  };

  export type ModelName = (typeof ModelName)[keyof typeof ModelName]


  export type Datasources = {
    db?: Datasource
  }

  interface TypeMapCb<ClientOptions = {}> extends $Utils.Fn<{extArgs: $Extensions.InternalArgs }, $Utils.Record<string, any>> {
    returns: Prisma.TypeMap<this['params']['extArgs'], ClientOptions extends { omit: infer OmitOptions } ? OmitOptions : {}>
  }

  export type TypeMap<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> = {
    globalOmitOptions: {
      omit: GlobalOmitOptions
    }
    meta: {
      modelProps: "user" | "agent" | "agentDocument" | "agentLocation" | "partner" | "order" | "notificationToken" | "supportTicket" | "appEvent" | "dailyStats" | "partnerDailyStats" | "partnerRevenue" | "platformRevenue" | "adminWallet" | "agentWallet" | "walletTransaction" | "walletPayout" | "notification" | "agentRating" | "payment" | "payroll" | "agentSchedule" | "payStructure"
      txIsolationLevel: Prisma.TransactionIsolationLevel
    }
    model: {
      User: {
        payload: Prisma.$UserPayload<ExtArgs>
        fields: Prisma.UserFieldRefs
        operations: {
          findUnique: {
            args: Prisma.UserFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.UserFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>
          }
          findFirst: {
            args: Prisma.UserFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.UserFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>
          }
          findMany: {
            args: Prisma.UserFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>[]
          }
          create: {
            args: Prisma.UserCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>
          }
          createMany: {
            args: Prisma.UserCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.UserCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>[]
          }
          delete: {
            args: Prisma.UserDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>
          }
          update: {
            args: Prisma.UserUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>
          }
          deleteMany: {
            args: Prisma.UserDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.UserUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.UserUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>[]
          }
          upsert: {
            args: Prisma.UserUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>
          }
          aggregate: {
            args: Prisma.UserAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateUser>
          }
          groupBy: {
            args: Prisma.UserGroupByArgs<ExtArgs>
            result: $Utils.Optional<UserGroupByOutputType>[]
          }
          count: {
            args: Prisma.UserCountArgs<ExtArgs>
            result: $Utils.Optional<UserCountAggregateOutputType> | number
          }
        }
      }
      Agent: {
        payload: Prisma.$AgentPayload<ExtArgs>
        fields: Prisma.AgentFieldRefs
        operations: {
          findUnique: {
            args: Prisma.AgentFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AgentPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.AgentFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AgentPayload>
          }
          findFirst: {
            args: Prisma.AgentFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AgentPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.AgentFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AgentPayload>
          }
          findMany: {
            args: Prisma.AgentFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AgentPayload>[]
          }
          create: {
            args: Prisma.AgentCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AgentPayload>
          }
          createMany: {
            args: Prisma.AgentCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.AgentCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AgentPayload>[]
          }
          delete: {
            args: Prisma.AgentDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AgentPayload>
          }
          update: {
            args: Prisma.AgentUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AgentPayload>
          }
          deleteMany: {
            args: Prisma.AgentDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.AgentUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.AgentUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AgentPayload>[]
          }
          upsert: {
            args: Prisma.AgentUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AgentPayload>
          }
          aggregate: {
            args: Prisma.AgentAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateAgent>
          }
          groupBy: {
            args: Prisma.AgentGroupByArgs<ExtArgs>
            result: $Utils.Optional<AgentGroupByOutputType>[]
          }
          count: {
            args: Prisma.AgentCountArgs<ExtArgs>
            result: $Utils.Optional<AgentCountAggregateOutputType> | number
          }
        }
      }
      AgentDocument: {
        payload: Prisma.$AgentDocumentPayload<ExtArgs>
        fields: Prisma.AgentDocumentFieldRefs
        operations: {
          findUnique: {
            args: Prisma.AgentDocumentFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AgentDocumentPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.AgentDocumentFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AgentDocumentPayload>
          }
          findFirst: {
            args: Prisma.AgentDocumentFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AgentDocumentPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.AgentDocumentFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AgentDocumentPayload>
          }
          findMany: {
            args: Prisma.AgentDocumentFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AgentDocumentPayload>[]
          }
          create: {
            args: Prisma.AgentDocumentCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AgentDocumentPayload>
          }
          createMany: {
            args: Prisma.AgentDocumentCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.AgentDocumentCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AgentDocumentPayload>[]
          }
          delete: {
            args: Prisma.AgentDocumentDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AgentDocumentPayload>
          }
          update: {
            args: Prisma.AgentDocumentUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AgentDocumentPayload>
          }
          deleteMany: {
            args: Prisma.AgentDocumentDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.AgentDocumentUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.AgentDocumentUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AgentDocumentPayload>[]
          }
          upsert: {
            args: Prisma.AgentDocumentUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AgentDocumentPayload>
          }
          aggregate: {
            args: Prisma.AgentDocumentAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateAgentDocument>
          }
          groupBy: {
            args: Prisma.AgentDocumentGroupByArgs<ExtArgs>
            result: $Utils.Optional<AgentDocumentGroupByOutputType>[]
          }
          count: {
            args: Prisma.AgentDocumentCountArgs<ExtArgs>
            result: $Utils.Optional<AgentDocumentCountAggregateOutputType> | number
          }
        }
      }
      AgentLocation: {
        payload: Prisma.$AgentLocationPayload<ExtArgs>
        fields: Prisma.AgentLocationFieldRefs
        operations: {
          findUnique: {
            args: Prisma.AgentLocationFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AgentLocationPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.AgentLocationFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AgentLocationPayload>
          }
          findFirst: {
            args: Prisma.AgentLocationFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AgentLocationPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.AgentLocationFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AgentLocationPayload>
          }
          findMany: {
            args: Prisma.AgentLocationFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AgentLocationPayload>[]
          }
          create: {
            args: Prisma.AgentLocationCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AgentLocationPayload>
          }
          createMany: {
            args: Prisma.AgentLocationCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.AgentLocationCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AgentLocationPayload>[]
          }
          delete: {
            args: Prisma.AgentLocationDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AgentLocationPayload>
          }
          update: {
            args: Prisma.AgentLocationUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AgentLocationPayload>
          }
          deleteMany: {
            args: Prisma.AgentLocationDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.AgentLocationUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.AgentLocationUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AgentLocationPayload>[]
          }
          upsert: {
            args: Prisma.AgentLocationUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AgentLocationPayload>
          }
          aggregate: {
            args: Prisma.AgentLocationAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateAgentLocation>
          }
          groupBy: {
            args: Prisma.AgentLocationGroupByArgs<ExtArgs>
            result: $Utils.Optional<AgentLocationGroupByOutputType>[]
          }
          count: {
            args: Prisma.AgentLocationCountArgs<ExtArgs>
            result: $Utils.Optional<AgentLocationCountAggregateOutputType> | number
          }
        }
      }
      Partner: {
        payload: Prisma.$PartnerPayload<ExtArgs>
        fields: Prisma.PartnerFieldRefs
        operations: {
          findUnique: {
            args: Prisma.PartnerFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PartnerPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.PartnerFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PartnerPayload>
          }
          findFirst: {
            args: Prisma.PartnerFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PartnerPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.PartnerFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PartnerPayload>
          }
          findMany: {
            args: Prisma.PartnerFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PartnerPayload>[]
          }
          create: {
            args: Prisma.PartnerCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PartnerPayload>
          }
          createMany: {
            args: Prisma.PartnerCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.PartnerCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PartnerPayload>[]
          }
          delete: {
            args: Prisma.PartnerDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PartnerPayload>
          }
          update: {
            args: Prisma.PartnerUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PartnerPayload>
          }
          deleteMany: {
            args: Prisma.PartnerDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.PartnerUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.PartnerUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PartnerPayload>[]
          }
          upsert: {
            args: Prisma.PartnerUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PartnerPayload>
          }
          aggregate: {
            args: Prisma.PartnerAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregatePartner>
          }
          groupBy: {
            args: Prisma.PartnerGroupByArgs<ExtArgs>
            result: $Utils.Optional<PartnerGroupByOutputType>[]
          }
          count: {
            args: Prisma.PartnerCountArgs<ExtArgs>
            result: $Utils.Optional<PartnerCountAggregateOutputType> | number
          }
        }
      }
      Order: {
        payload: Prisma.$OrderPayload<ExtArgs>
        fields: Prisma.OrderFieldRefs
        operations: {
          findUnique: {
            args: Prisma.OrderFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OrderPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.OrderFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OrderPayload>
          }
          findFirst: {
            args: Prisma.OrderFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OrderPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.OrderFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OrderPayload>
          }
          findMany: {
            args: Prisma.OrderFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OrderPayload>[]
          }
          create: {
            args: Prisma.OrderCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OrderPayload>
          }
          createMany: {
            args: Prisma.OrderCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.OrderCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OrderPayload>[]
          }
          delete: {
            args: Prisma.OrderDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OrderPayload>
          }
          update: {
            args: Prisma.OrderUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OrderPayload>
          }
          deleteMany: {
            args: Prisma.OrderDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.OrderUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.OrderUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OrderPayload>[]
          }
          upsert: {
            args: Prisma.OrderUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OrderPayload>
          }
          aggregate: {
            args: Prisma.OrderAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateOrder>
          }
          groupBy: {
            args: Prisma.OrderGroupByArgs<ExtArgs>
            result: $Utils.Optional<OrderGroupByOutputType>[]
          }
          count: {
            args: Prisma.OrderCountArgs<ExtArgs>
            result: $Utils.Optional<OrderCountAggregateOutputType> | number
          }
        }
      }
      NotificationToken: {
        payload: Prisma.$NotificationTokenPayload<ExtArgs>
        fields: Prisma.NotificationTokenFieldRefs
        operations: {
          findUnique: {
            args: Prisma.NotificationTokenFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NotificationTokenPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.NotificationTokenFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NotificationTokenPayload>
          }
          findFirst: {
            args: Prisma.NotificationTokenFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NotificationTokenPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.NotificationTokenFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NotificationTokenPayload>
          }
          findMany: {
            args: Prisma.NotificationTokenFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NotificationTokenPayload>[]
          }
          create: {
            args: Prisma.NotificationTokenCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NotificationTokenPayload>
          }
          createMany: {
            args: Prisma.NotificationTokenCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.NotificationTokenCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NotificationTokenPayload>[]
          }
          delete: {
            args: Prisma.NotificationTokenDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NotificationTokenPayload>
          }
          update: {
            args: Prisma.NotificationTokenUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NotificationTokenPayload>
          }
          deleteMany: {
            args: Prisma.NotificationTokenDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.NotificationTokenUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.NotificationTokenUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NotificationTokenPayload>[]
          }
          upsert: {
            args: Prisma.NotificationTokenUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NotificationTokenPayload>
          }
          aggregate: {
            args: Prisma.NotificationTokenAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateNotificationToken>
          }
          groupBy: {
            args: Prisma.NotificationTokenGroupByArgs<ExtArgs>
            result: $Utils.Optional<NotificationTokenGroupByOutputType>[]
          }
          count: {
            args: Prisma.NotificationTokenCountArgs<ExtArgs>
            result: $Utils.Optional<NotificationTokenCountAggregateOutputType> | number
          }
        }
      }
      SupportTicket: {
        payload: Prisma.$SupportTicketPayload<ExtArgs>
        fields: Prisma.SupportTicketFieldRefs
        operations: {
          findUnique: {
            args: Prisma.SupportTicketFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SupportTicketPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.SupportTicketFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SupportTicketPayload>
          }
          findFirst: {
            args: Prisma.SupportTicketFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SupportTicketPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.SupportTicketFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SupportTicketPayload>
          }
          findMany: {
            args: Prisma.SupportTicketFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SupportTicketPayload>[]
          }
          create: {
            args: Prisma.SupportTicketCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SupportTicketPayload>
          }
          createMany: {
            args: Prisma.SupportTicketCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.SupportTicketCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SupportTicketPayload>[]
          }
          delete: {
            args: Prisma.SupportTicketDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SupportTicketPayload>
          }
          update: {
            args: Prisma.SupportTicketUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SupportTicketPayload>
          }
          deleteMany: {
            args: Prisma.SupportTicketDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.SupportTicketUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.SupportTicketUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SupportTicketPayload>[]
          }
          upsert: {
            args: Prisma.SupportTicketUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SupportTicketPayload>
          }
          aggregate: {
            args: Prisma.SupportTicketAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateSupportTicket>
          }
          groupBy: {
            args: Prisma.SupportTicketGroupByArgs<ExtArgs>
            result: $Utils.Optional<SupportTicketGroupByOutputType>[]
          }
          count: {
            args: Prisma.SupportTicketCountArgs<ExtArgs>
            result: $Utils.Optional<SupportTicketCountAggregateOutputType> | number
          }
        }
      }
      AppEvent: {
        payload: Prisma.$AppEventPayload<ExtArgs>
        fields: Prisma.AppEventFieldRefs
        operations: {
          findUnique: {
            args: Prisma.AppEventFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AppEventPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.AppEventFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AppEventPayload>
          }
          findFirst: {
            args: Prisma.AppEventFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AppEventPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.AppEventFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AppEventPayload>
          }
          findMany: {
            args: Prisma.AppEventFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AppEventPayload>[]
          }
          create: {
            args: Prisma.AppEventCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AppEventPayload>
          }
          createMany: {
            args: Prisma.AppEventCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.AppEventCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AppEventPayload>[]
          }
          delete: {
            args: Prisma.AppEventDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AppEventPayload>
          }
          update: {
            args: Prisma.AppEventUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AppEventPayload>
          }
          deleteMany: {
            args: Prisma.AppEventDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.AppEventUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.AppEventUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AppEventPayload>[]
          }
          upsert: {
            args: Prisma.AppEventUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AppEventPayload>
          }
          aggregate: {
            args: Prisma.AppEventAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateAppEvent>
          }
          groupBy: {
            args: Prisma.AppEventGroupByArgs<ExtArgs>
            result: $Utils.Optional<AppEventGroupByOutputType>[]
          }
          count: {
            args: Prisma.AppEventCountArgs<ExtArgs>
            result: $Utils.Optional<AppEventCountAggregateOutputType> | number
          }
        }
      }
      DailyStats: {
        payload: Prisma.$DailyStatsPayload<ExtArgs>
        fields: Prisma.DailyStatsFieldRefs
        operations: {
          findUnique: {
            args: Prisma.DailyStatsFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DailyStatsPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.DailyStatsFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DailyStatsPayload>
          }
          findFirst: {
            args: Prisma.DailyStatsFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DailyStatsPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.DailyStatsFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DailyStatsPayload>
          }
          findMany: {
            args: Prisma.DailyStatsFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DailyStatsPayload>[]
          }
          create: {
            args: Prisma.DailyStatsCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DailyStatsPayload>
          }
          createMany: {
            args: Prisma.DailyStatsCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.DailyStatsCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DailyStatsPayload>[]
          }
          delete: {
            args: Prisma.DailyStatsDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DailyStatsPayload>
          }
          update: {
            args: Prisma.DailyStatsUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DailyStatsPayload>
          }
          deleteMany: {
            args: Prisma.DailyStatsDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.DailyStatsUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.DailyStatsUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DailyStatsPayload>[]
          }
          upsert: {
            args: Prisma.DailyStatsUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DailyStatsPayload>
          }
          aggregate: {
            args: Prisma.DailyStatsAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateDailyStats>
          }
          groupBy: {
            args: Prisma.DailyStatsGroupByArgs<ExtArgs>
            result: $Utils.Optional<DailyStatsGroupByOutputType>[]
          }
          count: {
            args: Prisma.DailyStatsCountArgs<ExtArgs>
            result: $Utils.Optional<DailyStatsCountAggregateOutputType> | number
          }
        }
      }
      PartnerDailyStats: {
        payload: Prisma.$PartnerDailyStatsPayload<ExtArgs>
        fields: Prisma.PartnerDailyStatsFieldRefs
        operations: {
          findUnique: {
            args: Prisma.PartnerDailyStatsFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PartnerDailyStatsPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.PartnerDailyStatsFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PartnerDailyStatsPayload>
          }
          findFirst: {
            args: Prisma.PartnerDailyStatsFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PartnerDailyStatsPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.PartnerDailyStatsFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PartnerDailyStatsPayload>
          }
          findMany: {
            args: Prisma.PartnerDailyStatsFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PartnerDailyStatsPayload>[]
          }
          create: {
            args: Prisma.PartnerDailyStatsCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PartnerDailyStatsPayload>
          }
          createMany: {
            args: Prisma.PartnerDailyStatsCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.PartnerDailyStatsCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PartnerDailyStatsPayload>[]
          }
          delete: {
            args: Prisma.PartnerDailyStatsDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PartnerDailyStatsPayload>
          }
          update: {
            args: Prisma.PartnerDailyStatsUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PartnerDailyStatsPayload>
          }
          deleteMany: {
            args: Prisma.PartnerDailyStatsDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.PartnerDailyStatsUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.PartnerDailyStatsUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PartnerDailyStatsPayload>[]
          }
          upsert: {
            args: Prisma.PartnerDailyStatsUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PartnerDailyStatsPayload>
          }
          aggregate: {
            args: Prisma.PartnerDailyStatsAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregatePartnerDailyStats>
          }
          groupBy: {
            args: Prisma.PartnerDailyStatsGroupByArgs<ExtArgs>
            result: $Utils.Optional<PartnerDailyStatsGroupByOutputType>[]
          }
          count: {
            args: Prisma.PartnerDailyStatsCountArgs<ExtArgs>
            result: $Utils.Optional<PartnerDailyStatsCountAggregateOutputType> | number
          }
        }
      }
      PartnerRevenue: {
        payload: Prisma.$PartnerRevenuePayload<ExtArgs>
        fields: Prisma.PartnerRevenueFieldRefs
        operations: {
          findUnique: {
            args: Prisma.PartnerRevenueFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PartnerRevenuePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.PartnerRevenueFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PartnerRevenuePayload>
          }
          findFirst: {
            args: Prisma.PartnerRevenueFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PartnerRevenuePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.PartnerRevenueFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PartnerRevenuePayload>
          }
          findMany: {
            args: Prisma.PartnerRevenueFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PartnerRevenuePayload>[]
          }
          create: {
            args: Prisma.PartnerRevenueCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PartnerRevenuePayload>
          }
          createMany: {
            args: Prisma.PartnerRevenueCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.PartnerRevenueCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PartnerRevenuePayload>[]
          }
          delete: {
            args: Prisma.PartnerRevenueDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PartnerRevenuePayload>
          }
          update: {
            args: Prisma.PartnerRevenueUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PartnerRevenuePayload>
          }
          deleteMany: {
            args: Prisma.PartnerRevenueDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.PartnerRevenueUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.PartnerRevenueUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PartnerRevenuePayload>[]
          }
          upsert: {
            args: Prisma.PartnerRevenueUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PartnerRevenuePayload>
          }
          aggregate: {
            args: Prisma.PartnerRevenueAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregatePartnerRevenue>
          }
          groupBy: {
            args: Prisma.PartnerRevenueGroupByArgs<ExtArgs>
            result: $Utils.Optional<PartnerRevenueGroupByOutputType>[]
          }
          count: {
            args: Prisma.PartnerRevenueCountArgs<ExtArgs>
            result: $Utils.Optional<PartnerRevenueCountAggregateOutputType> | number
          }
        }
      }
      PlatformRevenue: {
        payload: Prisma.$PlatformRevenuePayload<ExtArgs>
        fields: Prisma.PlatformRevenueFieldRefs
        operations: {
          findUnique: {
            args: Prisma.PlatformRevenueFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PlatformRevenuePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.PlatformRevenueFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PlatformRevenuePayload>
          }
          findFirst: {
            args: Prisma.PlatformRevenueFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PlatformRevenuePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.PlatformRevenueFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PlatformRevenuePayload>
          }
          findMany: {
            args: Prisma.PlatformRevenueFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PlatformRevenuePayload>[]
          }
          create: {
            args: Prisma.PlatformRevenueCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PlatformRevenuePayload>
          }
          createMany: {
            args: Prisma.PlatformRevenueCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.PlatformRevenueCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PlatformRevenuePayload>[]
          }
          delete: {
            args: Prisma.PlatformRevenueDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PlatformRevenuePayload>
          }
          update: {
            args: Prisma.PlatformRevenueUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PlatformRevenuePayload>
          }
          deleteMany: {
            args: Prisma.PlatformRevenueDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.PlatformRevenueUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.PlatformRevenueUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PlatformRevenuePayload>[]
          }
          upsert: {
            args: Prisma.PlatformRevenueUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PlatformRevenuePayload>
          }
          aggregate: {
            args: Prisma.PlatformRevenueAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregatePlatformRevenue>
          }
          groupBy: {
            args: Prisma.PlatformRevenueGroupByArgs<ExtArgs>
            result: $Utils.Optional<PlatformRevenueGroupByOutputType>[]
          }
          count: {
            args: Prisma.PlatformRevenueCountArgs<ExtArgs>
            result: $Utils.Optional<PlatformRevenueCountAggregateOutputType> | number
          }
        }
      }
      AdminWallet: {
        payload: Prisma.$AdminWalletPayload<ExtArgs>
        fields: Prisma.AdminWalletFieldRefs
        operations: {
          findUnique: {
            args: Prisma.AdminWalletFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AdminWalletPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.AdminWalletFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AdminWalletPayload>
          }
          findFirst: {
            args: Prisma.AdminWalletFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AdminWalletPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.AdminWalletFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AdminWalletPayload>
          }
          findMany: {
            args: Prisma.AdminWalletFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AdminWalletPayload>[]
          }
          create: {
            args: Prisma.AdminWalletCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AdminWalletPayload>
          }
          createMany: {
            args: Prisma.AdminWalletCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.AdminWalletCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AdminWalletPayload>[]
          }
          delete: {
            args: Prisma.AdminWalletDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AdminWalletPayload>
          }
          update: {
            args: Prisma.AdminWalletUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AdminWalletPayload>
          }
          deleteMany: {
            args: Prisma.AdminWalletDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.AdminWalletUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.AdminWalletUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AdminWalletPayload>[]
          }
          upsert: {
            args: Prisma.AdminWalletUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AdminWalletPayload>
          }
          aggregate: {
            args: Prisma.AdminWalletAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateAdminWallet>
          }
          groupBy: {
            args: Prisma.AdminWalletGroupByArgs<ExtArgs>
            result: $Utils.Optional<AdminWalletGroupByOutputType>[]
          }
          count: {
            args: Prisma.AdminWalletCountArgs<ExtArgs>
            result: $Utils.Optional<AdminWalletCountAggregateOutputType> | number
          }
        }
      }
      AgentWallet: {
        payload: Prisma.$AgentWalletPayload<ExtArgs>
        fields: Prisma.AgentWalletFieldRefs
        operations: {
          findUnique: {
            args: Prisma.AgentWalletFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AgentWalletPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.AgentWalletFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AgentWalletPayload>
          }
          findFirst: {
            args: Prisma.AgentWalletFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AgentWalletPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.AgentWalletFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AgentWalletPayload>
          }
          findMany: {
            args: Prisma.AgentWalletFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AgentWalletPayload>[]
          }
          create: {
            args: Prisma.AgentWalletCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AgentWalletPayload>
          }
          createMany: {
            args: Prisma.AgentWalletCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.AgentWalletCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AgentWalletPayload>[]
          }
          delete: {
            args: Prisma.AgentWalletDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AgentWalletPayload>
          }
          update: {
            args: Prisma.AgentWalletUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AgentWalletPayload>
          }
          deleteMany: {
            args: Prisma.AgentWalletDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.AgentWalletUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.AgentWalletUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AgentWalletPayload>[]
          }
          upsert: {
            args: Prisma.AgentWalletUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AgentWalletPayload>
          }
          aggregate: {
            args: Prisma.AgentWalletAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateAgentWallet>
          }
          groupBy: {
            args: Prisma.AgentWalletGroupByArgs<ExtArgs>
            result: $Utils.Optional<AgentWalletGroupByOutputType>[]
          }
          count: {
            args: Prisma.AgentWalletCountArgs<ExtArgs>
            result: $Utils.Optional<AgentWalletCountAggregateOutputType> | number
          }
        }
      }
      WalletTransaction: {
        payload: Prisma.$WalletTransactionPayload<ExtArgs>
        fields: Prisma.WalletTransactionFieldRefs
        operations: {
          findUnique: {
            args: Prisma.WalletTransactionFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WalletTransactionPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.WalletTransactionFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WalletTransactionPayload>
          }
          findFirst: {
            args: Prisma.WalletTransactionFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WalletTransactionPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.WalletTransactionFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WalletTransactionPayload>
          }
          findMany: {
            args: Prisma.WalletTransactionFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WalletTransactionPayload>[]
          }
          create: {
            args: Prisma.WalletTransactionCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WalletTransactionPayload>
          }
          createMany: {
            args: Prisma.WalletTransactionCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.WalletTransactionCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WalletTransactionPayload>[]
          }
          delete: {
            args: Prisma.WalletTransactionDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WalletTransactionPayload>
          }
          update: {
            args: Prisma.WalletTransactionUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WalletTransactionPayload>
          }
          deleteMany: {
            args: Prisma.WalletTransactionDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.WalletTransactionUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.WalletTransactionUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WalletTransactionPayload>[]
          }
          upsert: {
            args: Prisma.WalletTransactionUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WalletTransactionPayload>
          }
          aggregate: {
            args: Prisma.WalletTransactionAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateWalletTransaction>
          }
          groupBy: {
            args: Prisma.WalletTransactionGroupByArgs<ExtArgs>
            result: $Utils.Optional<WalletTransactionGroupByOutputType>[]
          }
          count: {
            args: Prisma.WalletTransactionCountArgs<ExtArgs>
            result: $Utils.Optional<WalletTransactionCountAggregateOutputType> | number
          }
        }
      }
      WalletPayout: {
        payload: Prisma.$WalletPayoutPayload<ExtArgs>
        fields: Prisma.WalletPayoutFieldRefs
        operations: {
          findUnique: {
            args: Prisma.WalletPayoutFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WalletPayoutPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.WalletPayoutFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WalletPayoutPayload>
          }
          findFirst: {
            args: Prisma.WalletPayoutFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WalletPayoutPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.WalletPayoutFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WalletPayoutPayload>
          }
          findMany: {
            args: Prisma.WalletPayoutFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WalletPayoutPayload>[]
          }
          create: {
            args: Prisma.WalletPayoutCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WalletPayoutPayload>
          }
          createMany: {
            args: Prisma.WalletPayoutCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.WalletPayoutCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WalletPayoutPayload>[]
          }
          delete: {
            args: Prisma.WalletPayoutDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WalletPayoutPayload>
          }
          update: {
            args: Prisma.WalletPayoutUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WalletPayoutPayload>
          }
          deleteMany: {
            args: Prisma.WalletPayoutDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.WalletPayoutUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.WalletPayoutUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WalletPayoutPayload>[]
          }
          upsert: {
            args: Prisma.WalletPayoutUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WalletPayoutPayload>
          }
          aggregate: {
            args: Prisma.WalletPayoutAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateWalletPayout>
          }
          groupBy: {
            args: Prisma.WalletPayoutGroupByArgs<ExtArgs>
            result: $Utils.Optional<WalletPayoutGroupByOutputType>[]
          }
          count: {
            args: Prisma.WalletPayoutCountArgs<ExtArgs>
            result: $Utils.Optional<WalletPayoutCountAggregateOutputType> | number
          }
        }
      }
      Notification: {
        payload: Prisma.$NotificationPayload<ExtArgs>
        fields: Prisma.NotificationFieldRefs
        operations: {
          findUnique: {
            args: Prisma.NotificationFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NotificationPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.NotificationFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NotificationPayload>
          }
          findFirst: {
            args: Prisma.NotificationFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NotificationPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.NotificationFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NotificationPayload>
          }
          findMany: {
            args: Prisma.NotificationFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NotificationPayload>[]
          }
          create: {
            args: Prisma.NotificationCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NotificationPayload>
          }
          createMany: {
            args: Prisma.NotificationCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.NotificationCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NotificationPayload>[]
          }
          delete: {
            args: Prisma.NotificationDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NotificationPayload>
          }
          update: {
            args: Prisma.NotificationUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NotificationPayload>
          }
          deleteMany: {
            args: Prisma.NotificationDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.NotificationUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.NotificationUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NotificationPayload>[]
          }
          upsert: {
            args: Prisma.NotificationUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NotificationPayload>
          }
          aggregate: {
            args: Prisma.NotificationAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateNotification>
          }
          groupBy: {
            args: Prisma.NotificationGroupByArgs<ExtArgs>
            result: $Utils.Optional<NotificationGroupByOutputType>[]
          }
          count: {
            args: Prisma.NotificationCountArgs<ExtArgs>
            result: $Utils.Optional<NotificationCountAggregateOutputType> | number
          }
        }
      }
      AgentRating: {
        payload: Prisma.$AgentRatingPayload<ExtArgs>
        fields: Prisma.AgentRatingFieldRefs
        operations: {
          findUnique: {
            args: Prisma.AgentRatingFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AgentRatingPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.AgentRatingFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AgentRatingPayload>
          }
          findFirst: {
            args: Prisma.AgentRatingFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AgentRatingPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.AgentRatingFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AgentRatingPayload>
          }
          findMany: {
            args: Prisma.AgentRatingFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AgentRatingPayload>[]
          }
          create: {
            args: Prisma.AgentRatingCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AgentRatingPayload>
          }
          createMany: {
            args: Prisma.AgentRatingCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.AgentRatingCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AgentRatingPayload>[]
          }
          delete: {
            args: Prisma.AgentRatingDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AgentRatingPayload>
          }
          update: {
            args: Prisma.AgentRatingUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AgentRatingPayload>
          }
          deleteMany: {
            args: Prisma.AgentRatingDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.AgentRatingUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.AgentRatingUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AgentRatingPayload>[]
          }
          upsert: {
            args: Prisma.AgentRatingUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AgentRatingPayload>
          }
          aggregate: {
            args: Prisma.AgentRatingAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateAgentRating>
          }
          groupBy: {
            args: Prisma.AgentRatingGroupByArgs<ExtArgs>
            result: $Utils.Optional<AgentRatingGroupByOutputType>[]
          }
          count: {
            args: Prisma.AgentRatingCountArgs<ExtArgs>
            result: $Utils.Optional<AgentRatingCountAggregateOutputType> | number
          }
        }
      }
      Payment: {
        payload: Prisma.$PaymentPayload<ExtArgs>
        fields: Prisma.PaymentFieldRefs
        operations: {
          findUnique: {
            args: Prisma.PaymentFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PaymentPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.PaymentFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PaymentPayload>
          }
          findFirst: {
            args: Prisma.PaymentFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PaymentPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.PaymentFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PaymentPayload>
          }
          findMany: {
            args: Prisma.PaymentFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PaymentPayload>[]
          }
          create: {
            args: Prisma.PaymentCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PaymentPayload>
          }
          createMany: {
            args: Prisma.PaymentCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.PaymentCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PaymentPayload>[]
          }
          delete: {
            args: Prisma.PaymentDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PaymentPayload>
          }
          update: {
            args: Prisma.PaymentUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PaymentPayload>
          }
          deleteMany: {
            args: Prisma.PaymentDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.PaymentUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.PaymentUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PaymentPayload>[]
          }
          upsert: {
            args: Prisma.PaymentUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PaymentPayload>
          }
          aggregate: {
            args: Prisma.PaymentAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregatePayment>
          }
          groupBy: {
            args: Prisma.PaymentGroupByArgs<ExtArgs>
            result: $Utils.Optional<PaymentGroupByOutputType>[]
          }
          count: {
            args: Prisma.PaymentCountArgs<ExtArgs>
            result: $Utils.Optional<PaymentCountAggregateOutputType> | number
          }
        }
      }
      Payroll: {
        payload: Prisma.$PayrollPayload<ExtArgs>
        fields: Prisma.PayrollFieldRefs
        operations: {
          findUnique: {
            args: Prisma.PayrollFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PayrollPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.PayrollFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PayrollPayload>
          }
          findFirst: {
            args: Prisma.PayrollFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PayrollPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.PayrollFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PayrollPayload>
          }
          findMany: {
            args: Prisma.PayrollFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PayrollPayload>[]
          }
          create: {
            args: Prisma.PayrollCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PayrollPayload>
          }
          createMany: {
            args: Prisma.PayrollCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.PayrollCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PayrollPayload>[]
          }
          delete: {
            args: Prisma.PayrollDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PayrollPayload>
          }
          update: {
            args: Prisma.PayrollUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PayrollPayload>
          }
          deleteMany: {
            args: Prisma.PayrollDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.PayrollUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.PayrollUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PayrollPayload>[]
          }
          upsert: {
            args: Prisma.PayrollUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PayrollPayload>
          }
          aggregate: {
            args: Prisma.PayrollAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregatePayroll>
          }
          groupBy: {
            args: Prisma.PayrollGroupByArgs<ExtArgs>
            result: $Utils.Optional<PayrollGroupByOutputType>[]
          }
          count: {
            args: Prisma.PayrollCountArgs<ExtArgs>
            result: $Utils.Optional<PayrollCountAggregateOutputType> | number
          }
        }
      }
      AgentSchedule: {
        payload: Prisma.$AgentSchedulePayload<ExtArgs>
        fields: Prisma.AgentScheduleFieldRefs
        operations: {
          findUnique: {
            args: Prisma.AgentScheduleFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AgentSchedulePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.AgentScheduleFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AgentSchedulePayload>
          }
          findFirst: {
            args: Prisma.AgentScheduleFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AgentSchedulePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.AgentScheduleFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AgentSchedulePayload>
          }
          findMany: {
            args: Prisma.AgentScheduleFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AgentSchedulePayload>[]
          }
          create: {
            args: Prisma.AgentScheduleCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AgentSchedulePayload>
          }
          createMany: {
            args: Prisma.AgentScheduleCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.AgentScheduleCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AgentSchedulePayload>[]
          }
          delete: {
            args: Prisma.AgentScheduleDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AgentSchedulePayload>
          }
          update: {
            args: Prisma.AgentScheduleUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AgentSchedulePayload>
          }
          deleteMany: {
            args: Prisma.AgentScheduleDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.AgentScheduleUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.AgentScheduleUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AgentSchedulePayload>[]
          }
          upsert: {
            args: Prisma.AgentScheduleUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AgentSchedulePayload>
          }
          aggregate: {
            args: Prisma.AgentScheduleAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateAgentSchedule>
          }
          groupBy: {
            args: Prisma.AgentScheduleGroupByArgs<ExtArgs>
            result: $Utils.Optional<AgentScheduleGroupByOutputType>[]
          }
          count: {
            args: Prisma.AgentScheduleCountArgs<ExtArgs>
            result: $Utils.Optional<AgentScheduleCountAggregateOutputType> | number
          }
        }
      }
      PayStructure: {
        payload: Prisma.$PayStructurePayload<ExtArgs>
        fields: Prisma.PayStructureFieldRefs
        operations: {
          findUnique: {
            args: Prisma.PayStructureFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PayStructurePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.PayStructureFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PayStructurePayload>
          }
          findFirst: {
            args: Prisma.PayStructureFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PayStructurePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.PayStructureFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PayStructurePayload>
          }
          findMany: {
            args: Prisma.PayStructureFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PayStructurePayload>[]
          }
          create: {
            args: Prisma.PayStructureCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PayStructurePayload>
          }
          createMany: {
            args: Prisma.PayStructureCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.PayStructureCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PayStructurePayload>[]
          }
          delete: {
            args: Prisma.PayStructureDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PayStructurePayload>
          }
          update: {
            args: Prisma.PayStructureUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PayStructurePayload>
          }
          deleteMany: {
            args: Prisma.PayStructureDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.PayStructureUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.PayStructureUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PayStructurePayload>[]
          }
          upsert: {
            args: Prisma.PayStructureUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PayStructurePayload>
          }
          aggregate: {
            args: Prisma.PayStructureAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregatePayStructure>
          }
          groupBy: {
            args: Prisma.PayStructureGroupByArgs<ExtArgs>
            result: $Utils.Optional<PayStructureGroupByOutputType>[]
          }
          count: {
            args: Prisma.PayStructureCountArgs<ExtArgs>
            result: $Utils.Optional<PayStructureCountAggregateOutputType> | number
          }
        }
      }
    }
  } & {
    other: {
      payload: any
      operations: {
        $executeRaw: {
          args: [query: TemplateStringsArray | Prisma.Sql, ...values: any[]],
          result: any
        }
        $executeRawUnsafe: {
          args: [query: string, ...values: any[]],
          result: any
        }
        $queryRaw: {
          args: [query: TemplateStringsArray | Prisma.Sql, ...values: any[]],
          result: any
        }
        $queryRawUnsafe: {
          args: [query: string, ...values: any[]],
          result: any
        }
      }
    }
  }
  export const defineExtension: $Extensions.ExtendsHook<"define", Prisma.TypeMapCb, $Extensions.DefaultArgs>
  export type DefaultPrismaClient = PrismaClient
  export type ErrorFormat = 'pretty' | 'colorless' | 'minimal'
  export interface PrismaClientOptions {
    /**
     * Overwrites the datasource url from your schema.prisma file
     */
    datasources?: Datasources
    /**
     * Overwrites the datasource url from your schema.prisma file
     */
    datasourceUrl?: string
    /**
     * @default "colorless"
     */
    errorFormat?: ErrorFormat
    /**
     * @example
     * ```
     * // Shorthand for `emit: 'stdout'`
     * log: ['query', 'info', 'warn', 'error']
     * 
     * // Emit as events only
     * log: [
     *   { emit: 'event', level: 'query' },
     *   { emit: 'event', level: 'info' },
     *   { emit: 'event', level: 'warn' }
     *   { emit: 'event', level: 'error' }
     * ]
     * 
     * / Emit as events and log to stdout
     * og: [
     *  { emit: 'stdout', level: 'query' },
     *  { emit: 'stdout', level: 'info' },
     *  { emit: 'stdout', level: 'warn' }
     *  { emit: 'stdout', level: 'error' }
     * 
     * ```
     * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/logging#the-log-option).
     */
    log?: (LogLevel | LogDefinition)[]
    /**
     * The default values for transactionOptions
     * maxWait ?= 2000
     * timeout ?= 5000
     */
    transactionOptions?: {
      maxWait?: number
      timeout?: number
      isolationLevel?: Prisma.TransactionIsolationLevel
    }
    /**
     * Instance of a Driver Adapter, e.g., like one provided by `@prisma/adapter-planetscale`
     */
    adapter?: runtime.SqlDriverAdapterFactory | null
    /**
     * Global configuration for omitting model fields by default.
     * 
     * @example
     * ```
     * const prisma = new PrismaClient({
     *   omit: {
     *     user: {
     *       password: true
     *     }
     *   }
     * })
     * ```
     */
    omit?: Prisma.GlobalOmitConfig
  }
  export type GlobalOmitConfig = {
    user?: UserOmit
    agent?: AgentOmit
    agentDocument?: AgentDocumentOmit
    agentLocation?: AgentLocationOmit
    partner?: PartnerOmit
    order?: OrderOmit
    notificationToken?: NotificationTokenOmit
    supportTicket?: SupportTicketOmit
    appEvent?: AppEventOmit
    dailyStats?: DailyStatsOmit
    partnerDailyStats?: PartnerDailyStatsOmit
    partnerRevenue?: PartnerRevenueOmit
    platformRevenue?: PlatformRevenueOmit
    adminWallet?: AdminWalletOmit
    agentWallet?: AgentWalletOmit
    walletTransaction?: WalletTransactionOmit
    walletPayout?: WalletPayoutOmit
    notification?: NotificationOmit
    agentRating?: AgentRatingOmit
    payment?: PaymentOmit
    payroll?: PayrollOmit
    agentSchedule?: AgentScheduleOmit
    payStructure?: PayStructureOmit
  }

  /* Types for Logging */
  export type LogLevel = 'info' | 'query' | 'warn' | 'error'
  export type LogDefinition = {
    level: LogLevel
    emit: 'stdout' | 'event'
  }

  export type CheckIsLogLevel<T> = T extends LogLevel ? T : never;

  export type GetLogType<T> = CheckIsLogLevel<
    T extends LogDefinition ? T['level'] : T
  >;

  export type GetEvents<T extends any[]> = T extends Array<LogLevel | LogDefinition>
    ? GetLogType<T[number]>
    : never;

  export type QueryEvent = {
    timestamp: Date
    query: string
    params: string
    duration: number
    target: string
  }

  export type LogEvent = {
    timestamp: Date
    message: string
    target: string
  }
  /* End Types for Logging */


  export type PrismaAction =
    | 'findUnique'
    | 'findUniqueOrThrow'
    | 'findMany'
    | 'findFirst'
    | 'findFirstOrThrow'
    | 'create'
    | 'createMany'
    | 'createManyAndReturn'
    | 'update'
    | 'updateMany'
    | 'updateManyAndReturn'
    | 'upsert'
    | 'delete'
    | 'deleteMany'
    | 'executeRaw'
    | 'queryRaw'
    | 'aggregate'
    | 'count'
    | 'runCommandRaw'
    | 'findRaw'
    | 'groupBy'

  // tested in getLogLevel.test.ts
  export function getLogLevel(log: Array<LogLevel | LogDefinition>): LogLevel | undefined;

  /**
   * `PrismaClient` proxy available in interactive transactions.
   */
  export type TransactionClient = Omit<Prisma.DefaultPrismaClient, runtime.ITXClientDenyList>

  export type Datasource = {
    url?: string
  }

  /**
   * Count Types
   */


  /**
   * Count Type UserCountOutputType
   */

  export type UserCountOutputType = {
    notifications: number
    userNotifications: number
    tickets: number
  }

  export type UserCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    notifications?: boolean | UserCountOutputTypeCountNotificationsArgs
    userNotifications?: boolean | UserCountOutputTypeCountUserNotificationsArgs
    tickets?: boolean | UserCountOutputTypeCountTicketsArgs
  }

  // Custom InputTypes
  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserCountOutputType
     */
    select?: UserCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountNotificationsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: NotificationTokenWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountUserNotificationsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: NotificationWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountTicketsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: SupportTicketWhereInput
  }


  /**
   * Count Type AgentCountOutputType
   */

  export type AgentCountOutputType = {
    orders: number
    documents: number
    locationHistory: number
    tickets: number
    ratings: number
    walletPayouts: number
    payments: number
    payrolls: number
    schedules: number
  }

  export type AgentCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    orders?: boolean | AgentCountOutputTypeCountOrdersArgs
    documents?: boolean | AgentCountOutputTypeCountDocumentsArgs
    locationHistory?: boolean | AgentCountOutputTypeCountLocationHistoryArgs
    tickets?: boolean | AgentCountOutputTypeCountTicketsArgs
    ratings?: boolean | AgentCountOutputTypeCountRatingsArgs
    walletPayouts?: boolean | AgentCountOutputTypeCountWalletPayoutsArgs
    payments?: boolean | AgentCountOutputTypeCountPaymentsArgs
    payrolls?: boolean | AgentCountOutputTypeCountPayrollsArgs
    schedules?: boolean | AgentCountOutputTypeCountSchedulesArgs
  }

  // Custom InputTypes
  /**
   * AgentCountOutputType without action
   */
  export type AgentCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AgentCountOutputType
     */
    select?: AgentCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * AgentCountOutputType without action
   */
  export type AgentCountOutputTypeCountOrdersArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: OrderWhereInput
  }

  /**
   * AgentCountOutputType without action
   */
  export type AgentCountOutputTypeCountDocumentsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: AgentDocumentWhereInput
  }

  /**
   * AgentCountOutputType without action
   */
  export type AgentCountOutputTypeCountLocationHistoryArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: AgentLocationWhereInput
  }

  /**
   * AgentCountOutputType without action
   */
  export type AgentCountOutputTypeCountTicketsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: SupportTicketWhereInput
  }

  /**
   * AgentCountOutputType without action
   */
  export type AgentCountOutputTypeCountRatingsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: AgentRatingWhereInput
  }

  /**
   * AgentCountOutputType without action
   */
  export type AgentCountOutputTypeCountWalletPayoutsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: WalletPayoutWhereInput
  }

  /**
   * AgentCountOutputType without action
   */
  export type AgentCountOutputTypeCountPaymentsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: PaymentWhereInput
  }

  /**
   * AgentCountOutputType without action
   */
  export type AgentCountOutputTypeCountPayrollsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: PayrollWhereInput
  }

  /**
   * AgentCountOutputType without action
   */
  export type AgentCountOutputTypeCountSchedulesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: AgentScheduleWhereInput
  }


  /**
   * Count Type PartnerCountOutputType
   */

  export type PartnerCountOutputType = {
    orders: number
    tickets: number
    dailyStats: number
    agentRatings: number
    partnerRevenues: number
    platformRevenues: number
  }

  export type PartnerCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    orders?: boolean | PartnerCountOutputTypeCountOrdersArgs
    tickets?: boolean | PartnerCountOutputTypeCountTicketsArgs
    dailyStats?: boolean | PartnerCountOutputTypeCountDailyStatsArgs
    agentRatings?: boolean | PartnerCountOutputTypeCountAgentRatingsArgs
    partnerRevenues?: boolean | PartnerCountOutputTypeCountPartnerRevenuesArgs
    platformRevenues?: boolean | PartnerCountOutputTypeCountPlatformRevenuesArgs
  }

  // Custom InputTypes
  /**
   * PartnerCountOutputType without action
   */
  export type PartnerCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PartnerCountOutputType
     */
    select?: PartnerCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * PartnerCountOutputType without action
   */
  export type PartnerCountOutputTypeCountOrdersArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: OrderWhereInput
  }

  /**
   * PartnerCountOutputType without action
   */
  export type PartnerCountOutputTypeCountTicketsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: SupportTicketWhereInput
  }

  /**
   * PartnerCountOutputType without action
   */
  export type PartnerCountOutputTypeCountDailyStatsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: PartnerDailyStatsWhereInput
  }

  /**
   * PartnerCountOutputType without action
   */
  export type PartnerCountOutputTypeCountAgentRatingsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: AgentRatingWhereInput
  }

  /**
   * PartnerCountOutputType without action
   */
  export type PartnerCountOutputTypeCountPartnerRevenuesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: PartnerRevenueWhereInput
  }

  /**
   * PartnerCountOutputType without action
   */
  export type PartnerCountOutputTypeCountPlatformRevenuesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: PlatformRevenueWhereInput
  }


  /**
   * Count Type OrderCountOutputType
   */

  export type OrderCountOutputType = {
    tickets: number
    payments: number
    walletTransactions: number
  }

  export type OrderCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    tickets?: boolean | OrderCountOutputTypeCountTicketsArgs
    payments?: boolean | OrderCountOutputTypeCountPaymentsArgs
    walletTransactions?: boolean | OrderCountOutputTypeCountWalletTransactionsArgs
  }

  // Custom InputTypes
  /**
   * OrderCountOutputType without action
   */
  export type OrderCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the OrderCountOutputType
     */
    select?: OrderCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * OrderCountOutputType without action
   */
  export type OrderCountOutputTypeCountTicketsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: SupportTicketWhereInput
  }

  /**
   * OrderCountOutputType without action
   */
  export type OrderCountOutputTypeCountPaymentsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: PaymentWhereInput
  }

  /**
   * OrderCountOutputType without action
   */
  export type OrderCountOutputTypeCountWalletTransactionsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: WalletTransactionWhereInput
  }


  /**
   * Count Type AdminWalletCountOutputType
   */

  export type AdminWalletCountOutputType = {
    transactions: number
  }

  export type AdminWalletCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    transactions?: boolean | AdminWalletCountOutputTypeCountTransactionsArgs
  }

  // Custom InputTypes
  /**
   * AdminWalletCountOutputType without action
   */
  export type AdminWalletCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AdminWalletCountOutputType
     */
    select?: AdminWalletCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * AdminWalletCountOutputType without action
   */
  export type AdminWalletCountOutputTypeCountTransactionsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: WalletTransactionWhereInput
  }


  /**
   * Count Type AgentWalletCountOutputType
   */

  export type AgentWalletCountOutputType = {
    transactions: number
    payouts: number
  }

  export type AgentWalletCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    transactions?: boolean | AgentWalletCountOutputTypeCountTransactionsArgs
    payouts?: boolean | AgentWalletCountOutputTypeCountPayoutsArgs
  }

  // Custom InputTypes
  /**
   * AgentWalletCountOutputType without action
   */
  export type AgentWalletCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AgentWalletCountOutputType
     */
    select?: AgentWalletCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * AgentWalletCountOutputType without action
   */
  export type AgentWalletCountOutputTypeCountTransactionsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: WalletTransactionWhereInput
  }

  /**
   * AgentWalletCountOutputType without action
   */
  export type AgentWalletCountOutputTypeCountPayoutsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: WalletPayoutWhereInput
  }


  /**
   * Models
   */

  /**
   * Model User
   */

  export type AggregateUser = {
    _count: UserCountAggregateOutputType | null
    _min: UserMinAggregateOutputType | null
    _max: UserMaxAggregateOutputType | null
  }

  export type UserMinAggregateOutputType = {
    id: string | null
    name: string | null
    email: string | null
    phone: string | null
    passwordHash: string | null
    role: $Enums.UserRole | null
    emailVerified: Date | null
    phoneVerified: boolean | null
    profilePicture: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type UserMaxAggregateOutputType = {
    id: string | null
    name: string | null
    email: string | null
    phone: string | null
    passwordHash: string | null
    role: $Enums.UserRole | null
    emailVerified: Date | null
    phoneVerified: boolean | null
    profilePicture: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type UserCountAggregateOutputType = {
    id: number
    name: number
    email: number
    phone: number
    passwordHash: number
    role: number
    emailVerified: number
    phoneVerified: number
    profilePicture: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type UserMinAggregateInputType = {
    id?: true
    name?: true
    email?: true
    phone?: true
    passwordHash?: true
    role?: true
    emailVerified?: true
    phoneVerified?: true
    profilePicture?: true
    createdAt?: true
    updatedAt?: true
  }

  export type UserMaxAggregateInputType = {
    id?: true
    name?: true
    email?: true
    phone?: true
    passwordHash?: true
    role?: true
    emailVerified?: true
    phoneVerified?: true
    profilePicture?: true
    createdAt?: true
    updatedAt?: true
  }

  export type UserCountAggregateInputType = {
    id?: true
    name?: true
    email?: true
    phone?: true
    passwordHash?: true
    role?: true
    emailVerified?: true
    phoneVerified?: true
    profilePicture?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type UserAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which User to aggregate.
     */
    where?: UserWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Users to fetch.
     */
    orderBy?: UserOrderByWithRelationInput | UserOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: UserWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Users from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Users.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Users
    **/
    _count?: true | UserCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: UserMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: UserMaxAggregateInputType
  }

  export type GetUserAggregateType<T extends UserAggregateArgs> = {
        [P in keyof T & keyof AggregateUser]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateUser[P]>
      : GetScalarType<T[P], AggregateUser[P]>
  }




  export type UserGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: UserWhereInput
    orderBy?: UserOrderByWithAggregationInput | UserOrderByWithAggregationInput[]
    by: UserScalarFieldEnum[] | UserScalarFieldEnum
    having?: UserScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: UserCountAggregateInputType | true
    _min?: UserMinAggregateInputType
    _max?: UserMaxAggregateInputType
  }

  export type UserGroupByOutputType = {
    id: string
    name: string
    email: string
    phone: string
    passwordHash: string
    role: $Enums.UserRole
    emailVerified: Date | null
    phoneVerified: boolean
    profilePicture: string | null
    createdAt: Date
    updatedAt: Date
    _count: UserCountAggregateOutputType | null
    _min: UserMinAggregateOutputType | null
    _max: UserMaxAggregateOutputType | null
  }

  type GetUserGroupByPayload<T extends UserGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<UserGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof UserGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], UserGroupByOutputType[P]>
            : GetScalarType<T[P], UserGroupByOutputType[P]>
        }
      >
    >


  export type UserSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    email?: boolean
    phone?: boolean
    passwordHash?: boolean
    role?: boolean
    emailVerified?: boolean
    phoneVerified?: boolean
    profilePicture?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    agent?: boolean | User$agentArgs<ExtArgs>
    partner?: boolean | User$partnerArgs<ExtArgs>
    notifications?: boolean | User$notificationsArgs<ExtArgs>
    userNotifications?: boolean | User$userNotificationsArgs<ExtArgs>
    tickets?: boolean | User$ticketsArgs<ExtArgs>
    _count?: boolean | UserCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["user"]>

  export type UserSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    email?: boolean
    phone?: boolean
    passwordHash?: boolean
    role?: boolean
    emailVerified?: boolean
    phoneVerified?: boolean
    profilePicture?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }, ExtArgs["result"]["user"]>

  export type UserSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    email?: boolean
    phone?: boolean
    passwordHash?: boolean
    role?: boolean
    emailVerified?: boolean
    phoneVerified?: boolean
    profilePicture?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }, ExtArgs["result"]["user"]>

  export type UserSelectScalar = {
    id?: boolean
    name?: boolean
    email?: boolean
    phone?: boolean
    passwordHash?: boolean
    role?: boolean
    emailVerified?: boolean
    phoneVerified?: boolean
    profilePicture?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type UserOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "name" | "email" | "phone" | "passwordHash" | "role" | "emailVerified" | "phoneVerified" | "profilePicture" | "createdAt" | "updatedAt", ExtArgs["result"]["user"]>
  export type UserInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    agent?: boolean | User$agentArgs<ExtArgs>
    partner?: boolean | User$partnerArgs<ExtArgs>
    notifications?: boolean | User$notificationsArgs<ExtArgs>
    userNotifications?: boolean | User$userNotificationsArgs<ExtArgs>
    tickets?: boolean | User$ticketsArgs<ExtArgs>
    _count?: boolean | UserCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type UserIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}
  export type UserIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}

  export type $UserPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "User"
    objects: {
      agent: Prisma.$AgentPayload<ExtArgs> | null
      partner: Prisma.$PartnerPayload<ExtArgs> | null
      notifications: Prisma.$NotificationTokenPayload<ExtArgs>[]
      userNotifications: Prisma.$NotificationPayload<ExtArgs>[]
      tickets: Prisma.$SupportTicketPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      name: string
      email: string
      phone: string
      passwordHash: string
      role: $Enums.UserRole
      emailVerified: Date | null
      phoneVerified: boolean
      profilePicture: string | null
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["user"]>
    composites: {}
  }

  type UserGetPayload<S extends boolean | null | undefined | UserDefaultArgs> = $Result.GetResult<Prisma.$UserPayload, S>

  type UserCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<UserFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: UserCountAggregateInputType | true
    }

  export interface UserDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['User'], meta: { name: 'User' } }
    /**
     * Find zero or one User that matches the filter.
     * @param {UserFindUniqueArgs} args - Arguments to find a User
     * @example
     * // Get one User
     * const user = await prisma.user.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends UserFindUniqueArgs>(args: SelectSubset<T, UserFindUniqueArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one User that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {UserFindUniqueOrThrowArgs} args - Arguments to find a User
     * @example
     * // Get one User
     * const user = await prisma.user.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends UserFindUniqueOrThrowArgs>(args: SelectSubset<T, UserFindUniqueOrThrowArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first User that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserFindFirstArgs} args - Arguments to find a User
     * @example
     * // Get one User
     * const user = await prisma.user.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends UserFindFirstArgs>(args?: SelectSubset<T, UserFindFirstArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first User that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserFindFirstOrThrowArgs} args - Arguments to find a User
     * @example
     * // Get one User
     * const user = await prisma.user.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends UserFindFirstOrThrowArgs>(args?: SelectSubset<T, UserFindFirstOrThrowArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Users that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Users
     * const users = await prisma.user.findMany()
     * 
     * // Get first 10 Users
     * const users = await prisma.user.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const userWithIdOnly = await prisma.user.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends UserFindManyArgs>(args?: SelectSubset<T, UserFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a User.
     * @param {UserCreateArgs} args - Arguments to create a User.
     * @example
     * // Create one User
     * const User = await prisma.user.create({
     *   data: {
     *     // ... data to create a User
     *   }
     * })
     * 
     */
    create<T extends UserCreateArgs>(args: SelectSubset<T, UserCreateArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Users.
     * @param {UserCreateManyArgs} args - Arguments to create many Users.
     * @example
     * // Create many Users
     * const user = await prisma.user.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends UserCreateManyArgs>(args?: SelectSubset<T, UserCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Users and returns the data saved in the database.
     * @param {UserCreateManyAndReturnArgs} args - Arguments to create many Users.
     * @example
     * // Create many Users
     * const user = await prisma.user.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Users and only return the `id`
     * const userWithIdOnly = await prisma.user.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends UserCreateManyAndReturnArgs>(args?: SelectSubset<T, UserCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a User.
     * @param {UserDeleteArgs} args - Arguments to delete one User.
     * @example
     * // Delete one User
     * const User = await prisma.user.delete({
     *   where: {
     *     // ... filter to delete one User
     *   }
     * })
     * 
     */
    delete<T extends UserDeleteArgs>(args: SelectSubset<T, UserDeleteArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one User.
     * @param {UserUpdateArgs} args - Arguments to update one User.
     * @example
     * // Update one User
     * const user = await prisma.user.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends UserUpdateArgs>(args: SelectSubset<T, UserUpdateArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Users.
     * @param {UserDeleteManyArgs} args - Arguments to filter Users to delete.
     * @example
     * // Delete a few Users
     * const { count } = await prisma.user.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends UserDeleteManyArgs>(args?: SelectSubset<T, UserDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Users.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Users
     * const user = await prisma.user.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends UserUpdateManyArgs>(args: SelectSubset<T, UserUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Users and returns the data updated in the database.
     * @param {UserUpdateManyAndReturnArgs} args - Arguments to update many Users.
     * @example
     * // Update many Users
     * const user = await prisma.user.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Users and only return the `id`
     * const userWithIdOnly = await prisma.user.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends UserUpdateManyAndReturnArgs>(args: SelectSubset<T, UserUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one User.
     * @param {UserUpsertArgs} args - Arguments to update or create a User.
     * @example
     * // Update or create a User
     * const user = await prisma.user.upsert({
     *   create: {
     *     // ... data to create a User
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the User we want to update
     *   }
     * })
     */
    upsert<T extends UserUpsertArgs>(args: SelectSubset<T, UserUpsertArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Users.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserCountArgs} args - Arguments to filter Users to count.
     * @example
     * // Count the number of Users
     * const count = await prisma.user.count({
     *   where: {
     *     // ... the filter for the Users we want to count
     *   }
     * })
    **/
    count<T extends UserCountArgs>(
      args?: Subset<T, UserCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], UserCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a User.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends UserAggregateArgs>(args: Subset<T, UserAggregateArgs>): Prisma.PrismaPromise<GetUserAggregateType<T>>

    /**
     * Group by User.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends UserGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: UserGroupByArgs['orderBy'] }
        : { orderBy?: UserGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, UserGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetUserGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the User model
   */
  readonly fields: UserFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for User.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__UserClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    agent<T extends User$agentArgs<ExtArgs> = {}>(args?: Subset<T, User$agentArgs<ExtArgs>>): Prisma__AgentClient<$Result.GetResult<Prisma.$AgentPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    partner<T extends User$partnerArgs<ExtArgs> = {}>(args?: Subset<T, User$partnerArgs<ExtArgs>>): Prisma__PartnerClient<$Result.GetResult<Prisma.$PartnerPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    notifications<T extends User$notificationsArgs<ExtArgs> = {}>(args?: Subset<T, User$notificationsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$NotificationTokenPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    userNotifications<T extends User$userNotificationsArgs<ExtArgs> = {}>(args?: Subset<T, User$userNotificationsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$NotificationPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    tickets<T extends User$ticketsArgs<ExtArgs> = {}>(args?: Subset<T, User$ticketsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SupportTicketPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the User model
   */
  interface UserFieldRefs {
    readonly id: FieldRef<"User", 'String'>
    readonly name: FieldRef<"User", 'String'>
    readonly email: FieldRef<"User", 'String'>
    readonly phone: FieldRef<"User", 'String'>
    readonly passwordHash: FieldRef<"User", 'String'>
    readonly role: FieldRef<"User", 'UserRole'>
    readonly emailVerified: FieldRef<"User", 'DateTime'>
    readonly phoneVerified: FieldRef<"User", 'Boolean'>
    readonly profilePicture: FieldRef<"User", 'String'>
    readonly createdAt: FieldRef<"User", 'DateTime'>
    readonly updatedAt: FieldRef<"User", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * User findUnique
   */
  export type UserFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * Filter, which User to fetch.
     */
    where: UserWhereUniqueInput
  }

  /**
   * User findUniqueOrThrow
   */
  export type UserFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * Filter, which User to fetch.
     */
    where: UserWhereUniqueInput
  }

  /**
   * User findFirst
   */
  export type UserFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * Filter, which User to fetch.
     */
    where?: UserWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Users to fetch.
     */
    orderBy?: UserOrderByWithRelationInput | UserOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Users.
     */
    cursor?: UserWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Users from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Users.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Users.
     */
    distinct?: UserScalarFieldEnum | UserScalarFieldEnum[]
  }

  /**
   * User findFirstOrThrow
   */
  export type UserFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * Filter, which User to fetch.
     */
    where?: UserWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Users to fetch.
     */
    orderBy?: UserOrderByWithRelationInput | UserOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Users.
     */
    cursor?: UserWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Users from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Users.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Users.
     */
    distinct?: UserScalarFieldEnum | UserScalarFieldEnum[]
  }

  /**
   * User findMany
   */
  export type UserFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * Filter, which Users to fetch.
     */
    where?: UserWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Users to fetch.
     */
    orderBy?: UserOrderByWithRelationInput | UserOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Users.
     */
    cursor?: UserWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Users from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Users.
     */
    skip?: number
    distinct?: UserScalarFieldEnum | UserScalarFieldEnum[]
  }

  /**
   * User create
   */
  export type UserCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * The data needed to create a User.
     */
    data: XOR<UserCreateInput, UserUncheckedCreateInput>
  }

  /**
   * User createMany
   */
  export type UserCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Users.
     */
    data: UserCreateManyInput | UserCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * User createManyAndReturn
   */
  export type UserCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * The data used to create many Users.
     */
    data: UserCreateManyInput | UserCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * User update
   */
  export type UserUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * The data needed to update a User.
     */
    data: XOR<UserUpdateInput, UserUncheckedUpdateInput>
    /**
     * Choose, which User to update.
     */
    where: UserWhereUniqueInput
  }

  /**
   * User updateMany
   */
  export type UserUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Users.
     */
    data: XOR<UserUpdateManyMutationInput, UserUncheckedUpdateManyInput>
    /**
     * Filter which Users to update
     */
    where?: UserWhereInput
    /**
     * Limit how many Users to update.
     */
    limit?: number
  }

  /**
   * User updateManyAndReturn
   */
  export type UserUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * The data used to update Users.
     */
    data: XOR<UserUpdateManyMutationInput, UserUncheckedUpdateManyInput>
    /**
     * Filter which Users to update
     */
    where?: UserWhereInput
    /**
     * Limit how many Users to update.
     */
    limit?: number
  }

  /**
   * User upsert
   */
  export type UserUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * The filter to search for the User to update in case it exists.
     */
    where: UserWhereUniqueInput
    /**
     * In case the User found by the `where` argument doesn't exist, create a new User with this data.
     */
    create: XOR<UserCreateInput, UserUncheckedCreateInput>
    /**
     * In case the User was found with the provided `where` argument, update it with this data.
     */
    update: XOR<UserUpdateInput, UserUncheckedUpdateInput>
  }

  /**
   * User delete
   */
  export type UserDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * Filter which User to delete.
     */
    where: UserWhereUniqueInput
  }

  /**
   * User deleteMany
   */
  export type UserDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Users to delete
     */
    where?: UserWhereInput
    /**
     * Limit how many Users to delete.
     */
    limit?: number
  }

  /**
   * User.agent
   */
  export type User$agentArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Agent
     */
    select?: AgentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Agent
     */
    omit?: AgentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AgentInclude<ExtArgs> | null
    where?: AgentWhereInput
  }

  /**
   * User.partner
   */
  export type User$partnerArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Partner
     */
    select?: PartnerSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Partner
     */
    omit?: PartnerOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PartnerInclude<ExtArgs> | null
    where?: PartnerWhereInput
  }

  /**
   * User.notifications
   */
  export type User$notificationsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the NotificationToken
     */
    select?: NotificationTokenSelect<ExtArgs> | null
    /**
     * Omit specific fields from the NotificationToken
     */
    omit?: NotificationTokenOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NotificationTokenInclude<ExtArgs> | null
    where?: NotificationTokenWhereInput
    orderBy?: NotificationTokenOrderByWithRelationInput | NotificationTokenOrderByWithRelationInput[]
    cursor?: NotificationTokenWhereUniqueInput
    take?: number
    skip?: number
    distinct?: NotificationTokenScalarFieldEnum | NotificationTokenScalarFieldEnum[]
  }

  /**
   * User.userNotifications
   */
  export type User$userNotificationsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Notification
     */
    select?: NotificationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Notification
     */
    omit?: NotificationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NotificationInclude<ExtArgs> | null
    where?: NotificationWhereInput
    orderBy?: NotificationOrderByWithRelationInput | NotificationOrderByWithRelationInput[]
    cursor?: NotificationWhereUniqueInput
    take?: number
    skip?: number
    distinct?: NotificationScalarFieldEnum | NotificationScalarFieldEnum[]
  }

  /**
   * User.tickets
   */
  export type User$ticketsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SupportTicket
     */
    select?: SupportTicketSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SupportTicket
     */
    omit?: SupportTicketOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SupportTicketInclude<ExtArgs> | null
    where?: SupportTicketWhereInput
    orderBy?: SupportTicketOrderByWithRelationInput | SupportTicketOrderByWithRelationInput[]
    cursor?: SupportTicketWhereUniqueInput
    take?: number
    skip?: number
    distinct?: SupportTicketScalarFieldEnum | SupportTicketScalarFieldEnum[]
  }

  /**
   * User without action
   */
  export type UserDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
  }


  /**
   * Model Agent
   */

  export type AggregateAgent = {
    _count: AgentCountAggregateOutputType | null
    _avg: AgentAvgAggregateOutputType | null
    _sum: AgentSumAggregateOutputType | null
    _min: AgentMinAggregateOutputType | null
    _max: AgentMaxAggregateOutputType | null
  }

  export type AgentAvgAggregateOutputType = {
    rating: number | null
    totalOrders: number | null
    completedOrders: number | null
    cancelledOrders: number | null
    acceptanceRate: number | null
  }

  export type AgentSumAggregateOutputType = {
    rating: number | null
    totalOrders: number | null
    completedOrders: number | null
    cancelledOrders: number | null
    acceptanceRate: number | null
  }

  export type AgentMinAggregateOutputType = {
    id: string | null
    userId: string | null
    vehicleType: $Enums.VehicleType | null
    status: $Enums.AgentStatus | null
    rating: number | null
    totalOrders: number | null
    completedOrders: number | null
    cancelledOrders: number | null
    acceptanceRate: number | null
    currentOrderId: string | null
    isApproved: boolean | null
    isBlocked: boolean | null
    blockedReason: string | null
    city: string | null
    state: string | null
    pincode: string | null
    lastOnlineAt: Date | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type AgentMaxAggregateOutputType = {
    id: string | null
    userId: string | null
    vehicleType: $Enums.VehicleType | null
    status: $Enums.AgentStatus | null
    rating: number | null
    totalOrders: number | null
    completedOrders: number | null
    cancelledOrders: number | null
    acceptanceRate: number | null
    currentOrderId: string | null
    isApproved: boolean | null
    isBlocked: boolean | null
    blockedReason: string | null
    city: string | null
    state: string | null
    pincode: string | null
    lastOnlineAt: Date | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type AgentCountAggregateOutputType = {
    id: number
    userId: number
    vehicleType: number
    status: number
    rating: number
    totalOrders: number
    completedOrders: number
    cancelledOrders: number
    acceptanceRate: number
    currentOrderId: number
    isApproved: number
    isBlocked: number
    blockedReason: number
    city: number
    state: number
    pincode: number
    lastOnlineAt: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type AgentAvgAggregateInputType = {
    rating?: true
    totalOrders?: true
    completedOrders?: true
    cancelledOrders?: true
    acceptanceRate?: true
  }

  export type AgentSumAggregateInputType = {
    rating?: true
    totalOrders?: true
    completedOrders?: true
    cancelledOrders?: true
    acceptanceRate?: true
  }

  export type AgentMinAggregateInputType = {
    id?: true
    userId?: true
    vehicleType?: true
    status?: true
    rating?: true
    totalOrders?: true
    completedOrders?: true
    cancelledOrders?: true
    acceptanceRate?: true
    currentOrderId?: true
    isApproved?: true
    isBlocked?: true
    blockedReason?: true
    city?: true
    state?: true
    pincode?: true
    lastOnlineAt?: true
    createdAt?: true
    updatedAt?: true
  }

  export type AgentMaxAggregateInputType = {
    id?: true
    userId?: true
    vehicleType?: true
    status?: true
    rating?: true
    totalOrders?: true
    completedOrders?: true
    cancelledOrders?: true
    acceptanceRate?: true
    currentOrderId?: true
    isApproved?: true
    isBlocked?: true
    blockedReason?: true
    city?: true
    state?: true
    pincode?: true
    lastOnlineAt?: true
    createdAt?: true
    updatedAt?: true
  }

  export type AgentCountAggregateInputType = {
    id?: true
    userId?: true
    vehicleType?: true
    status?: true
    rating?: true
    totalOrders?: true
    completedOrders?: true
    cancelledOrders?: true
    acceptanceRate?: true
    currentOrderId?: true
    isApproved?: true
    isBlocked?: true
    blockedReason?: true
    city?: true
    state?: true
    pincode?: true
    lastOnlineAt?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type AgentAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Agent to aggregate.
     */
    where?: AgentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Agents to fetch.
     */
    orderBy?: AgentOrderByWithRelationInput | AgentOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: AgentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Agents from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Agents.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Agents
    **/
    _count?: true | AgentCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: AgentAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: AgentSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: AgentMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: AgentMaxAggregateInputType
  }

  export type GetAgentAggregateType<T extends AgentAggregateArgs> = {
        [P in keyof T & keyof AggregateAgent]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateAgent[P]>
      : GetScalarType<T[P], AggregateAgent[P]>
  }




  export type AgentGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: AgentWhereInput
    orderBy?: AgentOrderByWithAggregationInput | AgentOrderByWithAggregationInput[]
    by: AgentScalarFieldEnum[] | AgentScalarFieldEnum
    having?: AgentScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: AgentCountAggregateInputType | true
    _avg?: AgentAvgAggregateInputType
    _sum?: AgentSumAggregateInputType
    _min?: AgentMinAggregateInputType
    _max?: AgentMaxAggregateInputType
  }

  export type AgentGroupByOutputType = {
    id: string
    userId: string
    vehicleType: $Enums.VehicleType
    status: $Enums.AgentStatus
    rating: number | null
    totalOrders: number
    completedOrders: number
    cancelledOrders: number
    acceptanceRate: number
    currentOrderId: string | null
    isApproved: boolean
    isBlocked: boolean
    blockedReason: string | null
    city: string | null
    state: string | null
    pincode: string | null
    lastOnlineAt: Date | null
    createdAt: Date
    updatedAt: Date
    _count: AgentCountAggregateOutputType | null
    _avg: AgentAvgAggregateOutputType | null
    _sum: AgentSumAggregateOutputType | null
    _min: AgentMinAggregateOutputType | null
    _max: AgentMaxAggregateOutputType | null
  }

  type GetAgentGroupByPayload<T extends AgentGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<AgentGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof AgentGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], AgentGroupByOutputType[P]>
            : GetScalarType<T[P], AgentGroupByOutputType[P]>
        }
      >
    >


  export type AgentSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    vehicleType?: boolean
    status?: boolean
    rating?: boolean
    totalOrders?: boolean
    completedOrders?: boolean
    cancelledOrders?: boolean
    acceptanceRate?: boolean
    currentOrderId?: boolean
    isApproved?: boolean
    isBlocked?: boolean
    blockedReason?: boolean
    city?: boolean
    state?: boolean
    pincode?: boolean
    lastOnlineAt?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
    orders?: boolean | Agent$ordersArgs<ExtArgs>
    currentOrder?: boolean | Agent$currentOrderArgs<ExtArgs>
    documents?: boolean | Agent$documentsArgs<ExtArgs>
    locationHistory?: boolean | Agent$locationHistoryArgs<ExtArgs>
    tickets?: boolean | Agent$ticketsArgs<ExtArgs>
    ratings?: boolean | Agent$ratingsArgs<ExtArgs>
    wallet?: boolean | Agent$walletArgs<ExtArgs>
    walletPayouts?: boolean | Agent$walletPayoutsArgs<ExtArgs>
    payments?: boolean | Agent$paymentsArgs<ExtArgs>
    payrolls?: boolean | Agent$payrollsArgs<ExtArgs>
    schedules?: boolean | Agent$schedulesArgs<ExtArgs>
    _count?: boolean | AgentCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["agent"]>

  export type AgentSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    vehicleType?: boolean
    status?: boolean
    rating?: boolean
    totalOrders?: boolean
    completedOrders?: boolean
    cancelledOrders?: boolean
    acceptanceRate?: boolean
    currentOrderId?: boolean
    isApproved?: boolean
    isBlocked?: boolean
    blockedReason?: boolean
    city?: boolean
    state?: boolean
    pincode?: boolean
    lastOnlineAt?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
    currentOrder?: boolean | Agent$currentOrderArgs<ExtArgs>
  }, ExtArgs["result"]["agent"]>

  export type AgentSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    vehicleType?: boolean
    status?: boolean
    rating?: boolean
    totalOrders?: boolean
    completedOrders?: boolean
    cancelledOrders?: boolean
    acceptanceRate?: boolean
    currentOrderId?: boolean
    isApproved?: boolean
    isBlocked?: boolean
    blockedReason?: boolean
    city?: boolean
    state?: boolean
    pincode?: boolean
    lastOnlineAt?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
    currentOrder?: boolean | Agent$currentOrderArgs<ExtArgs>
  }, ExtArgs["result"]["agent"]>

  export type AgentSelectScalar = {
    id?: boolean
    userId?: boolean
    vehicleType?: boolean
    status?: boolean
    rating?: boolean
    totalOrders?: boolean
    completedOrders?: boolean
    cancelledOrders?: boolean
    acceptanceRate?: boolean
    currentOrderId?: boolean
    isApproved?: boolean
    isBlocked?: boolean
    blockedReason?: boolean
    city?: boolean
    state?: boolean
    pincode?: boolean
    lastOnlineAt?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type AgentOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "userId" | "vehicleType" | "status" | "rating" | "totalOrders" | "completedOrders" | "cancelledOrders" | "acceptanceRate" | "currentOrderId" | "isApproved" | "isBlocked" | "blockedReason" | "city" | "state" | "pincode" | "lastOnlineAt" | "createdAt" | "updatedAt", ExtArgs["result"]["agent"]>
  export type AgentInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
    orders?: boolean | Agent$ordersArgs<ExtArgs>
    currentOrder?: boolean | Agent$currentOrderArgs<ExtArgs>
    documents?: boolean | Agent$documentsArgs<ExtArgs>
    locationHistory?: boolean | Agent$locationHistoryArgs<ExtArgs>
    tickets?: boolean | Agent$ticketsArgs<ExtArgs>
    ratings?: boolean | Agent$ratingsArgs<ExtArgs>
    wallet?: boolean | Agent$walletArgs<ExtArgs>
    walletPayouts?: boolean | Agent$walletPayoutsArgs<ExtArgs>
    payments?: boolean | Agent$paymentsArgs<ExtArgs>
    payrolls?: boolean | Agent$payrollsArgs<ExtArgs>
    schedules?: boolean | Agent$schedulesArgs<ExtArgs>
    _count?: boolean | AgentCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type AgentIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
    currentOrder?: boolean | Agent$currentOrderArgs<ExtArgs>
  }
  export type AgentIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
    currentOrder?: boolean | Agent$currentOrderArgs<ExtArgs>
  }

  export type $AgentPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Agent"
    objects: {
      user: Prisma.$UserPayload<ExtArgs>
      orders: Prisma.$OrderPayload<ExtArgs>[]
      currentOrder: Prisma.$OrderPayload<ExtArgs> | null
      documents: Prisma.$AgentDocumentPayload<ExtArgs>[]
      locationHistory: Prisma.$AgentLocationPayload<ExtArgs>[]
      tickets: Prisma.$SupportTicketPayload<ExtArgs>[]
      ratings: Prisma.$AgentRatingPayload<ExtArgs>[]
      wallet: Prisma.$AgentWalletPayload<ExtArgs> | null
      walletPayouts: Prisma.$WalletPayoutPayload<ExtArgs>[]
      payments: Prisma.$PaymentPayload<ExtArgs>[]
      payrolls: Prisma.$PayrollPayload<ExtArgs>[]
      schedules: Prisma.$AgentSchedulePayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      userId: string
      vehicleType: $Enums.VehicleType
      status: $Enums.AgentStatus
      rating: number | null
      totalOrders: number
      completedOrders: number
      cancelledOrders: number
      acceptanceRate: number
      currentOrderId: string | null
      isApproved: boolean
      isBlocked: boolean
      blockedReason: string | null
      city: string | null
      state: string | null
      pincode: string | null
      lastOnlineAt: Date | null
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["agent"]>
    composites: {}
  }

  type AgentGetPayload<S extends boolean | null | undefined | AgentDefaultArgs> = $Result.GetResult<Prisma.$AgentPayload, S>

  type AgentCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<AgentFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: AgentCountAggregateInputType | true
    }

  export interface AgentDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Agent'], meta: { name: 'Agent' } }
    /**
     * Find zero or one Agent that matches the filter.
     * @param {AgentFindUniqueArgs} args - Arguments to find a Agent
     * @example
     * // Get one Agent
     * const agent = await prisma.agent.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends AgentFindUniqueArgs>(args: SelectSubset<T, AgentFindUniqueArgs<ExtArgs>>): Prisma__AgentClient<$Result.GetResult<Prisma.$AgentPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Agent that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {AgentFindUniqueOrThrowArgs} args - Arguments to find a Agent
     * @example
     * // Get one Agent
     * const agent = await prisma.agent.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends AgentFindUniqueOrThrowArgs>(args: SelectSubset<T, AgentFindUniqueOrThrowArgs<ExtArgs>>): Prisma__AgentClient<$Result.GetResult<Prisma.$AgentPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Agent that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AgentFindFirstArgs} args - Arguments to find a Agent
     * @example
     * // Get one Agent
     * const agent = await prisma.agent.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends AgentFindFirstArgs>(args?: SelectSubset<T, AgentFindFirstArgs<ExtArgs>>): Prisma__AgentClient<$Result.GetResult<Prisma.$AgentPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Agent that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AgentFindFirstOrThrowArgs} args - Arguments to find a Agent
     * @example
     * // Get one Agent
     * const agent = await prisma.agent.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends AgentFindFirstOrThrowArgs>(args?: SelectSubset<T, AgentFindFirstOrThrowArgs<ExtArgs>>): Prisma__AgentClient<$Result.GetResult<Prisma.$AgentPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Agents that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AgentFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Agents
     * const agents = await prisma.agent.findMany()
     * 
     * // Get first 10 Agents
     * const agents = await prisma.agent.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const agentWithIdOnly = await prisma.agent.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends AgentFindManyArgs>(args?: SelectSubset<T, AgentFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AgentPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Agent.
     * @param {AgentCreateArgs} args - Arguments to create a Agent.
     * @example
     * // Create one Agent
     * const Agent = await prisma.agent.create({
     *   data: {
     *     // ... data to create a Agent
     *   }
     * })
     * 
     */
    create<T extends AgentCreateArgs>(args: SelectSubset<T, AgentCreateArgs<ExtArgs>>): Prisma__AgentClient<$Result.GetResult<Prisma.$AgentPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Agents.
     * @param {AgentCreateManyArgs} args - Arguments to create many Agents.
     * @example
     * // Create many Agents
     * const agent = await prisma.agent.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends AgentCreateManyArgs>(args?: SelectSubset<T, AgentCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Agents and returns the data saved in the database.
     * @param {AgentCreateManyAndReturnArgs} args - Arguments to create many Agents.
     * @example
     * // Create many Agents
     * const agent = await prisma.agent.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Agents and only return the `id`
     * const agentWithIdOnly = await prisma.agent.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends AgentCreateManyAndReturnArgs>(args?: SelectSubset<T, AgentCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AgentPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Agent.
     * @param {AgentDeleteArgs} args - Arguments to delete one Agent.
     * @example
     * // Delete one Agent
     * const Agent = await prisma.agent.delete({
     *   where: {
     *     // ... filter to delete one Agent
     *   }
     * })
     * 
     */
    delete<T extends AgentDeleteArgs>(args: SelectSubset<T, AgentDeleteArgs<ExtArgs>>): Prisma__AgentClient<$Result.GetResult<Prisma.$AgentPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Agent.
     * @param {AgentUpdateArgs} args - Arguments to update one Agent.
     * @example
     * // Update one Agent
     * const agent = await prisma.agent.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends AgentUpdateArgs>(args: SelectSubset<T, AgentUpdateArgs<ExtArgs>>): Prisma__AgentClient<$Result.GetResult<Prisma.$AgentPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Agents.
     * @param {AgentDeleteManyArgs} args - Arguments to filter Agents to delete.
     * @example
     * // Delete a few Agents
     * const { count } = await prisma.agent.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends AgentDeleteManyArgs>(args?: SelectSubset<T, AgentDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Agents.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AgentUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Agents
     * const agent = await prisma.agent.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends AgentUpdateManyArgs>(args: SelectSubset<T, AgentUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Agents and returns the data updated in the database.
     * @param {AgentUpdateManyAndReturnArgs} args - Arguments to update many Agents.
     * @example
     * // Update many Agents
     * const agent = await prisma.agent.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Agents and only return the `id`
     * const agentWithIdOnly = await prisma.agent.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends AgentUpdateManyAndReturnArgs>(args: SelectSubset<T, AgentUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AgentPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Agent.
     * @param {AgentUpsertArgs} args - Arguments to update or create a Agent.
     * @example
     * // Update or create a Agent
     * const agent = await prisma.agent.upsert({
     *   create: {
     *     // ... data to create a Agent
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Agent we want to update
     *   }
     * })
     */
    upsert<T extends AgentUpsertArgs>(args: SelectSubset<T, AgentUpsertArgs<ExtArgs>>): Prisma__AgentClient<$Result.GetResult<Prisma.$AgentPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Agents.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AgentCountArgs} args - Arguments to filter Agents to count.
     * @example
     * // Count the number of Agents
     * const count = await prisma.agent.count({
     *   where: {
     *     // ... the filter for the Agents we want to count
     *   }
     * })
    **/
    count<T extends AgentCountArgs>(
      args?: Subset<T, AgentCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], AgentCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Agent.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AgentAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends AgentAggregateArgs>(args: Subset<T, AgentAggregateArgs>): Prisma.PrismaPromise<GetAgentAggregateType<T>>

    /**
     * Group by Agent.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AgentGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends AgentGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: AgentGroupByArgs['orderBy'] }
        : { orderBy?: AgentGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, AgentGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetAgentGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Agent model
   */
  readonly fields: AgentFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Agent.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__AgentClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    user<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    orders<T extends Agent$ordersArgs<ExtArgs> = {}>(args?: Subset<T, Agent$ordersArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$OrderPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    currentOrder<T extends Agent$currentOrderArgs<ExtArgs> = {}>(args?: Subset<T, Agent$currentOrderArgs<ExtArgs>>): Prisma__OrderClient<$Result.GetResult<Prisma.$OrderPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    documents<T extends Agent$documentsArgs<ExtArgs> = {}>(args?: Subset<T, Agent$documentsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AgentDocumentPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    locationHistory<T extends Agent$locationHistoryArgs<ExtArgs> = {}>(args?: Subset<T, Agent$locationHistoryArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AgentLocationPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    tickets<T extends Agent$ticketsArgs<ExtArgs> = {}>(args?: Subset<T, Agent$ticketsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SupportTicketPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    ratings<T extends Agent$ratingsArgs<ExtArgs> = {}>(args?: Subset<T, Agent$ratingsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AgentRatingPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    wallet<T extends Agent$walletArgs<ExtArgs> = {}>(args?: Subset<T, Agent$walletArgs<ExtArgs>>): Prisma__AgentWalletClient<$Result.GetResult<Prisma.$AgentWalletPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    walletPayouts<T extends Agent$walletPayoutsArgs<ExtArgs> = {}>(args?: Subset<T, Agent$walletPayoutsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$WalletPayoutPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    payments<T extends Agent$paymentsArgs<ExtArgs> = {}>(args?: Subset<T, Agent$paymentsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PaymentPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    payrolls<T extends Agent$payrollsArgs<ExtArgs> = {}>(args?: Subset<T, Agent$payrollsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PayrollPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    schedules<T extends Agent$schedulesArgs<ExtArgs> = {}>(args?: Subset<T, Agent$schedulesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AgentSchedulePayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Agent model
   */
  interface AgentFieldRefs {
    readonly id: FieldRef<"Agent", 'String'>
    readonly userId: FieldRef<"Agent", 'String'>
    readonly vehicleType: FieldRef<"Agent", 'VehicleType'>
    readonly status: FieldRef<"Agent", 'AgentStatus'>
    readonly rating: FieldRef<"Agent", 'Float'>
    readonly totalOrders: FieldRef<"Agent", 'Int'>
    readonly completedOrders: FieldRef<"Agent", 'Int'>
    readonly cancelledOrders: FieldRef<"Agent", 'Int'>
    readonly acceptanceRate: FieldRef<"Agent", 'Float'>
    readonly currentOrderId: FieldRef<"Agent", 'String'>
    readonly isApproved: FieldRef<"Agent", 'Boolean'>
    readonly isBlocked: FieldRef<"Agent", 'Boolean'>
    readonly blockedReason: FieldRef<"Agent", 'String'>
    readonly city: FieldRef<"Agent", 'String'>
    readonly state: FieldRef<"Agent", 'String'>
    readonly pincode: FieldRef<"Agent", 'String'>
    readonly lastOnlineAt: FieldRef<"Agent", 'DateTime'>
    readonly createdAt: FieldRef<"Agent", 'DateTime'>
    readonly updatedAt: FieldRef<"Agent", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Agent findUnique
   */
  export type AgentFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Agent
     */
    select?: AgentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Agent
     */
    omit?: AgentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AgentInclude<ExtArgs> | null
    /**
     * Filter, which Agent to fetch.
     */
    where: AgentWhereUniqueInput
  }

  /**
   * Agent findUniqueOrThrow
   */
  export type AgentFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Agent
     */
    select?: AgentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Agent
     */
    omit?: AgentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AgentInclude<ExtArgs> | null
    /**
     * Filter, which Agent to fetch.
     */
    where: AgentWhereUniqueInput
  }

  /**
   * Agent findFirst
   */
  export type AgentFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Agent
     */
    select?: AgentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Agent
     */
    omit?: AgentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AgentInclude<ExtArgs> | null
    /**
     * Filter, which Agent to fetch.
     */
    where?: AgentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Agents to fetch.
     */
    orderBy?: AgentOrderByWithRelationInput | AgentOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Agents.
     */
    cursor?: AgentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Agents from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Agents.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Agents.
     */
    distinct?: AgentScalarFieldEnum | AgentScalarFieldEnum[]
  }

  /**
   * Agent findFirstOrThrow
   */
  export type AgentFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Agent
     */
    select?: AgentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Agent
     */
    omit?: AgentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AgentInclude<ExtArgs> | null
    /**
     * Filter, which Agent to fetch.
     */
    where?: AgentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Agents to fetch.
     */
    orderBy?: AgentOrderByWithRelationInput | AgentOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Agents.
     */
    cursor?: AgentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Agents from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Agents.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Agents.
     */
    distinct?: AgentScalarFieldEnum | AgentScalarFieldEnum[]
  }

  /**
   * Agent findMany
   */
  export type AgentFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Agent
     */
    select?: AgentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Agent
     */
    omit?: AgentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AgentInclude<ExtArgs> | null
    /**
     * Filter, which Agents to fetch.
     */
    where?: AgentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Agents to fetch.
     */
    orderBy?: AgentOrderByWithRelationInput | AgentOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Agents.
     */
    cursor?: AgentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Agents from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Agents.
     */
    skip?: number
    distinct?: AgentScalarFieldEnum | AgentScalarFieldEnum[]
  }

  /**
   * Agent create
   */
  export type AgentCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Agent
     */
    select?: AgentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Agent
     */
    omit?: AgentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AgentInclude<ExtArgs> | null
    /**
     * The data needed to create a Agent.
     */
    data: XOR<AgentCreateInput, AgentUncheckedCreateInput>
  }

  /**
   * Agent createMany
   */
  export type AgentCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Agents.
     */
    data: AgentCreateManyInput | AgentCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Agent createManyAndReturn
   */
  export type AgentCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Agent
     */
    select?: AgentSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Agent
     */
    omit?: AgentOmit<ExtArgs> | null
    /**
     * The data used to create many Agents.
     */
    data: AgentCreateManyInput | AgentCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AgentIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Agent update
   */
  export type AgentUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Agent
     */
    select?: AgentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Agent
     */
    omit?: AgentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AgentInclude<ExtArgs> | null
    /**
     * The data needed to update a Agent.
     */
    data: XOR<AgentUpdateInput, AgentUncheckedUpdateInput>
    /**
     * Choose, which Agent to update.
     */
    where: AgentWhereUniqueInput
  }

  /**
   * Agent updateMany
   */
  export type AgentUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Agents.
     */
    data: XOR<AgentUpdateManyMutationInput, AgentUncheckedUpdateManyInput>
    /**
     * Filter which Agents to update
     */
    where?: AgentWhereInput
    /**
     * Limit how many Agents to update.
     */
    limit?: number
  }

  /**
   * Agent updateManyAndReturn
   */
  export type AgentUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Agent
     */
    select?: AgentSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Agent
     */
    omit?: AgentOmit<ExtArgs> | null
    /**
     * The data used to update Agents.
     */
    data: XOR<AgentUpdateManyMutationInput, AgentUncheckedUpdateManyInput>
    /**
     * Filter which Agents to update
     */
    where?: AgentWhereInput
    /**
     * Limit how many Agents to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AgentIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * Agent upsert
   */
  export type AgentUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Agent
     */
    select?: AgentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Agent
     */
    omit?: AgentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AgentInclude<ExtArgs> | null
    /**
     * The filter to search for the Agent to update in case it exists.
     */
    where: AgentWhereUniqueInput
    /**
     * In case the Agent found by the `where` argument doesn't exist, create a new Agent with this data.
     */
    create: XOR<AgentCreateInput, AgentUncheckedCreateInput>
    /**
     * In case the Agent was found with the provided `where` argument, update it with this data.
     */
    update: XOR<AgentUpdateInput, AgentUncheckedUpdateInput>
  }

  /**
   * Agent delete
   */
  export type AgentDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Agent
     */
    select?: AgentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Agent
     */
    omit?: AgentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AgentInclude<ExtArgs> | null
    /**
     * Filter which Agent to delete.
     */
    where: AgentWhereUniqueInput
  }

  /**
   * Agent deleteMany
   */
  export type AgentDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Agents to delete
     */
    where?: AgentWhereInput
    /**
     * Limit how many Agents to delete.
     */
    limit?: number
  }

  /**
   * Agent.orders
   */
  export type Agent$ordersArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Order
     */
    select?: OrderSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Order
     */
    omit?: OrderOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OrderInclude<ExtArgs> | null
    where?: OrderWhereInput
    orderBy?: OrderOrderByWithRelationInput | OrderOrderByWithRelationInput[]
    cursor?: OrderWhereUniqueInput
    take?: number
    skip?: number
    distinct?: OrderScalarFieldEnum | OrderScalarFieldEnum[]
  }

  /**
   * Agent.currentOrder
   */
  export type Agent$currentOrderArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Order
     */
    select?: OrderSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Order
     */
    omit?: OrderOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OrderInclude<ExtArgs> | null
    where?: OrderWhereInput
  }

  /**
   * Agent.documents
   */
  export type Agent$documentsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AgentDocument
     */
    select?: AgentDocumentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AgentDocument
     */
    omit?: AgentDocumentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AgentDocumentInclude<ExtArgs> | null
    where?: AgentDocumentWhereInput
    orderBy?: AgentDocumentOrderByWithRelationInput | AgentDocumentOrderByWithRelationInput[]
    cursor?: AgentDocumentWhereUniqueInput
    take?: number
    skip?: number
    distinct?: AgentDocumentScalarFieldEnum | AgentDocumentScalarFieldEnum[]
  }

  /**
   * Agent.locationHistory
   */
  export type Agent$locationHistoryArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AgentLocation
     */
    select?: AgentLocationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AgentLocation
     */
    omit?: AgentLocationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AgentLocationInclude<ExtArgs> | null
    where?: AgentLocationWhereInput
    orderBy?: AgentLocationOrderByWithRelationInput | AgentLocationOrderByWithRelationInput[]
    cursor?: AgentLocationWhereUniqueInput
    take?: number
    skip?: number
    distinct?: AgentLocationScalarFieldEnum | AgentLocationScalarFieldEnum[]
  }

  /**
   * Agent.tickets
   */
  export type Agent$ticketsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SupportTicket
     */
    select?: SupportTicketSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SupportTicket
     */
    omit?: SupportTicketOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SupportTicketInclude<ExtArgs> | null
    where?: SupportTicketWhereInput
    orderBy?: SupportTicketOrderByWithRelationInput | SupportTicketOrderByWithRelationInput[]
    cursor?: SupportTicketWhereUniqueInput
    take?: number
    skip?: number
    distinct?: SupportTicketScalarFieldEnum | SupportTicketScalarFieldEnum[]
  }

  /**
   * Agent.ratings
   */
  export type Agent$ratingsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AgentRating
     */
    select?: AgentRatingSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AgentRating
     */
    omit?: AgentRatingOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AgentRatingInclude<ExtArgs> | null
    where?: AgentRatingWhereInput
    orderBy?: AgentRatingOrderByWithRelationInput | AgentRatingOrderByWithRelationInput[]
    cursor?: AgentRatingWhereUniqueInput
    take?: number
    skip?: number
    distinct?: AgentRatingScalarFieldEnum | AgentRatingScalarFieldEnum[]
  }

  /**
   * Agent.wallet
   */
  export type Agent$walletArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AgentWallet
     */
    select?: AgentWalletSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AgentWallet
     */
    omit?: AgentWalletOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AgentWalletInclude<ExtArgs> | null
    where?: AgentWalletWhereInput
  }

  /**
   * Agent.walletPayouts
   */
  export type Agent$walletPayoutsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WalletPayout
     */
    select?: WalletPayoutSelect<ExtArgs> | null
    /**
     * Omit specific fields from the WalletPayout
     */
    omit?: WalletPayoutOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WalletPayoutInclude<ExtArgs> | null
    where?: WalletPayoutWhereInput
    orderBy?: WalletPayoutOrderByWithRelationInput | WalletPayoutOrderByWithRelationInput[]
    cursor?: WalletPayoutWhereUniqueInput
    take?: number
    skip?: number
    distinct?: WalletPayoutScalarFieldEnum | WalletPayoutScalarFieldEnum[]
  }

  /**
   * Agent.payments
   */
  export type Agent$paymentsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Payment
     */
    select?: PaymentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Payment
     */
    omit?: PaymentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PaymentInclude<ExtArgs> | null
    where?: PaymentWhereInput
    orderBy?: PaymentOrderByWithRelationInput | PaymentOrderByWithRelationInput[]
    cursor?: PaymentWhereUniqueInput
    take?: number
    skip?: number
    distinct?: PaymentScalarFieldEnum | PaymentScalarFieldEnum[]
  }

  /**
   * Agent.payrolls
   */
  export type Agent$payrollsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Payroll
     */
    select?: PayrollSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Payroll
     */
    omit?: PayrollOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PayrollInclude<ExtArgs> | null
    where?: PayrollWhereInput
    orderBy?: PayrollOrderByWithRelationInput | PayrollOrderByWithRelationInput[]
    cursor?: PayrollWhereUniqueInput
    take?: number
    skip?: number
    distinct?: PayrollScalarFieldEnum | PayrollScalarFieldEnum[]
  }

  /**
   * Agent.schedules
   */
  export type Agent$schedulesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AgentSchedule
     */
    select?: AgentScheduleSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AgentSchedule
     */
    omit?: AgentScheduleOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AgentScheduleInclude<ExtArgs> | null
    where?: AgentScheduleWhereInput
    orderBy?: AgentScheduleOrderByWithRelationInput | AgentScheduleOrderByWithRelationInput[]
    cursor?: AgentScheduleWhereUniqueInput
    take?: number
    skip?: number
    distinct?: AgentScheduleScalarFieldEnum | AgentScheduleScalarFieldEnum[]
  }

  /**
   * Agent without action
   */
  export type AgentDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Agent
     */
    select?: AgentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Agent
     */
    omit?: AgentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AgentInclude<ExtArgs> | null
  }


  /**
   * Model AgentDocument
   */

  export type AggregateAgentDocument = {
    _count: AgentDocumentCountAggregateOutputType | null
    _min: AgentDocumentMinAggregateOutputType | null
    _max: AgentDocumentMaxAggregateOutputType | null
  }

  export type AgentDocumentMinAggregateOutputType = {
    id: string | null
    agentId: string | null
    documentType: string | null
    fileName: string | null
    fileUrl: string | null
    verified: boolean | null
    uploadedAt: Date | null
  }

  export type AgentDocumentMaxAggregateOutputType = {
    id: string | null
    agentId: string | null
    documentType: string | null
    fileName: string | null
    fileUrl: string | null
    verified: boolean | null
    uploadedAt: Date | null
  }

  export type AgentDocumentCountAggregateOutputType = {
    id: number
    agentId: number
    documentType: number
    fileName: number
    fileUrl: number
    verified: number
    uploadedAt: number
    _all: number
  }


  export type AgentDocumentMinAggregateInputType = {
    id?: true
    agentId?: true
    documentType?: true
    fileName?: true
    fileUrl?: true
    verified?: true
    uploadedAt?: true
  }

  export type AgentDocumentMaxAggregateInputType = {
    id?: true
    agentId?: true
    documentType?: true
    fileName?: true
    fileUrl?: true
    verified?: true
    uploadedAt?: true
  }

  export type AgentDocumentCountAggregateInputType = {
    id?: true
    agentId?: true
    documentType?: true
    fileName?: true
    fileUrl?: true
    verified?: true
    uploadedAt?: true
    _all?: true
  }

  export type AgentDocumentAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which AgentDocument to aggregate.
     */
    where?: AgentDocumentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of AgentDocuments to fetch.
     */
    orderBy?: AgentDocumentOrderByWithRelationInput | AgentDocumentOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: AgentDocumentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` AgentDocuments from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` AgentDocuments.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned AgentDocuments
    **/
    _count?: true | AgentDocumentCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: AgentDocumentMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: AgentDocumentMaxAggregateInputType
  }

  export type GetAgentDocumentAggregateType<T extends AgentDocumentAggregateArgs> = {
        [P in keyof T & keyof AggregateAgentDocument]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateAgentDocument[P]>
      : GetScalarType<T[P], AggregateAgentDocument[P]>
  }




  export type AgentDocumentGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: AgentDocumentWhereInput
    orderBy?: AgentDocumentOrderByWithAggregationInput | AgentDocumentOrderByWithAggregationInput[]
    by: AgentDocumentScalarFieldEnum[] | AgentDocumentScalarFieldEnum
    having?: AgentDocumentScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: AgentDocumentCountAggregateInputType | true
    _min?: AgentDocumentMinAggregateInputType
    _max?: AgentDocumentMaxAggregateInputType
  }

  export type AgentDocumentGroupByOutputType = {
    id: string
    agentId: string
    documentType: string
    fileName: string
    fileUrl: string
    verified: boolean
    uploadedAt: Date
    _count: AgentDocumentCountAggregateOutputType | null
    _min: AgentDocumentMinAggregateOutputType | null
    _max: AgentDocumentMaxAggregateOutputType | null
  }

  type GetAgentDocumentGroupByPayload<T extends AgentDocumentGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<AgentDocumentGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof AgentDocumentGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], AgentDocumentGroupByOutputType[P]>
            : GetScalarType<T[P], AgentDocumentGroupByOutputType[P]>
        }
      >
    >


  export type AgentDocumentSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    agentId?: boolean
    documentType?: boolean
    fileName?: boolean
    fileUrl?: boolean
    verified?: boolean
    uploadedAt?: boolean
    agent?: boolean | AgentDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["agentDocument"]>

  export type AgentDocumentSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    agentId?: boolean
    documentType?: boolean
    fileName?: boolean
    fileUrl?: boolean
    verified?: boolean
    uploadedAt?: boolean
    agent?: boolean | AgentDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["agentDocument"]>

  export type AgentDocumentSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    agentId?: boolean
    documentType?: boolean
    fileName?: boolean
    fileUrl?: boolean
    verified?: boolean
    uploadedAt?: boolean
    agent?: boolean | AgentDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["agentDocument"]>

  export type AgentDocumentSelectScalar = {
    id?: boolean
    agentId?: boolean
    documentType?: boolean
    fileName?: boolean
    fileUrl?: boolean
    verified?: boolean
    uploadedAt?: boolean
  }

  export type AgentDocumentOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "agentId" | "documentType" | "fileName" | "fileUrl" | "verified" | "uploadedAt", ExtArgs["result"]["agentDocument"]>
  export type AgentDocumentInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    agent?: boolean | AgentDefaultArgs<ExtArgs>
  }
  export type AgentDocumentIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    agent?: boolean | AgentDefaultArgs<ExtArgs>
  }
  export type AgentDocumentIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    agent?: boolean | AgentDefaultArgs<ExtArgs>
  }

  export type $AgentDocumentPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "AgentDocument"
    objects: {
      agent: Prisma.$AgentPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      agentId: string
      documentType: string
      fileName: string
      fileUrl: string
      verified: boolean
      uploadedAt: Date
    }, ExtArgs["result"]["agentDocument"]>
    composites: {}
  }

  type AgentDocumentGetPayload<S extends boolean | null | undefined | AgentDocumentDefaultArgs> = $Result.GetResult<Prisma.$AgentDocumentPayload, S>

  type AgentDocumentCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<AgentDocumentFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: AgentDocumentCountAggregateInputType | true
    }

  export interface AgentDocumentDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['AgentDocument'], meta: { name: 'AgentDocument' } }
    /**
     * Find zero or one AgentDocument that matches the filter.
     * @param {AgentDocumentFindUniqueArgs} args - Arguments to find a AgentDocument
     * @example
     * // Get one AgentDocument
     * const agentDocument = await prisma.agentDocument.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends AgentDocumentFindUniqueArgs>(args: SelectSubset<T, AgentDocumentFindUniqueArgs<ExtArgs>>): Prisma__AgentDocumentClient<$Result.GetResult<Prisma.$AgentDocumentPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one AgentDocument that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {AgentDocumentFindUniqueOrThrowArgs} args - Arguments to find a AgentDocument
     * @example
     * // Get one AgentDocument
     * const agentDocument = await prisma.agentDocument.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends AgentDocumentFindUniqueOrThrowArgs>(args: SelectSubset<T, AgentDocumentFindUniqueOrThrowArgs<ExtArgs>>): Prisma__AgentDocumentClient<$Result.GetResult<Prisma.$AgentDocumentPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first AgentDocument that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AgentDocumentFindFirstArgs} args - Arguments to find a AgentDocument
     * @example
     * // Get one AgentDocument
     * const agentDocument = await prisma.agentDocument.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends AgentDocumentFindFirstArgs>(args?: SelectSubset<T, AgentDocumentFindFirstArgs<ExtArgs>>): Prisma__AgentDocumentClient<$Result.GetResult<Prisma.$AgentDocumentPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first AgentDocument that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AgentDocumentFindFirstOrThrowArgs} args - Arguments to find a AgentDocument
     * @example
     * // Get one AgentDocument
     * const agentDocument = await prisma.agentDocument.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends AgentDocumentFindFirstOrThrowArgs>(args?: SelectSubset<T, AgentDocumentFindFirstOrThrowArgs<ExtArgs>>): Prisma__AgentDocumentClient<$Result.GetResult<Prisma.$AgentDocumentPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more AgentDocuments that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AgentDocumentFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all AgentDocuments
     * const agentDocuments = await prisma.agentDocument.findMany()
     * 
     * // Get first 10 AgentDocuments
     * const agentDocuments = await prisma.agentDocument.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const agentDocumentWithIdOnly = await prisma.agentDocument.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends AgentDocumentFindManyArgs>(args?: SelectSubset<T, AgentDocumentFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AgentDocumentPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a AgentDocument.
     * @param {AgentDocumentCreateArgs} args - Arguments to create a AgentDocument.
     * @example
     * // Create one AgentDocument
     * const AgentDocument = await prisma.agentDocument.create({
     *   data: {
     *     // ... data to create a AgentDocument
     *   }
     * })
     * 
     */
    create<T extends AgentDocumentCreateArgs>(args: SelectSubset<T, AgentDocumentCreateArgs<ExtArgs>>): Prisma__AgentDocumentClient<$Result.GetResult<Prisma.$AgentDocumentPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many AgentDocuments.
     * @param {AgentDocumentCreateManyArgs} args - Arguments to create many AgentDocuments.
     * @example
     * // Create many AgentDocuments
     * const agentDocument = await prisma.agentDocument.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends AgentDocumentCreateManyArgs>(args?: SelectSubset<T, AgentDocumentCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many AgentDocuments and returns the data saved in the database.
     * @param {AgentDocumentCreateManyAndReturnArgs} args - Arguments to create many AgentDocuments.
     * @example
     * // Create many AgentDocuments
     * const agentDocument = await prisma.agentDocument.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many AgentDocuments and only return the `id`
     * const agentDocumentWithIdOnly = await prisma.agentDocument.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends AgentDocumentCreateManyAndReturnArgs>(args?: SelectSubset<T, AgentDocumentCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AgentDocumentPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a AgentDocument.
     * @param {AgentDocumentDeleteArgs} args - Arguments to delete one AgentDocument.
     * @example
     * // Delete one AgentDocument
     * const AgentDocument = await prisma.agentDocument.delete({
     *   where: {
     *     // ... filter to delete one AgentDocument
     *   }
     * })
     * 
     */
    delete<T extends AgentDocumentDeleteArgs>(args: SelectSubset<T, AgentDocumentDeleteArgs<ExtArgs>>): Prisma__AgentDocumentClient<$Result.GetResult<Prisma.$AgentDocumentPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one AgentDocument.
     * @param {AgentDocumentUpdateArgs} args - Arguments to update one AgentDocument.
     * @example
     * // Update one AgentDocument
     * const agentDocument = await prisma.agentDocument.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends AgentDocumentUpdateArgs>(args: SelectSubset<T, AgentDocumentUpdateArgs<ExtArgs>>): Prisma__AgentDocumentClient<$Result.GetResult<Prisma.$AgentDocumentPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more AgentDocuments.
     * @param {AgentDocumentDeleteManyArgs} args - Arguments to filter AgentDocuments to delete.
     * @example
     * // Delete a few AgentDocuments
     * const { count } = await prisma.agentDocument.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends AgentDocumentDeleteManyArgs>(args?: SelectSubset<T, AgentDocumentDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more AgentDocuments.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AgentDocumentUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many AgentDocuments
     * const agentDocument = await prisma.agentDocument.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends AgentDocumentUpdateManyArgs>(args: SelectSubset<T, AgentDocumentUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more AgentDocuments and returns the data updated in the database.
     * @param {AgentDocumentUpdateManyAndReturnArgs} args - Arguments to update many AgentDocuments.
     * @example
     * // Update many AgentDocuments
     * const agentDocument = await prisma.agentDocument.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more AgentDocuments and only return the `id`
     * const agentDocumentWithIdOnly = await prisma.agentDocument.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends AgentDocumentUpdateManyAndReturnArgs>(args: SelectSubset<T, AgentDocumentUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AgentDocumentPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one AgentDocument.
     * @param {AgentDocumentUpsertArgs} args - Arguments to update or create a AgentDocument.
     * @example
     * // Update or create a AgentDocument
     * const agentDocument = await prisma.agentDocument.upsert({
     *   create: {
     *     // ... data to create a AgentDocument
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the AgentDocument we want to update
     *   }
     * })
     */
    upsert<T extends AgentDocumentUpsertArgs>(args: SelectSubset<T, AgentDocumentUpsertArgs<ExtArgs>>): Prisma__AgentDocumentClient<$Result.GetResult<Prisma.$AgentDocumentPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of AgentDocuments.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AgentDocumentCountArgs} args - Arguments to filter AgentDocuments to count.
     * @example
     * // Count the number of AgentDocuments
     * const count = await prisma.agentDocument.count({
     *   where: {
     *     // ... the filter for the AgentDocuments we want to count
     *   }
     * })
    **/
    count<T extends AgentDocumentCountArgs>(
      args?: Subset<T, AgentDocumentCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], AgentDocumentCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a AgentDocument.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AgentDocumentAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends AgentDocumentAggregateArgs>(args: Subset<T, AgentDocumentAggregateArgs>): Prisma.PrismaPromise<GetAgentDocumentAggregateType<T>>

    /**
     * Group by AgentDocument.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AgentDocumentGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends AgentDocumentGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: AgentDocumentGroupByArgs['orderBy'] }
        : { orderBy?: AgentDocumentGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, AgentDocumentGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetAgentDocumentGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the AgentDocument model
   */
  readonly fields: AgentDocumentFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for AgentDocument.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__AgentDocumentClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    agent<T extends AgentDefaultArgs<ExtArgs> = {}>(args?: Subset<T, AgentDefaultArgs<ExtArgs>>): Prisma__AgentClient<$Result.GetResult<Prisma.$AgentPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the AgentDocument model
   */
  interface AgentDocumentFieldRefs {
    readonly id: FieldRef<"AgentDocument", 'String'>
    readonly agentId: FieldRef<"AgentDocument", 'String'>
    readonly documentType: FieldRef<"AgentDocument", 'String'>
    readonly fileName: FieldRef<"AgentDocument", 'String'>
    readonly fileUrl: FieldRef<"AgentDocument", 'String'>
    readonly verified: FieldRef<"AgentDocument", 'Boolean'>
    readonly uploadedAt: FieldRef<"AgentDocument", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * AgentDocument findUnique
   */
  export type AgentDocumentFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AgentDocument
     */
    select?: AgentDocumentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AgentDocument
     */
    omit?: AgentDocumentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AgentDocumentInclude<ExtArgs> | null
    /**
     * Filter, which AgentDocument to fetch.
     */
    where: AgentDocumentWhereUniqueInput
  }

  /**
   * AgentDocument findUniqueOrThrow
   */
  export type AgentDocumentFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AgentDocument
     */
    select?: AgentDocumentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AgentDocument
     */
    omit?: AgentDocumentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AgentDocumentInclude<ExtArgs> | null
    /**
     * Filter, which AgentDocument to fetch.
     */
    where: AgentDocumentWhereUniqueInput
  }

  /**
   * AgentDocument findFirst
   */
  export type AgentDocumentFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AgentDocument
     */
    select?: AgentDocumentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AgentDocument
     */
    omit?: AgentDocumentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AgentDocumentInclude<ExtArgs> | null
    /**
     * Filter, which AgentDocument to fetch.
     */
    where?: AgentDocumentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of AgentDocuments to fetch.
     */
    orderBy?: AgentDocumentOrderByWithRelationInput | AgentDocumentOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for AgentDocuments.
     */
    cursor?: AgentDocumentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` AgentDocuments from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` AgentDocuments.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of AgentDocuments.
     */
    distinct?: AgentDocumentScalarFieldEnum | AgentDocumentScalarFieldEnum[]
  }

  /**
   * AgentDocument findFirstOrThrow
   */
  export type AgentDocumentFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AgentDocument
     */
    select?: AgentDocumentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AgentDocument
     */
    omit?: AgentDocumentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AgentDocumentInclude<ExtArgs> | null
    /**
     * Filter, which AgentDocument to fetch.
     */
    where?: AgentDocumentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of AgentDocuments to fetch.
     */
    orderBy?: AgentDocumentOrderByWithRelationInput | AgentDocumentOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for AgentDocuments.
     */
    cursor?: AgentDocumentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` AgentDocuments from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` AgentDocuments.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of AgentDocuments.
     */
    distinct?: AgentDocumentScalarFieldEnum | AgentDocumentScalarFieldEnum[]
  }

  /**
   * AgentDocument findMany
   */
  export type AgentDocumentFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AgentDocument
     */
    select?: AgentDocumentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AgentDocument
     */
    omit?: AgentDocumentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AgentDocumentInclude<ExtArgs> | null
    /**
     * Filter, which AgentDocuments to fetch.
     */
    where?: AgentDocumentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of AgentDocuments to fetch.
     */
    orderBy?: AgentDocumentOrderByWithRelationInput | AgentDocumentOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing AgentDocuments.
     */
    cursor?: AgentDocumentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` AgentDocuments from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` AgentDocuments.
     */
    skip?: number
    distinct?: AgentDocumentScalarFieldEnum | AgentDocumentScalarFieldEnum[]
  }

  /**
   * AgentDocument create
   */
  export type AgentDocumentCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AgentDocument
     */
    select?: AgentDocumentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AgentDocument
     */
    omit?: AgentDocumentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AgentDocumentInclude<ExtArgs> | null
    /**
     * The data needed to create a AgentDocument.
     */
    data: XOR<AgentDocumentCreateInput, AgentDocumentUncheckedCreateInput>
  }

  /**
   * AgentDocument createMany
   */
  export type AgentDocumentCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many AgentDocuments.
     */
    data: AgentDocumentCreateManyInput | AgentDocumentCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * AgentDocument createManyAndReturn
   */
  export type AgentDocumentCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AgentDocument
     */
    select?: AgentDocumentSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the AgentDocument
     */
    omit?: AgentDocumentOmit<ExtArgs> | null
    /**
     * The data used to create many AgentDocuments.
     */
    data: AgentDocumentCreateManyInput | AgentDocumentCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AgentDocumentIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * AgentDocument update
   */
  export type AgentDocumentUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AgentDocument
     */
    select?: AgentDocumentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AgentDocument
     */
    omit?: AgentDocumentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AgentDocumentInclude<ExtArgs> | null
    /**
     * The data needed to update a AgentDocument.
     */
    data: XOR<AgentDocumentUpdateInput, AgentDocumentUncheckedUpdateInput>
    /**
     * Choose, which AgentDocument to update.
     */
    where: AgentDocumentWhereUniqueInput
  }

  /**
   * AgentDocument updateMany
   */
  export type AgentDocumentUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update AgentDocuments.
     */
    data: XOR<AgentDocumentUpdateManyMutationInput, AgentDocumentUncheckedUpdateManyInput>
    /**
     * Filter which AgentDocuments to update
     */
    where?: AgentDocumentWhereInput
    /**
     * Limit how many AgentDocuments to update.
     */
    limit?: number
  }

  /**
   * AgentDocument updateManyAndReturn
   */
  export type AgentDocumentUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AgentDocument
     */
    select?: AgentDocumentSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the AgentDocument
     */
    omit?: AgentDocumentOmit<ExtArgs> | null
    /**
     * The data used to update AgentDocuments.
     */
    data: XOR<AgentDocumentUpdateManyMutationInput, AgentDocumentUncheckedUpdateManyInput>
    /**
     * Filter which AgentDocuments to update
     */
    where?: AgentDocumentWhereInput
    /**
     * Limit how many AgentDocuments to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AgentDocumentIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * AgentDocument upsert
   */
  export type AgentDocumentUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AgentDocument
     */
    select?: AgentDocumentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AgentDocument
     */
    omit?: AgentDocumentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AgentDocumentInclude<ExtArgs> | null
    /**
     * The filter to search for the AgentDocument to update in case it exists.
     */
    where: AgentDocumentWhereUniqueInput
    /**
     * In case the AgentDocument found by the `where` argument doesn't exist, create a new AgentDocument with this data.
     */
    create: XOR<AgentDocumentCreateInput, AgentDocumentUncheckedCreateInput>
    /**
     * In case the AgentDocument was found with the provided `where` argument, update it with this data.
     */
    update: XOR<AgentDocumentUpdateInput, AgentDocumentUncheckedUpdateInput>
  }

  /**
   * AgentDocument delete
   */
  export type AgentDocumentDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AgentDocument
     */
    select?: AgentDocumentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AgentDocument
     */
    omit?: AgentDocumentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AgentDocumentInclude<ExtArgs> | null
    /**
     * Filter which AgentDocument to delete.
     */
    where: AgentDocumentWhereUniqueInput
  }

  /**
   * AgentDocument deleteMany
   */
  export type AgentDocumentDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which AgentDocuments to delete
     */
    where?: AgentDocumentWhereInput
    /**
     * Limit how many AgentDocuments to delete.
     */
    limit?: number
  }

  /**
   * AgentDocument without action
   */
  export type AgentDocumentDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AgentDocument
     */
    select?: AgentDocumentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AgentDocument
     */
    omit?: AgentDocumentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AgentDocumentInclude<ExtArgs> | null
  }


  /**
   * Model AgentLocation
   */

  export type AggregateAgentLocation = {
    _count: AgentLocationCountAggregateOutputType | null
    _avg: AgentLocationAvgAggregateOutputType | null
    _sum: AgentLocationSumAggregateOutputType | null
    _min: AgentLocationMinAggregateOutputType | null
    _max: AgentLocationMaxAggregateOutputType | null
  }

  export type AgentLocationAvgAggregateOutputType = {
    latitude: number | null
    longitude: number | null
  }

  export type AgentLocationSumAggregateOutputType = {
    latitude: number | null
    longitude: number | null
  }

  export type AgentLocationMinAggregateOutputType = {
    id: string | null
    agentId: string | null
    latitude: number | null
    longitude: number | null
    timestamp: Date | null
  }

  export type AgentLocationMaxAggregateOutputType = {
    id: string | null
    agentId: string | null
    latitude: number | null
    longitude: number | null
    timestamp: Date | null
  }

  export type AgentLocationCountAggregateOutputType = {
    id: number
    agentId: number
    latitude: number
    longitude: number
    timestamp: number
    _all: number
  }


  export type AgentLocationAvgAggregateInputType = {
    latitude?: true
    longitude?: true
  }

  export type AgentLocationSumAggregateInputType = {
    latitude?: true
    longitude?: true
  }

  export type AgentLocationMinAggregateInputType = {
    id?: true
    agentId?: true
    latitude?: true
    longitude?: true
    timestamp?: true
  }

  export type AgentLocationMaxAggregateInputType = {
    id?: true
    agentId?: true
    latitude?: true
    longitude?: true
    timestamp?: true
  }

  export type AgentLocationCountAggregateInputType = {
    id?: true
    agentId?: true
    latitude?: true
    longitude?: true
    timestamp?: true
    _all?: true
  }

  export type AgentLocationAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which AgentLocation to aggregate.
     */
    where?: AgentLocationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of AgentLocations to fetch.
     */
    orderBy?: AgentLocationOrderByWithRelationInput | AgentLocationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: AgentLocationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` AgentLocations from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` AgentLocations.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned AgentLocations
    **/
    _count?: true | AgentLocationCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: AgentLocationAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: AgentLocationSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: AgentLocationMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: AgentLocationMaxAggregateInputType
  }

  export type GetAgentLocationAggregateType<T extends AgentLocationAggregateArgs> = {
        [P in keyof T & keyof AggregateAgentLocation]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateAgentLocation[P]>
      : GetScalarType<T[P], AggregateAgentLocation[P]>
  }




  export type AgentLocationGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: AgentLocationWhereInput
    orderBy?: AgentLocationOrderByWithAggregationInput | AgentLocationOrderByWithAggregationInput[]
    by: AgentLocationScalarFieldEnum[] | AgentLocationScalarFieldEnum
    having?: AgentLocationScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: AgentLocationCountAggregateInputType | true
    _avg?: AgentLocationAvgAggregateInputType
    _sum?: AgentLocationSumAggregateInputType
    _min?: AgentLocationMinAggregateInputType
    _max?: AgentLocationMaxAggregateInputType
  }

  export type AgentLocationGroupByOutputType = {
    id: string
    agentId: string
    latitude: number
    longitude: number
    timestamp: Date
    _count: AgentLocationCountAggregateOutputType | null
    _avg: AgentLocationAvgAggregateOutputType | null
    _sum: AgentLocationSumAggregateOutputType | null
    _min: AgentLocationMinAggregateOutputType | null
    _max: AgentLocationMaxAggregateOutputType | null
  }

  type GetAgentLocationGroupByPayload<T extends AgentLocationGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<AgentLocationGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof AgentLocationGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], AgentLocationGroupByOutputType[P]>
            : GetScalarType<T[P], AgentLocationGroupByOutputType[P]>
        }
      >
    >


  export type AgentLocationSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    agentId?: boolean
    latitude?: boolean
    longitude?: boolean
    timestamp?: boolean
    agent?: boolean | AgentDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["agentLocation"]>

  export type AgentLocationSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    agentId?: boolean
    latitude?: boolean
    longitude?: boolean
    timestamp?: boolean
    agent?: boolean | AgentDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["agentLocation"]>

  export type AgentLocationSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    agentId?: boolean
    latitude?: boolean
    longitude?: boolean
    timestamp?: boolean
    agent?: boolean | AgentDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["agentLocation"]>

  export type AgentLocationSelectScalar = {
    id?: boolean
    agentId?: boolean
    latitude?: boolean
    longitude?: boolean
    timestamp?: boolean
  }

  export type AgentLocationOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "agentId" | "latitude" | "longitude" | "timestamp", ExtArgs["result"]["agentLocation"]>
  export type AgentLocationInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    agent?: boolean | AgentDefaultArgs<ExtArgs>
  }
  export type AgentLocationIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    agent?: boolean | AgentDefaultArgs<ExtArgs>
  }
  export type AgentLocationIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    agent?: boolean | AgentDefaultArgs<ExtArgs>
  }

  export type $AgentLocationPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "AgentLocation"
    objects: {
      agent: Prisma.$AgentPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      agentId: string
      latitude: number
      longitude: number
      timestamp: Date
    }, ExtArgs["result"]["agentLocation"]>
    composites: {}
  }

  type AgentLocationGetPayload<S extends boolean | null | undefined | AgentLocationDefaultArgs> = $Result.GetResult<Prisma.$AgentLocationPayload, S>

  type AgentLocationCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<AgentLocationFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: AgentLocationCountAggregateInputType | true
    }

  export interface AgentLocationDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['AgentLocation'], meta: { name: 'AgentLocation' } }
    /**
     * Find zero or one AgentLocation that matches the filter.
     * @param {AgentLocationFindUniqueArgs} args - Arguments to find a AgentLocation
     * @example
     * // Get one AgentLocation
     * const agentLocation = await prisma.agentLocation.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends AgentLocationFindUniqueArgs>(args: SelectSubset<T, AgentLocationFindUniqueArgs<ExtArgs>>): Prisma__AgentLocationClient<$Result.GetResult<Prisma.$AgentLocationPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one AgentLocation that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {AgentLocationFindUniqueOrThrowArgs} args - Arguments to find a AgentLocation
     * @example
     * // Get one AgentLocation
     * const agentLocation = await prisma.agentLocation.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends AgentLocationFindUniqueOrThrowArgs>(args: SelectSubset<T, AgentLocationFindUniqueOrThrowArgs<ExtArgs>>): Prisma__AgentLocationClient<$Result.GetResult<Prisma.$AgentLocationPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first AgentLocation that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AgentLocationFindFirstArgs} args - Arguments to find a AgentLocation
     * @example
     * // Get one AgentLocation
     * const agentLocation = await prisma.agentLocation.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends AgentLocationFindFirstArgs>(args?: SelectSubset<T, AgentLocationFindFirstArgs<ExtArgs>>): Prisma__AgentLocationClient<$Result.GetResult<Prisma.$AgentLocationPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first AgentLocation that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AgentLocationFindFirstOrThrowArgs} args - Arguments to find a AgentLocation
     * @example
     * // Get one AgentLocation
     * const agentLocation = await prisma.agentLocation.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends AgentLocationFindFirstOrThrowArgs>(args?: SelectSubset<T, AgentLocationFindFirstOrThrowArgs<ExtArgs>>): Prisma__AgentLocationClient<$Result.GetResult<Prisma.$AgentLocationPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more AgentLocations that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AgentLocationFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all AgentLocations
     * const agentLocations = await prisma.agentLocation.findMany()
     * 
     * // Get first 10 AgentLocations
     * const agentLocations = await prisma.agentLocation.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const agentLocationWithIdOnly = await prisma.agentLocation.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends AgentLocationFindManyArgs>(args?: SelectSubset<T, AgentLocationFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AgentLocationPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a AgentLocation.
     * @param {AgentLocationCreateArgs} args - Arguments to create a AgentLocation.
     * @example
     * // Create one AgentLocation
     * const AgentLocation = await prisma.agentLocation.create({
     *   data: {
     *     // ... data to create a AgentLocation
     *   }
     * })
     * 
     */
    create<T extends AgentLocationCreateArgs>(args: SelectSubset<T, AgentLocationCreateArgs<ExtArgs>>): Prisma__AgentLocationClient<$Result.GetResult<Prisma.$AgentLocationPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many AgentLocations.
     * @param {AgentLocationCreateManyArgs} args - Arguments to create many AgentLocations.
     * @example
     * // Create many AgentLocations
     * const agentLocation = await prisma.agentLocation.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends AgentLocationCreateManyArgs>(args?: SelectSubset<T, AgentLocationCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many AgentLocations and returns the data saved in the database.
     * @param {AgentLocationCreateManyAndReturnArgs} args - Arguments to create many AgentLocations.
     * @example
     * // Create many AgentLocations
     * const agentLocation = await prisma.agentLocation.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many AgentLocations and only return the `id`
     * const agentLocationWithIdOnly = await prisma.agentLocation.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends AgentLocationCreateManyAndReturnArgs>(args?: SelectSubset<T, AgentLocationCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AgentLocationPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a AgentLocation.
     * @param {AgentLocationDeleteArgs} args - Arguments to delete one AgentLocation.
     * @example
     * // Delete one AgentLocation
     * const AgentLocation = await prisma.agentLocation.delete({
     *   where: {
     *     // ... filter to delete one AgentLocation
     *   }
     * })
     * 
     */
    delete<T extends AgentLocationDeleteArgs>(args: SelectSubset<T, AgentLocationDeleteArgs<ExtArgs>>): Prisma__AgentLocationClient<$Result.GetResult<Prisma.$AgentLocationPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one AgentLocation.
     * @param {AgentLocationUpdateArgs} args - Arguments to update one AgentLocation.
     * @example
     * // Update one AgentLocation
     * const agentLocation = await prisma.agentLocation.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends AgentLocationUpdateArgs>(args: SelectSubset<T, AgentLocationUpdateArgs<ExtArgs>>): Prisma__AgentLocationClient<$Result.GetResult<Prisma.$AgentLocationPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more AgentLocations.
     * @param {AgentLocationDeleteManyArgs} args - Arguments to filter AgentLocations to delete.
     * @example
     * // Delete a few AgentLocations
     * const { count } = await prisma.agentLocation.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends AgentLocationDeleteManyArgs>(args?: SelectSubset<T, AgentLocationDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more AgentLocations.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AgentLocationUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many AgentLocations
     * const agentLocation = await prisma.agentLocation.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends AgentLocationUpdateManyArgs>(args: SelectSubset<T, AgentLocationUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more AgentLocations and returns the data updated in the database.
     * @param {AgentLocationUpdateManyAndReturnArgs} args - Arguments to update many AgentLocations.
     * @example
     * // Update many AgentLocations
     * const agentLocation = await prisma.agentLocation.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more AgentLocations and only return the `id`
     * const agentLocationWithIdOnly = await prisma.agentLocation.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends AgentLocationUpdateManyAndReturnArgs>(args: SelectSubset<T, AgentLocationUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AgentLocationPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one AgentLocation.
     * @param {AgentLocationUpsertArgs} args - Arguments to update or create a AgentLocation.
     * @example
     * // Update or create a AgentLocation
     * const agentLocation = await prisma.agentLocation.upsert({
     *   create: {
     *     // ... data to create a AgentLocation
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the AgentLocation we want to update
     *   }
     * })
     */
    upsert<T extends AgentLocationUpsertArgs>(args: SelectSubset<T, AgentLocationUpsertArgs<ExtArgs>>): Prisma__AgentLocationClient<$Result.GetResult<Prisma.$AgentLocationPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of AgentLocations.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AgentLocationCountArgs} args - Arguments to filter AgentLocations to count.
     * @example
     * // Count the number of AgentLocations
     * const count = await prisma.agentLocation.count({
     *   where: {
     *     // ... the filter for the AgentLocations we want to count
     *   }
     * })
    **/
    count<T extends AgentLocationCountArgs>(
      args?: Subset<T, AgentLocationCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], AgentLocationCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a AgentLocation.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AgentLocationAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends AgentLocationAggregateArgs>(args: Subset<T, AgentLocationAggregateArgs>): Prisma.PrismaPromise<GetAgentLocationAggregateType<T>>

    /**
     * Group by AgentLocation.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AgentLocationGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends AgentLocationGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: AgentLocationGroupByArgs['orderBy'] }
        : { orderBy?: AgentLocationGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, AgentLocationGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetAgentLocationGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the AgentLocation model
   */
  readonly fields: AgentLocationFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for AgentLocation.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__AgentLocationClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    agent<T extends AgentDefaultArgs<ExtArgs> = {}>(args?: Subset<T, AgentDefaultArgs<ExtArgs>>): Prisma__AgentClient<$Result.GetResult<Prisma.$AgentPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the AgentLocation model
   */
  interface AgentLocationFieldRefs {
    readonly id: FieldRef<"AgentLocation", 'String'>
    readonly agentId: FieldRef<"AgentLocation", 'String'>
    readonly latitude: FieldRef<"AgentLocation", 'Float'>
    readonly longitude: FieldRef<"AgentLocation", 'Float'>
    readonly timestamp: FieldRef<"AgentLocation", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * AgentLocation findUnique
   */
  export type AgentLocationFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AgentLocation
     */
    select?: AgentLocationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AgentLocation
     */
    omit?: AgentLocationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AgentLocationInclude<ExtArgs> | null
    /**
     * Filter, which AgentLocation to fetch.
     */
    where: AgentLocationWhereUniqueInput
  }

  /**
   * AgentLocation findUniqueOrThrow
   */
  export type AgentLocationFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AgentLocation
     */
    select?: AgentLocationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AgentLocation
     */
    omit?: AgentLocationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AgentLocationInclude<ExtArgs> | null
    /**
     * Filter, which AgentLocation to fetch.
     */
    where: AgentLocationWhereUniqueInput
  }

  /**
   * AgentLocation findFirst
   */
  export type AgentLocationFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AgentLocation
     */
    select?: AgentLocationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AgentLocation
     */
    omit?: AgentLocationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AgentLocationInclude<ExtArgs> | null
    /**
     * Filter, which AgentLocation to fetch.
     */
    where?: AgentLocationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of AgentLocations to fetch.
     */
    orderBy?: AgentLocationOrderByWithRelationInput | AgentLocationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for AgentLocations.
     */
    cursor?: AgentLocationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` AgentLocations from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` AgentLocations.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of AgentLocations.
     */
    distinct?: AgentLocationScalarFieldEnum | AgentLocationScalarFieldEnum[]
  }

  /**
   * AgentLocation findFirstOrThrow
   */
  export type AgentLocationFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AgentLocation
     */
    select?: AgentLocationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AgentLocation
     */
    omit?: AgentLocationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AgentLocationInclude<ExtArgs> | null
    /**
     * Filter, which AgentLocation to fetch.
     */
    where?: AgentLocationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of AgentLocations to fetch.
     */
    orderBy?: AgentLocationOrderByWithRelationInput | AgentLocationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for AgentLocations.
     */
    cursor?: AgentLocationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` AgentLocations from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` AgentLocations.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of AgentLocations.
     */
    distinct?: AgentLocationScalarFieldEnum | AgentLocationScalarFieldEnum[]
  }

  /**
   * AgentLocation findMany
   */
  export type AgentLocationFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AgentLocation
     */
    select?: AgentLocationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AgentLocation
     */
    omit?: AgentLocationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AgentLocationInclude<ExtArgs> | null
    /**
     * Filter, which AgentLocations to fetch.
     */
    where?: AgentLocationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of AgentLocations to fetch.
     */
    orderBy?: AgentLocationOrderByWithRelationInput | AgentLocationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing AgentLocations.
     */
    cursor?: AgentLocationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` AgentLocations from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` AgentLocations.
     */
    skip?: number
    distinct?: AgentLocationScalarFieldEnum | AgentLocationScalarFieldEnum[]
  }

  /**
   * AgentLocation create
   */
  export type AgentLocationCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AgentLocation
     */
    select?: AgentLocationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AgentLocation
     */
    omit?: AgentLocationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AgentLocationInclude<ExtArgs> | null
    /**
     * The data needed to create a AgentLocation.
     */
    data: XOR<AgentLocationCreateInput, AgentLocationUncheckedCreateInput>
  }

  /**
   * AgentLocation createMany
   */
  export type AgentLocationCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many AgentLocations.
     */
    data: AgentLocationCreateManyInput | AgentLocationCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * AgentLocation createManyAndReturn
   */
  export type AgentLocationCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AgentLocation
     */
    select?: AgentLocationSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the AgentLocation
     */
    omit?: AgentLocationOmit<ExtArgs> | null
    /**
     * The data used to create many AgentLocations.
     */
    data: AgentLocationCreateManyInput | AgentLocationCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AgentLocationIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * AgentLocation update
   */
  export type AgentLocationUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AgentLocation
     */
    select?: AgentLocationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AgentLocation
     */
    omit?: AgentLocationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AgentLocationInclude<ExtArgs> | null
    /**
     * The data needed to update a AgentLocation.
     */
    data: XOR<AgentLocationUpdateInput, AgentLocationUncheckedUpdateInput>
    /**
     * Choose, which AgentLocation to update.
     */
    where: AgentLocationWhereUniqueInput
  }

  /**
   * AgentLocation updateMany
   */
  export type AgentLocationUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update AgentLocations.
     */
    data: XOR<AgentLocationUpdateManyMutationInput, AgentLocationUncheckedUpdateManyInput>
    /**
     * Filter which AgentLocations to update
     */
    where?: AgentLocationWhereInput
    /**
     * Limit how many AgentLocations to update.
     */
    limit?: number
  }

  /**
   * AgentLocation updateManyAndReturn
   */
  export type AgentLocationUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AgentLocation
     */
    select?: AgentLocationSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the AgentLocation
     */
    omit?: AgentLocationOmit<ExtArgs> | null
    /**
     * The data used to update AgentLocations.
     */
    data: XOR<AgentLocationUpdateManyMutationInput, AgentLocationUncheckedUpdateManyInput>
    /**
     * Filter which AgentLocations to update
     */
    where?: AgentLocationWhereInput
    /**
     * Limit how many AgentLocations to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AgentLocationIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * AgentLocation upsert
   */
  export type AgentLocationUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AgentLocation
     */
    select?: AgentLocationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AgentLocation
     */
    omit?: AgentLocationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AgentLocationInclude<ExtArgs> | null
    /**
     * The filter to search for the AgentLocation to update in case it exists.
     */
    where: AgentLocationWhereUniqueInput
    /**
     * In case the AgentLocation found by the `where` argument doesn't exist, create a new AgentLocation with this data.
     */
    create: XOR<AgentLocationCreateInput, AgentLocationUncheckedCreateInput>
    /**
     * In case the AgentLocation was found with the provided `where` argument, update it with this data.
     */
    update: XOR<AgentLocationUpdateInput, AgentLocationUncheckedUpdateInput>
  }

  /**
   * AgentLocation delete
   */
  export type AgentLocationDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AgentLocation
     */
    select?: AgentLocationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AgentLocation
     */
    omit?: AgentLocationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AgentLocationInclude<ExtArgs> | null
    /**
     * Filter which AgentLocation to delete.
     */
    where: AgentLocationWhereUniqueInput
  }

  /**
   * AgentLocation deleteMany
   */
  export type AgentLocationDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which AgentLocations to delete
     */
    where?: AgentLocationWhereInput
    /**
     * Limit how many AgentLocations to delete.
     */
    limit?: number
  }

  /**
   * AgentLocation without action
   */
  export type AgentLocationDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AgentLocation
     */
    select?: AgentLocationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AgentLocation
     */
    omit?: AgentLocationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AgentLocationInclude<ExtArgs> | null
  }


  /**
   * Model Partner
   */

  export type AggregatePartner = {
    _count: PartnerCountAggregateOutputType | null
    _min: PartnerMinAggregateOutputType | null
    _max: PartnerMaxAggregateOutputType | null
  }

  export type PartnerMinAggregateOutputType = {
    id: string | null
    userId: string | null
    companyName: string | null
    apiKey: string | null
    webhookUrl: string | null
    isActive: boolean | null
    city: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type PartnerMaxAggregateOutputType = {
    id: string | null
    userId: string | null
    companyName: string | null
    apiKey: string | null
    webhookUrl: string | null
    isActive: boolean | null
    city: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type PartnerCountAggregateOutputType = {
    id: number
    userId: number
    companyName: number
    apiKey: number
    webhookUrl: number
    isActive: number
    city: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type PartnerMinAggregateInputType = {
    id?: true
    userId?: true
    companyName?: true
    apiKey?: true
    webhookUrl?: true
    isActive?: true
    city?: true
    createdAt?: true
    updatedAt?: true
  }

  export type PartnerMaxAggregateInputType = {
    id?: true
    userId?: true
    companyName?: true
    apiKey?: true
    webhookUrl?: true
    isActive?: true
    city?: true
    createdAt?: true
    updatedAt?: true
  }

  export type PartnerCountAggregateInputType = {
    id?: true
    userId?: true
    companyName?: true
    apiKey?: true
    webhookUrl?: true
    isActive?: true
    city?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type PartnerAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Partner to aggregate.
     */
    where?: PartnerWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Partners to fetch.
     */
    orderBy?: PartnerOrderByWithRelationInput | PartnerOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: PartnerWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Partners from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Partners.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Partners
    **/
    _count?: true | PartnerCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: PartnerMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: PartnerMaxAggregateInputType
  }

  export type GetPartnerAggregateType<T extends PartnerAggregateArgs> = {
        [P in keyof T & keyof AggregatePartner]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregatePartner[P]>
      : GetScalarType<T[P], AggregatePartner[P]>
  }




  export type PartnerGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: PartnerWhereInput
    orderBy?: PartnerOrderByWithAggregationInput | PartnerOrderByWithAggregationInput[]
    by: PartnerScalarFieldEnum[] | PartnerScalarFieldEnum
    having?: PartnerScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: PartnerCountAggregateInputType | true
    _min?: PartnerMinAggregateInputType
    _max?: PartnerMaxAggregateInputType
  }

  export type PartnerGroupByOutputType = {
    id: string
    userId: string
    companyName: string
    apiKey: string
    webhookUrl: string | null
    isActive: boolean
    city: string | null
    createdAt: Date
    updatedAt: Date
    _count: PartnerCountAggregateOutputType | null
    _min: PartnerMinAggregateOutputType | null
    _max: PartnerMaxAggregateOutputType | null
  }

  type GetPartnerGroupByPayload<T extends PartnerGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<PartnerGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof PartnerGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], PartnerGroupByOutputType[P]>
            : GetScalarType<T[P], PartnerGroupByOutputType[P]>
        }
      >
    >


  export type PartnerSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    companyName?: boolean
    apiKey?: boolean
    webhookUrl?: boolean
    isActive?: boolean
    city?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
    orders?: boolean | Partner$ordersArgs<ExtArgs>
    tickets?: boolean | Partner$ticketsArgs<ExtArgs>
    dailyStats?: boolean | Partner$dailyStatsArgs<ExtArgs>
    agentRatings?: boolean | Partner$agentRatingsArgs<ExtArgs>
    partnerRevenues?: boolean | Partner$partnerRevenuesArgs<ExtArgs>
    platformRevenues?: boolean | Partner$platformRevenuesArgs<ExtArgs>
    _count?: boolean | PartnerCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["partner"]>

  export type PartnerSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    companyName?: boolean
    apiKey?: boolean
    webhookUrl?: boolean
    isActive?: boolean
    city?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["partner"]>

  export type PartnerSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    companyName?: boolean
    apiKey?: boolean
    webhookUrl?: boolean
    isActive?: boolean
    city?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["partner"]>

  export type PartnerSelectScalar = {
    id?: boolean
    userId?: boolean
    companyName?: boolean
    apiKey?: boolean
    webhookUrl?: boolean
    isActive?: boolean
    city?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type PartnerOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "userId" | "companyName" | "apiKey" | "webhookUrl" | "isActive" | "city" | "createdAt" | "updatedAt", ExtArgs["result"]["partner"]>
  export type PartnerInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
    orders?: boolean | Partner$ordersArgs<ExtArgs>
    tickets?: boolean | Partner$ticketsArgs<ExtArgs>
    dailyStats?: boolean | Partner$dailyStatsArgs<ExtArgs>
    agentRatings?: boolean | Partner$agentRatingsArgs<ExtArgs>
    partnerRevenues?: boolean | Partner$partnerRevenuesArgs<ExtArgs>
    platformRevenues?: boolean | Partner$platformRevenuesArgs<ExtArgs>
    _count?: boolean | PartnerCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type PartnerIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
  }
  export type PartnerIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
  }

  export type $PartnerPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Partner"
    objects: {
      user: Prisma.$UserPayload<ExtArgs>
      orders: Prisma.$OrderPayload<ExtArgs>[]
      tickets: Prisma.$SupportTicketPayload<ExtArgs>[]
      dailyStats: Prisma.$PartnerDailyStatsPayload<ExtArgs>[]
      agentRatings: Prisma.$AgentRatingPayload<ExtArgs>[]
      partnerRevenues: Prisma.$PartnerRevenuePayload<ExtArgs>[]
      platformRevenues: Prisma.$PlatformRevenuePayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      userId: string
      companyName: string
      apiKey: string
      webhookUrl: string | null
      isActive: boolean
      city: string | null
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["partner"]>
    composites: {}
  }

  type PartnerGetPayload<S extends boolean | null | undefined | PartnerDefaultArgs> = $Result.GetResult<Prisma.$PartnerPayload, S>

  type PartnerCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<PartnerFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: PartnerCountAggregateInputType | true
    }

  export interface PartnerDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Partner'], meta: { name: 'Partner' } }
    /**
     * Find zero or one Partner that matches the filter.
     * @param {PartnerFindUniqueArgs} args - Arguments to find a Partner
     * @example
     * // Get one Partner
     * const partner = await prisma.partner.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends PartnerFindUniqueArgs>(args: SelectSubset<T, PartnerFindUniqueArgs<ExtArgs>>): Prisma__PartnerClient<$Result.GetResult<Prisma.$PartnerPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Partner that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {PartnerFindUniqueOrThrowArgs} args - Arguments to find a Partner
     * @example
     * // Get one Partner
     * const partner = await prisma.partner.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends PartnerFindUniqueOrThrowArgs>(args: SelectSubset<T, PartnerFindUniqueOrThrowArgs<ExtArgs>>): Prisma__PartnerClient<$Result.GetResult<Prisma.$PartnerPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Partner that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PartnerFindFirstArgs} args - Arguments to find a Partner
     * @example
     * // Get one Partner
     * const partner = await prisma.partner.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends PartnerFindFirstArgs>(args?: SelectSubset<T, PartnerFindFirstArgs<ExtArgs>>): Prisma__PartnerClient<$Result.GetResult<Prisma.$PartnerPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Partner that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PartnerFindFirstOrThrowArgs} args - Arguments to find a Partner
     * @example
     * // Get one Partner
     * const partner = await prisma.partner.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends PartnerFindFirstOrThrowArgs>(args?: SelectSubset<T, PartnerFindFirstOrThrowArgs<ExtArgs>>): Prisma__PartnerClient<$Result.GetResult<Prisma.$PartnerPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Partners that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PartnerFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Partners
     * const partners = await prisma.partner.findMany()
     * 
     * // Get first 10 Partners
     * const partners = await prisma.partner.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const partnerWithIdOnly = await prisma.partner.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends PartnerFindManyArgs>(args?: SelectSubset<T, PartnerFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PartnerPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Partner.
     * @param {PartnerCreateArgs} args - Arguments to create a Partner.
     * @example
     * // Create one Partner
     * const Partner = await prisma.partner.create({
     *   data: {
     *     // ... data to create a Partner
     *   }
     * })
     * 
     */
    create<T extends PartnerCreateArgs>(args: SelectSubset<T, PartnerCreateArgs<ExtArgs>>): Prisma__PartnerClient<$Result.GetResult<Prisma.$PartnerPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Partners.
     * @param {PartnerCreateManyArgs} args - Arguments to create many Partners.
     * @example
     * // Create many Partners
     * const partner = await prisma.partner.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends PartnerCreateManyArgs>(args?: SelectSubset<T, PartnerCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Partners and returns the data saved in the database.
     * @param {PartnerCreateManyAndReturnArgs} args - Arguments to create many Partners.
     * @example
     * // Create many Partners
     * const partner = await prisma.partner.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Partners and only return the `id`
     * const partnerWithIdOnly = await prisma.partner.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends PartnerCreateManyAndReturnArgs>(args?: SelectSubset<T, PartnerCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PartnerPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Partner.
     * @param {PartnerDeleteArgs} args - Arguments to delete one Partner.
     * @example
     * // Delete one Partner
     * const Partner = await prisma.partner.delete({
     *   where: {
     *     // ... filter to delete one Partner
     *   }
     * })
     * 
     */
    delete<T extends PartnerDeleteArgs>(args: SelectSubset<T, PartnerDeleteArgs<ExtArgs>>): Prisma__PartnerClient<$Result.GetResult<Prisma.$PartnerPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Partner.
     * @param {PartnerUpdateArgs} args - Arguments to update one Partner.
     * @example
     * // Update one Partner
     * const partner = await prisma.partner.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends PartnerUpdateArgs>(args: SelectSubset<T, PartnerUpdateArgs<ExtArgs>>): Prisma__PartnerClient<$Result.GetResult<Prisma.$PartnerPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Partners.
     * @param {PartnerDeleteManyArgs} args - Arguments to filter Partners to delete.
     * @example
     * // Delete a few Partners
     * const { count } = await prisma.partner.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends PartnerDeleteManyArgs>(args?: SelectSubset<T, PartnerDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Partners.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PartnerUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Partners
     * const partner = await prisma.partner.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends PartnerUpdateManyArgs>(args: SelectSubset<T, PartnerUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Partners and returns the data updated in the database.
     * @param {PartnerUpdateManyAndReturnArgs} args - Arguments to update many Partners.
     * @example
     * // Update many Partners
     * const partner = await prisma.partner.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Partners and only return the `id`
     * const partnerWithIdOnly = await prisma.partner.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends PartnerUpdateManyAndReturnArgs>(args: SelectSubset<T, PartnerUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PartnerPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Partner.
     * @param {PartnerUpsertArgs} args - Arguments to update or create a Partner.
     * @example
     * // Update or create a Partner
     * const partner = await prisma.partner.upsert({
     *   create: {
     *     // ... data to create a Partner
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Partner we want to update
     *   }
     * })
     */
    upsert<T extends PartnerUpsertArgs>(args: SelectSubset<T, PartnerUpsertArgs<ExtArgs>>): Prisma__PartnerClient<$Result.GetResult<Prisma.$PartnerPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Partners.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PartnerCountArgs} args - Arguments to filter Partners to count.
     * @example
     * // Count the number of Partners
     * const count = await prisma.partner.count({
     *   where: {
     *     // ... the filter for the Partners we want to count
     *   }
     * })
    **/
    count<T extends PartnerCountArgs>(
      args?: Subset<T, PartnerCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], PartnerCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Partner.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PartnerAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends PartnerAggregateArgs>(args: Subset<T, PartnerAggregateArgs>): Prisma.PrismaPromise<GetPartnerAggregateType<T>>

    /**
     * Group by Partner.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PartnerGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends PartnerGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: PartnerGroupByArgs['orderBy'] }
        : { orderBy?: PartnerGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, PartnerGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetPartnerGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Partner model
   */
  readonly fields: PartnerFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Partner.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__PartnerClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    user<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    orders<T extends Partner$ordersArgs<ExtArgs> = {}>(args?: Subset<T, Partner$ordersArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$OrderPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    tickets<T extends Partner$ticketsArgs<ExtArgs> = {}>(args?: Subset<T, Partner$ticketsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SupportTicketPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    dailyStats<T extends Partner$dailyStatsArgs<ExtArgs> = {}>(args?: Subset<T, Partner$dailyStatsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PartnerDailyStatsPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    agentRatings<T extends Partner$agentRatingsArgs<ExtArgs> = {}>(args?: Subset<T, Partner$agentRatingsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AgentRatingPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    partnerRevenues<T extends Partner$partnerRevenuesArgs<ExtArgs> = {}>(args?: Subset<T, Partner$partnerRevenuesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PartnerRevenuePayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    platformRevenues<T extends Partner$platformRevenuesArgs<ExtArgs> = {}>(args?: Subset<T, Partner$platformRevenuesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PlatformRevenuePayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Partner model
   */
  interface PartnerFieldRefs {
    readonly id: FieldRef<"Partner", 'String'>
    readonly userId: FieldRef<"Partner", 'String'>
    readonly companyName: FieldRef<"Partner", 'String'>
    readonly apiKey: FieldRef<"Partner", 'String'>
    readonly webhookUrl: FieldRef<"Partner", 'String'>
    readonly isActive: FieldRef<"Partner", 'Boolean'>
    readonly city: FieldRef<"Partner", 'String'>
    readonly createdAt: FieldRef<"Partner", 'DateTime'>
    readonly updatedAt: FieldRef<"Partner", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Partner findUnique
   */
  export type PartnerFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Partner
     */
    select?: PartnerSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Partner
     */
    omit?: PartnerOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PartnerInclude<ExtArgs> | null
    /**
     * Filter, which Partner to fetch.
     */
    where: PartnerWhereUniqueInput
  }

  /**
   * Partner findUniqueOrThrow
   */
  export type PartnerFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Partner
     */
    select?: PartnerSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Partner
     */
    omit?: PartnerOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PartnerInclude<ExtArgs> | null
    /**
     * Filter, which Partner to fetch.
     */
    where: PartnerWhereUniqueInput
  }

  /**
   * Partner findFirst
   */
  export type PartnerFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Partner
     */
    select?: PartnerSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Partner
     */
    omit?: PartnerOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PartnerInclude<ExtArgs> | null
    /**
     * Filter, which Partner to fetch.
     */
    where?: PartnerWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Partners to fetch.
     */
    orderBy?: PartnerOrderByWithRelationInput | PartnerOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Partners.
     */
    cursor?: PartnerWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Partners from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Partners.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Partners.
     */
    distinct?: PartnerScalarFieldEnum | PartnerScalarFieldEnum[]
  }

  /**
   * Partner findFirstOrThrow
   */
  export type PartnerFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Partner
     */
    select?: PartnerSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Partner
     */
    omit?: PartnerOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PartnerInclude<ExtArgs> | null
    /**
     * Filter, which Partner to fetch.
     */
    where?: PartnerWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Partners to fetch.
     */
    orderBy?: PartnerOrderByWithRelationInput | PartnerOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Partners.
     */
    cursor?: PartnerWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Partners from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Partners.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Partners.
     */
    distinct?: PartnerScalarFieldEnum | PartnerScalarFieldEnum[]
  }

  /**
   * Partner findMany
   */
  export type PartnerFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Partner
     */
    select?: PartnerSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Partner
     */
    omit?: PartnerOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PartnerInclude<ExtArgs> | null
    /**
     * Filter, which Partners to fetch.
     */
    where?: PartnerWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Partners to fetch.
     */
    orderBy?: PartnerOrderByWithRelationInput | PartnerOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Partners.
     */
    cursor?: PartnerWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Partners from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Partners.
     */
    skip?: number
    distinct?: PartnerScalarFieldEnum | PartnerScalarFieldEnum[]
  }

  /**
   * Partner create
   */
  export type PartnerCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Partner
     */
    select?: PartnerSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Partner
     */
    omit?: PartnerOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PartnerInclude<ExtArgs> | null
    /**
     * The data needed to create a Partner.
     */
    data: XOR<PartnerCreateInput, PartnerUncheckedCreateInput>
  }

  /**
   * Partner createMany
   */
  export type PartnerCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Partners.
     */
    data: PartnerCreateManyInput | PartnerCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Partner createManyAndReturn
   */
  export type PartnerCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Partner
     */
    select?: PartnerSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Partner
     */
    omit?: PartnerOmit<ExtArgs> | null
    /**
     * The data used to create many Partners.
     */
    data: PartnerCreateManyInput | PartnerCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PartnerIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Partner update
   */
  export type PartnerUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Partner
     */
    select?: PartnerSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Partner
     */
    omit?: PartnerOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PartnerInclude<ExtArgs> | null
    /**
     * The data needed to update a Partner.
     */
    data: XOR<PartnerUpdateInput, PartnerUncheckedUpdateInput>
    /**
     * Choose, which Partner to update.
     */
    where: PartnerWhereUniqueInput
  }

  /**
   * Partner updateMany
   */
  export type PartnerUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Partners.
     */
    data: XOR<PartnerUpdateManyMutationInput, PartnerUncheckedUpdateManyInput>
    /**
     * Filter which Partners to update
     */
    where?: PartnerWhereInput
    /**
     * Limit how many Partners to update.
     */
    limit?: number
  }

  /**
   * Partner updateManyAndReturn
   */
  export type PartnerUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Partner
     */
    select?: PartnerSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Partner
     */
    omit?: PartnerOmit<ExtArgs> | null
    /**
     * The data used to update Partners.
     */
    data: XOR<PartnerUpdateManyMutationInput, PartnerUncheckedUpdateManyInput>
    /**
     * Filter which Partners to update
     */
    where?: PartnerWhereInput
    /**
     * Limit how many Partners to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PartnerIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * Partner upsert
   */
  export type PartnerUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Partner
     */
    select?: PartnerSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Partner
     */
    omit?: PartnerOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PartnerInclude<ExtArgs> | null
    /**
     * The filter to search for the Partner to update in case it exists.
     */
    where: PartnerWhereUniqueInput
    /**
     * In case the Partner found by the `where` argument doesn't exist, create a new Partner with this data.
     */
    create: XOR<PartnerCreateInput, PartnerUncheckedCreateInput>
    /**
     * In case the Partner was found with the provided `where` argument, update it with this data.
     */
    update: XOR<PartnerUpdateInput, PartnerUncheckedUpdateInput>
  }

  /**
   * Partner delete
   */
  export type PartnerDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Partner
     */
    select?: PartnerSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Partner
     */
    omit?: PartnerOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PartnerInclude<ExtArgs> | null
    /**
     * Filter which Partner to delete.
     */
    where: PartnerWhereUniqueInput
  }

  /**
   * Partner deleteMany
   */
  export type PartnerDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Partners to delete
     */
    where?: PartnerWhereInput
    /**
     * Limit how many Partners to delete.
     */
    limit?: number
  }

  /**
   * Partner.orders
   */
  export type Partner$ordersArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Order
     */
    select?: OrderSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Order
     */
    omit?: OrderOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OrderInclude<ExtArgs> | null
    where?: OrderWhereInput
    orderBy?: OrderOrderByWithRelationInput | OrderOrderByWithRelationInput[]
    cursor?: OrderWhereUniqueInput
    take?: number
    skip?: number
    distinct?: OrderScalarFieldEnum | OrderScalarFieldEnum[]
  }

  /**
   * Partner.tickets
   */
  export type Partner$ticketsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SupportTicket
     */
    select?: SupportTicketSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SupportTicket
     */
    omit?: SupportTicketOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SupportTicketInclude<ExtArgs> | null
    where?: SupportTicketWhereInput
    orderBy?: SupportTicketOrderByWithRelationInput | SupportTicketOrderByWithRelationInput[]
    cursor?: SupportTicketWhereUniqueInput
    take?: number
    skip?: number
    distinct?: SupportTicketScalarFieldEnum | SupportTicketScalarFieldEnum[]
  }

  /**
   * Partner.dailyStats
   */
  export type Partner$dailyStatsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PartnerDailyStats
     */
    select?: PartnerDailyStatsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PartnerDailyStats
     */
    omit?: PartnerDailyStatsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PartnerDailyStatsInclude<ExtArgs> | null
    where?: PartnerDailyStatsWhereInput
    orderBy?: PartnerDailyStatsOrderByWithRelationInput | PartnerDailyStatsOrderByWithRelationInput[]
    cursor?: PartnerDailyStatsWhereUniqueInput
    take?: number
    skip?: number
    distinct?: PartnerDailyStatsScalarFieldEnum | PartnerDailyStatsScalarFieldEnum[]
  }

  /**
   * Partner.agentRatings
   */
  export type Partner$agentRatingsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AgentRating
     */
    select?: AgentRatingSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AgentRating
     */
    omit?: AgentRatingOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AgentRatingInclude<ExtArgs> | null
    where?: AgentRatingWhereInput
    orderBy?: AgentRatingOrderByWithRelationInput | AgentRatingOrderByWithRelationInput[]
    cursor?: AgentRatingWhereUniqueInput
    take?: number
    skip?: number
    distinct?: AgentRatingScalarFieldEnum | AgentRatingScalarFieldEnum[]
  }

  /**
   * Partner.partnerRevenues
   */
  export type Partner$partnerRevenuesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PartnerRevenue
     */
    select?: PartnerRevenueSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PartnerRevenue
     */
    omit?: PartnerRevenueOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PartnerRevenueInclude<ExtArgs> | null
    where?: PartnerRevenueWhereInput
    orderBy?: PartnerRevenueOrderByWithRelationInput | PartnerRevenueOrderByWithRelationInput[]
    cursor?: PartnerRevenueWhereUniqueInput
    take?: number
    skip?: number
    distinct?: PartnerRevenueScalarFieldEnum | PartnerRevenueScalarFieldEnum[]
  }

  /**
   * Partner.platformRevenues
   */
  export type Partner$platformRevenuesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PlatformRevenue
     */
    select?: PlatformRevenueSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PlatformRevenue
     */
    omit?: PlatformRevenueOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PlatformRevenueInclude<ExtArgs> | null
    where?: PlatformRevenueWhereInput
    orderBy?: PlatformRevenueOrderByWithRelationInput | PlatformRevenueOrderByWithRelationInput[]
    cursor?: PlatformRevenueWhereUniqueInput
    take?: number
    skip?: number
    distinct?: PlatformRevenueScalarFieldEnum | PlatformRevenueScalarFieldEnum[]
  }

  /**
   * Partner without action
   */
  export type PartnerDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Partner
     */
    select?: PartnerSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Partner
     */
    omit?: PartnerOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PartnerInclude<ExtArgs> | null
  }


  /**
   * Model Order
   */

  export type AggregateOrder = {
    _count: OrderCountAggregateOutputType | null
    _avg: OrderAvgAggregateOutputType | null
    _sum: OrderSumAggregateOutputType | null
    _min: OrderMinAggregateOutputType | null
    _max: OrderMaxAggregateOutputType | null
  }

  export type OrderAvgAggregateOutputType = {
    pickupLat: number | null
    pickupLng: number | null
    dropLat: number | null
    dropLng: number | null
    payoutAmount: number | null
    orderAmount: number | null
    platformFee: number | null
    commissionRate: number | null
    estimatedDuration: number | null
    actualDuration: number | null
  }

  export type OrderSumAggregateOutputType = {
    pickupLat: number | null
    pickupLng: number | null
    dropLat: number | null
    dropLng: number | null
    payoutAmount: number | null
    orderAmount: number | null
    platformFee: number | null
    commissionRate: number | null
    estimatedDuration: number | null
    actualDuration: number | null
  }

  export type OrderMinAggregateOutputType = {
    id: string | null
    partnerId: string | null
    agentId: string | null
    pickupLat: number | null
    pickupLng: number | null
    dropLat: number | null
    dropLng: number | null
    payoutAmount: number | null
    orderAmount: number | null
    platformFee: number | null
    orderType: string | null
    commissionRate: number | null
    priority: string | null
    status: $Enums.OrderStatus | null
    assignedAt: Date | null
    pickedUpAt: Date | null
    deliveredAt: Date | null
    cancelledAt: Date | null
    cancellationReason: string | null
    estimatedDuration: number | null
    actualDuration: number | null
    createdAt: Date | null
    updatedAt: Date | null
    barcode: string | null
    qrCode: string | null
    deliveryOtp: string | null
    deliveryQrCode: string | null
    otpExpiresAt: Date | null
    verifiedAt: Date | null
    verificationMethod: string | null
  }

  export type OrderMaxAggregateOutputType = {
    id: string | null
    partnerId: string | null
    agentId: string | null
    pickupLat: number | null
    pickupLng: number | null
    dropLat: number | null
    dropLng: number | null
    payoutAmount: number | null
    orderAmount: number | null
    platformFee: number | null
    orderType: string | null
    commissionRate: number | null
    priority: string | null
    status: $Enums.OrderStatus | null
    assignedAt: Date | null
    pickedUpAt: Date | null
    deliveredAt: Date | null
    cancelledAt: Date | null
    cancellationReason: string | null
    estimatedDuration: number | null
    actualDuration: number | null
    createdAt: Date | null
    updatedAt: Date | null
    barcode: string | null
    qrCode: string | null
    deliveryOtp: string | null
    deliveryQrCode: string | null
    otpExpiresAt: Date | null
    verifiedAt: Date | null
    verificationMethod: string | null
  }

  export type OrderCountAggregateOutputType = {
    id: number
    partnerId: number
    agentId: number
    pickupLat: number
    pickupLng: number
    dropLat: number
    dropLng: number
    payoutAmount: number
    orderAmount: number
    platformFee: number
    orderType: number
    commissionRate: number
    priority: number
    status: number
    assignedAt: number
    pickedUpAt: number
    deliveredAt: number
    cancelledAt: number
    cancellationReason: number
    estimatedDuration: number
    actualDuration: number
    createdAt: number
    updatedAt: number
    barcode: number
    qrCode: number
    deliveryOtp: number
    deliveryQrCode: number
    otpExpiresAt: number
    verifiedAt: number
    verificationMethod: number
    _all: number
  }


  export type OrderAvgAggregateInputType = {
    pickupLat?: true
    pickupLng?: true
    dropLat?: true
    dropLng?: true
    payoutAmount?: true
    orderAmount?: true
    platformFee?: true
    commissionRate?: true
    estimatedDuration?: true
    actualDuration?: true
  }

  export type OrderSumAggregateInputType = {
    pickupLat?: true
    pickupLng?: true
    dropLat?: true
    dropLng?: true
    payoutAmount?: true
    orderAmount?: true
    platformFee?: true
    commissionRate?: true
    estimatedDuration?: true
    actualDuration?: true
  }

  export type OrderMinAggregateInputType = {
    id?: true
    partnerId?: true
    agentId?: true
    pickupLat?: true
    pickupLng?: true
    dropLat?: true
    dropLng?: true
    payoutAmount?: true
    orderAmount?: true
    platformFee?: true
    orderType?: true
    commissionRate?: true
    priority?: true
    status?: true
    assignedAt?: true
    pickedUpAt?: true
    deliveredAt?: true
    cancelledAt?: true
    cancellationReason?: true
    estimatedDuration?: true
    actualDuration?: true
    createdAt?: true
    updatedAt?: true
    barcode?: true
    qrCode?: true
    deliveryOtp?: true
    deliveryQrCode?: true
    otpExpiresAt?: true
    verifiedAt?: true
    verificationMethod?: true
  }

  export type OrderMaxAggregateInputType = {
    id?: true
    partnerId?: true
    agentId?: true
    pickupLat?: true
    pickupLng?: true
    dropLat?: true
    dropLng?: true
    payoutAmount?: true
    orderAmount?: true
    platformFee?: true
    orderType?: true
    commissionRate?: true
    priority?: true
    status?: true
    assignedAt?: true
    pickedUpAt?: true
    deliveredAt?: true
    cancelledAt?: true
    cancellationReason?: true
    estimatedDuration?: true
    actualDuration?: true
    createdAt?: true
    updatedAt?: true
    barcode?: true
    qrCode?: true
    deliveryOtp?: true
    deliveryQrCode?: true
    otpExpiresAt?: true
    verifiedAt?: true
    verificationMethod?: true
  }

  export type OrderCountAggregateInputType = {
    id?: true
    partnerId?: true
    agentId?: true
    pickupLat?: true
    pickupLng?: true
    dropLat?: true
    dropLng?: true
    payoutAmount?: true
    orderAmount?: true
    platformFee?: true
    orderType?: true
    commissionRate?: true
    priority?: true
    status?: true
    assignedAt?: true
    pickedUpAt?: true
    deliveredAt?: true
    cancelledAt?: true
    cancellationReason?: true
    estimatedDuration?: true
    actualDuration?: true
    createdAt?: true
    updatedAt?: true
    barcode?: true
    qrCode?: true
    deliveryOtp?: true
    deliveryQrCode?: true
    otpExpiresAt?: true
    verifiedAt?: true
    verificationMethod?: true
    _all?: true
  }

  export type OrderAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Order to aggregate.
     */
    where?: OrderWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Orders to fetch.
     */
    orderBy?: OrderOrderByWithRelationInput | OrderOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: OrderWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Orders from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Orders.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Orders
    **/
    _count?: true | OrderCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: OrderAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: OrderSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: OrderMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: OrderMaxAggregateInputType
  }

  export type GetOrderAggregateType<T extends OrderAggregateArgs> = {
        [P in keyof T & keyof AggregateOrder]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateOrder[P]>
      : GetScalarType<T[P], AggregateOrder[P]>
  }




  export type OrderGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: OrderWhereInput
    orderBy?: OrderOrderByWithAggregationInput | OrderOrderByWithAggregationInput[]
    by: OrderScalarFieldEnum[] | OrderScalarFieldEnum
    having?: OrderScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: OrderCountAggregateInputType | true
    _avg?: OrderAvgAggregateInputType
    _sum?: OrderSumAggregateInputType
    _min?: OrderMinAggregateInputType
    _max?: OrderMaxAggregateInputType
  }

  export type OrderGroupByOutputType = {
    id: string
    partnerId: string
    agentId: string | null
    pickupLat: number
    pickupLng: number
    dropLat: number
    dropLng: number
    payoutAmount: number
    orderAmount: number | null
    platformFee: number | null
    orderType: string | null
    commissionRate: number | null
    priority: string | null
    status: $Enums.OrderStatus
    assignedAt: Date | null
    pickedUpAt: Date | null
    deliveredAt: Date | null
    cancelledAt: Date | null
    cancellationReason: string | null
    estimatedDuration: number | null
    actualDuration: number | null
    createdAt: Date
    updatedAt: Date
    barcode: string | null
    qrCode: string | null
    deliveryOtp: string | null
    deliveryQrCode: string | null
    otpExpiresAt: Date | null
    verifiedAt: Date | null
    verificationMethod: string | null
    _count: OrderCountAggregateOutputType | null
    _avg: OrderAvgAggregateOutputType | null
    _sum: OrderSumAggregateOutputType | null
    _min: OrderMinAggregateOutputType | null
    _max: OrderMaxAggregateOutputType | null
  }

  type GetOrderGroupByPayload<T extends OrderGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<OrderGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof OrderGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], OrderGroupByOutputType[P]>
            : GetScalarType<T[P], OrderGroupByOutputType[P]>
        }
      >
    >


  export type OrderSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    partnerId?: boolean
    agentId?: boolean
    pickupLat?: boolean
    pickupLng?: boolean
    dropLat?: boolean
    dropLng?: boolean
    payoutAmount?: boolean
    orderAmount?: boolean
    platformFee?: boolean
    orderType?: boolean
    commissionRate?: boolean
    priority?: boolean
    status?: boolean
    assignedAt?: boolean
    pickedUpAt?: boolean
    deliveredAt?: boolean
    cancelledAt?: boolean
    cancellationReason?: boolean
    estimatedDuration?: boolean
    actualDuration?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    barcode?: boolean
    qrCode?: boolean
    deliveryOtp?: boolean
    deliveryQrCode?: boolean
    otpExpiresAt?: boolean
    verifiedAt?: boolean
    verificationMethod?: boolean
    partner?: boolean | PartnerDefaultArgs<ExtArgs>
    agent?: boolean | Order$agentArgs<ExtArgs>
    currentAgent?: boolean | Order$currentAgentArgs<ExtArgs>
    tickets?: boolean | Order$ticketsArgs<ExtArgs>
    rating?: boolean | Order$ratingArgs<ExtArgs>
    payments?: boolean | Order$paymentsArgs<ExtArgs>
    partnerRevenue?: boolean | Order$partnerRevenueArgs<ExtArgs>
    platformRevenue?: boolean | Order$platformRevenueArgs<ExtArgs>
    walletTransactions?: boolean | Order$walletTransactionsArgs<ExtArgs>
    _count?: boolean | OrderCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["order"]>

  export type OrderSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    partnerId?: boolean
    agentId?: boolean
    pickupLat?: boolean
    pickupLng?: boolean
    dropLat?: boolean
    dropLng?: boolean
    payoutAmount?: boolean
    orderAmount?: boolean
    platformFee?: boolean
    orderType?: boolean
    commissionRate?: boolean
    priority?: boolean
    status?: boolean
    assignedAt?: boolean
    pickedUpAt?: boolean
    deliveredAt?: boolean
    cancelledAt?: boolean
    cancellationReason?: boolean
    estimatedDuration?: boolean
    actualDuration?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    barcode?: boolean
    qrCode?: boolean
    deliveryOtp?: boolean
    deliveryQrCode?: boolean
    otpExpiresAt?: boolean
    verifiedAt?: boolean
    verificationMethod?: boolean
    partner?: boolean | PartnerDefaultArgs<ExtArgs>
    agent?: boolean | Order$agentArgs<ExtArgs>
  }, ExtArgs["result"]["order"]>

  export type OrderSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    partnerId?: boolean
    agentId?: boolean
    pickupLat?: boolean
    pickupLng?: boolean
    dropLat?: boolean
    dropLng?: boolean
    payoutAmount?: boolean
    orderAmount?: boolean
    platformFee?: boolean
    orderType?: boolean
    commissionRate?: boolean
    priority?: boolean
    status?: boolean
    assignedAt?: boolean
    pickedUpAt?: boolean
    deliveredAt?: boolean
    cancelledAt?: boolean
    cancellationReason?: boolean
    estimatedDuration?: boolean
    actualDuration?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    barcode?: boolean
    qrCode?: boolean
    deliveryOtp?: boolean
    deliveryQrCode?: boolean
    otpExpiresAt?: boolean
    verifiedAt?: boolean
    verificationMethod?: boolean
    partner?: boolean | PartnerDefaultArgs<ExtArgs>
    agent?: boolean | Order$agentArgs<ExtArgs>
  }, ExtArgs["result"]["order"]>

  export type OrderSelectScalar = {
    id?: boolean
    partnerId?: boolean
    agentId?: boolean
    pickupLat?: boolean
    pickupLng?: boolean
    dropLat?: boolean
    dropLng?: boolean
    payoutAmount?: boolean
    orderAmount?: boolean
    platformFee?: boolean
    orderType?: boolean
    commissionRate?: boolean
    priority?: boolean
    status?: boolean
    assignedAt?: boolean
    pickedUpAt?: boolean
    deliveredAt?: boolean
    cancelledAt?: boolean
    cancellationReason?: boolean
    estimatedDuration?: boolean
    actualDuration?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    barcode?: boolean
    qrCode?: boolean
    deliveryOtp?: boolean
    deliveryQrCode?: boolean
    otpExpiresAt?: boolean
    verifiedAt?: boolean
    verificationMethod?: boolean
  }

  export type OrderOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "partnerId" | "agentId" | "pickupLat" | "pickupLng" | "dropLat" | "dropLng" | "payoutAmount" | "orderAmount" | "platformFee" | "orderType" | "commissionRate" | "priority" | "status" | "assignedAt" | "pickedUpAt" | "deliveredAt" | "cancelledAt" | "cancellationReason" | "estimatedDuration" | "actualDuration" | "createdAt" | "updatedAt" | "barcode" | "qrCode" | "deliveryOtp" | "deliveryQrCode" | "otpExpiresAt" | "verifiedAt" | "verificationMethod", ExtArgs["result"]["order"]>
  export type OrderInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    partner?: boolean | PartnerDefaultArgs<ExtArgs>
    agent?: boolean | Order$agentArgs<ExtArgs>
    currentAgent?: boolean | Order$currentAgentArgs<ExtArgs>
    tickets?: boolean | Order$ticketsArgs<ExtArgs>
    rating?: boolean | Order$ratingArgs<ExtArgs>
    payments?: boolean | Order$paymentsArgs<ExtArgs>
    partnerRevenue?: boolean | Order$partnerRevenueArgs<ExtArgs>
    platformRevenue?: boolean | Order$platformRevenueArgs<ExtArgs>
    walletTransactions?: boolean | Order$walletTransactionsArgs<ExtArgs>
    _count?: boolean | OrderCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type OrderIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    partner?: boolean | PartnerDefaultArgs<ExtArgs>
    agent?: boolean | Order$agentArgs<ExtArgs>
  }
  export type OrderIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    partner?: boolean | PartnerDefaultArgs<ExtArgs>
    agent?: boolean | Order$agentArgs<ExtArgs>
  }

  export type $OrderPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Order"
    objects: {
      partner: Prisma.$PartnerPayload<ExtArgs>
      agent: Prisma.$AgentPayload<ExtArgs> | null
      currentAgent: Prisma.$AgentPayload<ExtArgs> | null
      tickets: Prisma.$SupportTicketPayload<ExtArgs>[]
      rating: Prisma.$AgentRatingPayload<ExtArgs> | null
      payments: Prisma.$PaymentPayload<ExtArgs>[]
      partnerRevenue: Prisma.$PartnerRevenuePayload<ExtArgs> | null
      platformRevenue: Prisma.$PlatformRevenuePayload<ExtArgs> | null
      walletTransactions: Prisma.$WalletTransactionPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      partnerId: string
      agentId: string | null
      pickupLat: number
      pickupLng: number
      dropLat: number
      dropLng: number
      payoutAmount: number
      orderAmount: number | null
      platformFee: number | null
      orderType: string | null
      commissionRate: number | null
      priority: string | null
      status: $Enums.OrderStatus
      assignedAt: Date | null
      pickedUpAt: Date | null
      deliveredAt: Date | null
      cancelledAt: Date | null
      cancellationReason: string | null
      estimatedDuration: number | null
      actualDuration: number | null
      createdAt: Date
      updatedAt: Date
      barcode: string | null
      qrCode: string | null
      deliveryOtp: string | null
      deliveryQrCode: string | null
      otpExpiresAt: Date | null
      verifiedAt: Date | null
      verificationMethod: string | null
    }, ExtArgs["result"]["order"]>
    composites: {}
  }

  type OrderGetPayload<S extends boolean | null | undefined | OrderDefaultArgs> = $Result.GetResult<Prisma.$OrderPayload, S>

  type OrderCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<OrderFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: OrderCountAggregateInputType | true
    }

  export interface OrderDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Order'], meta: { name: 'Order' } }
    /**
     * Find zero or one Order that matches the filter.
     * @param {OrderFindUniqueArgs} args - Arguments to find a Order
     * @example
     * // Get one Order
     * const order = await prisma.order.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends OrderFindUniqueArgs>(args: SelectSubset<T, OrderFindUniqueArgs<ExtArgs>>): Prisma__OrderClient<$Result.GetResult<Prisma.$OrderPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Order that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {OrderFindUniqueOrThrowArgs} args - Arguments to find a Order
     * @example
     * // Get one Order
     * const order = await prisma.order.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends OrderFindUniqueOrThrowArgs>(args: SelectSubset<T, OrderFindUniqueOrThrowArgs<ExtArgs>>): Prisma__OrderClient<$Result.GetResult<Prisma.$OrderPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Order that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {OrderFindFirstArgs} args - Arguments to find a Order
     * @example
     * // Get one Order
     * const order = await prisma.order.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends OrderFindFirstArgs>(args?: SelectSubset<T, OrderFindFirstArgs<ExtArgs>>): Prisma__OrderClient<$Result.GetResult<Prisma.$OrderPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Order that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {OrderFindFirstOrThrowArgs} args - Arguments to find a Order
     * @example
     * // Get one Order
     * const order = await prisma.order.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends OrderFindFirstOrThrowArgs>(args?: SelectSubset<T, OrderFindFirstOrThrowArgs<ExtArgs>>): Prisma__OrderClient<$Result.GetResult<Prisma.$OrderPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Orders that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {OrderFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Orders
     * const orders = await prisma.order.findMany()
     * 
     * // Get first 10 Orders
     * const orders = await prisma.order.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const orderWithIdOnly = await prisma.order.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends OrderFindManyArgs>(args?: SelectSubset<T, OrderFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$OrderPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Order.
     * @param {OrderCreateArgs} args - Arguments to create a Order.
     * @example
     * // Create one Order
     * const Order = await prisma.order.create({
     *   data: {
     *     // ... data to create a Order
     *   }
     * })
     * 
     */
    create<T extends OrderCreateArgs>(args: SelectSubset<T, OrderCreateArgs<ExtArgs>>): Prisma__OrderClient<$Result.GetResult<Prisma.$OrderPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Orders.
     * @param {OrderCreateManyArgs} args - Arguments to create many Orders.
     * @example
     * // Create many Orders
     * const order = await prisma.order.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends OrderCreateManyArgs>(args?: SelectSubset<T, OrderCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Orders and returns the data saved in the database.
     * @param {OrderCreateManyAndReturnArgs} args - Arguments to create many Orders.
     * @example
     * // Create many Orders
     * const order = await prisma.order.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Orders and only return the `id`
     * const orderWithIdOnly = await prisma.order.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends OrderCreateManyAndReturnArgs>(args?: SelectSubset<T, OrderCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$OrderPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Order.
     * @param {OrderDeleteArgs} args - Arguments to delete one Order.
     * @example
     * // Delete one Order
     * const Order = await prisma.order.delete({
     *   where: {
     *     // ... filter to delete one Order
     *   }
     * })
     * 
     */
    delete<T extends OrderDeleteArgs>(args: SelectSubset<T, OrderDeleteArgs<ExtArgs>>): Prisma__OrderClient<$Result.GetResult<Prisma.$OrderPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Order.
     * @param {OrderUpdateArgs} args - Arguments to update one Order.
     * @example
     * // Update one Order
     * const order = await prisma.order.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends OrderUpdateArgs>(args: SelectSubset<T, OrderUpdateArgs<ExtArgs>>): Prisma__OrderClient<$Result.GetResult<Prisma.$OrderPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Orders.
     * @param {OrderDeleteManyArgs} args - Arguments to filter Orders to delete.
     * @example
     * // Delete a few Orders
     * const { count } = await prisma.order.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends OrderDeleteManyArgs>(args?: SelectSubset<T, OrderDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Orders.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {OrderUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Orders
     * const order = await prisma.order.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends OrderUpdateManyArgs>(args: SelectSubset<T, OrderUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Orders and returns the data updated in the database.
     * @param {OrderUpdateManyAndReturnArgs} args - Arguments to update many Orders.
     * @example
     * // Update many Orders
     * const order = await prisma.order.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Orders and only return the `id`
     * const orderWithIdOnly = await prisma.order.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends OrderUpdateManyAndReturnArgs>(args: SelectSubset<T, OrderUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$OrderPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Order.
     * @param {OrderUpsertArgs} args - Arguments to update or create a Order.
     * @example
     * // Update or create a Order
     * const order = await prisma.order.upsert({
     *   create: {
     *     // ... data to create a Order
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Order we want to update
     *   }
     * })
     */
    upsert<T extends OrderUpsertArgs>(args: SelectSubset<T, OrderUpsertArgs<ExtArgs>>): Prisma__OrderClient<$Result.GetResult<Prisma.$OrderPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Orders.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {OrderCountArgs} args - Arguments to filter Orders to count.
     * @example
     * // Count the number of Orders
     * const count = await prisma.order.count({
     *   where: {
     *     // ... the filter for the Orders we want to count
     *   }
     * })
    **/
    count<T extends OrderCountArgs>(
      args?: Subset<T, OrderCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], OrderCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Order.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {OrderAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends OrderAggregateArgs>(args: Subset<T, OrderAggregateArgs>): Prisma.PrismaPromise<GetOrderAggregateType<T>>

    /**
     * Group by Order.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {OrderGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends OrderGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: OrderGroupByArgs['orderBy'] }
        : { orderBy?: OrderGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, OrderGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetOrderGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Order model
   */
  readonly fields: OrderFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Order.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__OrderClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    partner<T extends PartnerDefaultArgs<ExtArgs> = {}>(args?: Subset<T, PartnerDefaultArgs<ExtArgs>>): Prisma__PartnerClient<$Result.GetResult<Prisma.$PartnerPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    agent<T extends Order$agentArgs<ExtArgs> = {}>(args?: Subset<T, Order$agentArgs<ExtArgs>>): Prisma__AgentClient<$Result.GetResult<Prisma.$AgentPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    currentAgent<T extends Order$currentAgentArgs<ExtArgs> = {}>(args?: Subset<T, Order$currentAgentArgs<ExtArgs>>): Prisma__AgentClient<$Result.GetResult<Prisma.$AgentPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    tickets<T extends Order$ticketsArgs<ExtArgs> = {}>(args?: Subset<T, Order$ticketsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SupportTicketPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    rating<T extends Order$ratingArgs<ExtArgs> = {}>(args?: Subset<T, Order$ratingArgs<ExtArgs>>): Prisma__AgentRatingClient<$Result.GetResult<Prisma.$AgentRatingPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    payments<T extends Order$paymentsArgs<ExtArgs> = {}>(args?: Subset<T, Order$paymentsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PaymentPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    partnerRevenue<T extends Order$partnerRevenueArgs<ExtArgs> = {}>(args?: Subset<T, Order$partnerRevenueArgs<ExtArgs>>): Prisma__PartnerRevenueClient<$Result.GetResult<Prisma.$PartnerRevenuePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    platformRevenue<T extends Order$platformRevenueArgs<ExtArgs> = {}>(args?: Subset<T, Order$platformRevenueArgs<ExtArgs>>): Prisma__PlatformRevenueClient<$Result.GetResult<Prisma.$PlatformRevenuePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    walletTransactions<T extends Order$walletTransactionsArgs<ExtArgs> = {}>(args?: Subset<T, Order$walletTransactionsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$WalletTransactionPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Order model
   */
  interface OrderFieldRefs {
    readonly id: FieldRef<"Order", 'String'>
    readonly partnerId: FieldRef<"Order", 'String'>
    readonly agentId: FieldRef<"Order", 'String'>
    readonly pickupLat: FieldRef<"Order", 'Float'>
    readonly pickupLng: FieldRef<"Order", 'Float'>
    readonly dropLat: FieldRef<"Order", 'Float'>
    readonly dropLng: FieldRef<"Order", 'Float'>
    readonly payoutAmount: FieldRef<"Order", 'Float'>
    readonly orderAmount: FieldRef<"Order", 'Float'>
    readonly platformFee: FieldRef<"Order", 'Float'>
    readonly orderType: FieldRef<"Order", 'String'>
    readonly commissionRate: FieldRef<"Order", 'Float'>
    readonly priority: FieldRef<"Order", 'String'>
    readonly status: FieldRef<"Order", 'OrderStatus'>
    readonly assignedAt: FieldRef<"Order", 'DateTime'>
    readonly pickedUpAt: FieldRef<"Order", 'DateTime'>
    readonly deliveredAt: FieldRef<"Order", 'DateTime'>
    readonly cancelledAt: FieldRef<"Order", 'DateTime'>
    readonly cancellationReason: FieldRef<"Order", 'String'>
    readonly estimatedDuration: FieldRef<"Order", 'Int'>
    readonly actualDuration: FieldRef<"Order", 'Int'>
    readonly createdAt: FieldRef<"Order", 'DateTime'>
    readonly updatedAt: FieldRef<"Order", 'DateTime'>
    readonly barcode: FieldRef<"Order", 'String'>
    readonly qrCode: FieldRef<"Order", 'String'>
    readonly deliveryOtp: FieldRef<"Order", 'String'>
    readonly deliveryQrCode: FieldRef<"Order", 'String'>
    readonly otpExpiresAt: FieldRef<"Order", 'DateTime'>
    readonly verifiedAt: FieldRef<"Order", 'DateTime'>
    readonly verificationMethod: FieldRef<"Order", 'String'>
  }
    

  // Custom InputTypes
  /**
   * Order findUnique
   */
  export type OrderFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Order
     */
    select?: OrderSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Order
     */
    omit?: OrderOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OrderInclude<ExtArgs> | null
    /**
     * Filter, which Order to fetch.
     */
    where: OrderWhereUniqueInput
  }

  /**
   * Order findUniqueOrThrow
   */
  export type OrderFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Order
     */
    select?: OrderSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Order
     */
    omit?: OrderOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OrderInclude<ExtArgs> | null
    /**
     * Filter, which Order to fetch.
     */
    where: OrderWhereUniqueInput
  }

  /**
   * Order findFirst
   */
  export type OrderFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Order
     */
    select?: OrderSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Order
     */
    omit?: OrderOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OrderInclude<ExtArgs> | null
    /**
     * Filter, which Order to fetch.
     */
    where?: OrderWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Orders to fetch.
     */
    orderBy?: OrderOrderByWithRelationInput | OrderOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Orders.
     */
    cursor?: OrderWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Orders from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Orders.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Orders.
     */
    distinct?: OrderScalarFieldEnum | OrderScalarFieldEnum[]
  }

  /**
   * Order findFirstOrThrow
   */
  export type OrderFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Order
     */
    select?: OrderSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Order
     */
    omit?: OrderOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OrderInclude<ExtArgs> | null
    /**
     * Filter, which Order to fetch.
     */
    where?: OrderWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Orders to fetch.
     */
    orderBy?: OrderOrderByWithRelationInput | OrderOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Orders.
     */
    cursor?: OrderWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Orders from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Orders.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Orders.
     */
    distinct?: OrderScalarFieldEnum | OrderScalarFieldEnum[]
  }

  /**
   * Order findMany
   */
  export type OrderFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Order
     */
    select?: OrderSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Order
     */
    omit?: OrderOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OrderInclude<ExtArgs> | null
    /**
     * Filter, which Orders to fetch.
     */
    where?: OrderWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Orders to fetch.
     */
    orderBy?: OrderOrderByWithRelationInput | OrderOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Orders.
     */
    cursor?: OrderWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Orders from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Orders.
     */
    skip?: number
    distinct?: OrderScalarFieldEnum | OrderScalarFieldEnum[]
  }

  /**
   * Order create
   */
  export type OrderCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Order
     */
    select?: OrderSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Order
     */
    omit?: OrderOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OrderInclude<ExtArgs> | null
    /**
     * The data needed to create a Order.
     */
    data: XOR<OrderCreateInput, OrderUncheckedCreateInput>
  }

  /**
   * Order createMany
   */
  export type OrderCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Orders.
     */
    data: OrderCreateManyInput | OrderCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Order createManyAndReturn
   */
  export type OrderCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Order
     */
    select?: OrderSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Order
     */
    omit?: OrderOmit<ExtArgs> | null
    /**
     * The data used to create many Orders.
     */
    data: OrderCreateManyInput | OrderCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OrderIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Order update
   */
  export type OrderUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Order
     */
    select?: OrderSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Order
     */
    omit?: OrderOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OrderInclude<ExtArgs> | null
    /**
     * The data needed to update a Order.
     */
    data: XOR<OrderUpdateInput, OrderUncheckedUpdateInput>
    /**
     * Choose, which Order to update.
     */
    where: OrderWhereUniqueInput
  }

  /**
   * Order updateMany
   */
  export type OrderUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Orders.
     */
    data: XOR<OrderUpdateManyMutationInput, OrderUncheckedUpdateManyInput>
    /**
     * Filter which Orders to update
     */
    where?: OrderWhereInput
    /**
     * Limit how many Orders to update.
     */
    limit?: number
  }

  /**
   * Order updateManyAndReturn
   */
  export type OrderUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Order
     */
    select?: OrderSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Order
     */
    omit?: OrderOmit<ExtArgs> | null
    /**
     * The data used to update Orders.
     */
    data: XOR<OrderUpdateManyMutationInput, OrderUncheckedUpdateManyInput>
    /**
     * Filter which Orders to update
     */
    where?: OrderWhereInput
    /**
     * Limit how many Orders to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OrderIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * Order upsert
   */
  export type OrderUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Order
     */
    select?: OrderSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Order
     */
    omit?: OrderOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OrderInclude<ExtArgs> | null
    /**
     * The filter to search for the Order to update in case it exists.
     */
    where: OrderWhereUniqueInput
    /**
     * In case the Order found by the `where` argument doesn't exist, create a new Order with this data.
     */
    create: XOR<OrderCreateInput, OrderUncheckedCreateInput>
    /**
     * In case the Order was found with the provided `where` argument, update it with this data.
     */
    update: XOR<OrderUpdateInput, OrderUncheckedUpdateInput>
  }

  /**
   * Order delete
   */
  export type OrderDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Order
     */
    select?: OrderSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Order
     */
    omit?: OrderOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OrderInclude<ExtArgs> | null
    /**
     * Filter which Order to delete.
     */
    where: OrderWhereUniqueInput
  }

  /**
   * Order deleteMany
   */
  export type OrderDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Orders to delete
     */
    where?: OrderWhereInput
    /**
     * Limit how many Orders to delete.
     */
    limit?: number
  }

  /**
   * Order.agent
   */
  export type Order$agentArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Agent
     */
    select?: AgentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Agent
     */
    omit?: AgentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AgentInclude<ExtArgs> | null
    where?: AgentWhereInput
  }

  /**
   * Order.currentAgent
   */
  export type Order$currentAgentArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Agent
     */
    select?: AgentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Agent
     */
    omit?: AgentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AgentInclude<ExtArgs> | null
    where?: AgentWhereInput
  }

  /**
   * Order.tickets
   */
  export type Order$ticketsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SupportTicket
     */
    select?: SupportTicketSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SupportTicket
     */
    omit?: SupportTicketOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SupportTicketInclude<ExtArgs> | null
    where?: SupportTicketWhereInput
    orderBy?: SupportTicketOrderByWithRelationInput | SupportTicketOrderByWithRelationInput[]
    cursor?: SupportTicketWhereUniqueInput
    take?: number
    skip?: number
    distinct?: SupportTicketScalarFieldEnum | SupportTicketScalarFieldEnum[]
  }

  /**
   * Order.rating
   */
  export type Order$ratingArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AgentRating
     */
    select?: AgentRatingSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AgentRating
     */
    omit?: AgentRatingOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AgentRatingInclude<ExtArgs> | null
    where?: AgentRatingWhereInput
  }

  /**
   * Order.payments
   */
  export type Order$paymentsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Payment
     */
    select?: PaymentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Payment
     */
    omit?: PaymentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PaymentInclude<ExtArgs> | null
    where?: PaymentWhereInput
    orderBy?: PaymentOrderByWithRelationInput | PaymentOrderByWithRelationInput[]
    cursor?: PaymentWhereUniqueInput
    take?: number
    skip?: number
    distinct?: PaymentScalarFieldEnum | PaymentScalarFieldEnum[]
  }

  /**
   * Order.partnerRevenue
   */
  export type Order$partnerRevenueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PartnerRevenue
     */
    select?: PartnerRevenueSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PartnerRevenue
     */
    omit?: PartnerRevenueOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PartnerRevenueInclude<ExtArgs> | null
    where?: PartnerRevenueWhereInput
  }

  /**
   * Order.platformRevenue
   */
  export type Order$platformRevenueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PlatformRevenue
     */
    select?: PlatformRevenueSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PlatformRevenue
     */
    omit?: PlatformRevenueOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PlatformRevenueInclude<ExtArgs> | null
    where?: PlatformRevenueWhereInput
  }

  /**
   * Order.walletTransactions
   */
  export type Order$walletTransactionsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WalletTransaction
     */
    select?: WalletTransactionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the WalletTransaction
     */
    omit?: WalletTransactionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WalletTransactionInclude<ExtArgs> | null
    where?: WalletTransactionWhereInput
    orderBy?: WalletTransactionOrderByWithRelationInput | WalletTransactionOrderByWithRelationInput[]
    cursor?: WalletTransactionWhereUniqueInput
    take?: number
    skip?: number
    distinct?: WalletTransactionScalarFieldEnum | WalletTransactionScalarFieldEnum[]
  }

  /**
   * Order without action
   */
  export type OrderDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Order
     */
    select?: OrderSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Order
     */
    omit?: OrderOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OrderInclude<ExtArgs> | null
  }


  /**
   * Model NotificationToken
   */

  export type AggregateNotificationToken = {
    _count: NotificationTokenCountAggregateOutputType | null
    _min: NotificationTokenMinAggregateOutputType | null
    _max: NotificationTokenMaxAggregateOutputType | null
  }

  export type NotificationTokenMinAggregateOutputType = {
    id: string | null
    userId: string | null
    fcmToken: string | null
    deviceType: string | null
    isActive: boolean | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type NotificationTokenMaxAggregateOutputType = {
    id: string | null
    userId: string | null
    fcmToken: string | null
    deviceType: string | null
    isActive: boolean | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type NotificationTokenCountAggregateOutputType = {
    id: number
    userId: number
    fcmToken: number
    deviceType: number
    isActive: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type NotificationTokenMinAggregateInputType = {
    id?: true
    userId?: true
    fcmToken?: true
    deviceType?: true
    isActive?: true
    createdAt?: true
    updatedAt?: true
  }

  export type NotificationTokenMaxAggregateInputType = {
    id?: true
    userId?: true
    fcmToken?: true
    deviceType?: true
    isActive?: true
    createdAt?: true
    updatedAt?: true
  }

  export type NotificationTokenCountAggregateInputType = {
    id?: true
    userId?: true
    fcmToken?: true
    deviceType?: true
    isActive?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type NotificationTokenAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which NotificationToken to aggregate.
     */
    where?: NotificationTokenWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of NotificationTokens to fetch.
     */
    orderBy?: NotificationTokenOrderByWithRelationInput | NotificationTokenOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: NotificationTokenWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` NotificationTokens from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` NotificationTokens.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned NotificationTokens
    **/
    _count?: true | NotificationTokenCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: NotificationTokenMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: NotificationTokenMaxAggregateInputType
  }

  export type GetNotificationTokenAggregateType<T extends NotificationTokenAggregateArgs> = {
        [P in keyof T & keyof AggregateNotificationToken]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateNotificationToken[P]>
      : GetScalarType<T[P], AggregateNotificationToken[P]>
  }




  export type NotificationTokenGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: NotificationTokenWhereInput
    orderBy?: NotificationTokenOrderByWithAggregationInput | NotificationTokenOrderByWithAggregationInput[]
    by: NotificationTokenScalarFieldEnum[] | NotificationTokenScalarFieldEnum
    having?: NotificationTokenScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: NotificationTokenCountAggregateInputType | true
    _min?: NotificationTokenMinAggregateInputType
    _max?: NotificationTokenMaxAggregateInputType
  }

  export type NotificationTokenGroupByOutputType = {
    id: string
    userId: string
    fcmToken: string
    deviceType: string | null
    isActive: boolean
    createdAt: Date
    updatedAt: Date
    _count: NotificationTokenCountAggregateOutputType | null
    _min: NotificationTokenMinAggregateOutputType | null
    _max: NotificationTokenMaxAggregateOutputType | null
  }

  type GetNotificationTokenGroupByPayload<T extends NotificationTokenGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<NotificationTokenGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof NotificationTokenGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], NotificationTokenGroupByOutputType[P]>
            : GetScalarType<T[P], NotificationTokenGroupByOutputType[P]>
        }
      >
    >


  export type NotificationTokenSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    fcmToken?: boolean
    deviceType?: boolean
    isActive?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["notificationToken"]>

  export type NotificationTokenSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    fcmToken?: boolean
    deviceType?: boolean
    isActive?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["notificationToken"]>

  export type NotificationTokenSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    fcmToken?: boolean
    deviceType?: boolean
    isActive?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["notificationToken"]>

  export type NotificationTokenSelectScalar = {
    id?: boolean
    userId?: boolean
    fcmToken?: boolean
    deviceType?: boolean
    isActive?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type NotificationTokenOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "userId" | "fcmToken" | "deviceType" | "isActive" | "createdAt" | "updatedAt", ExtArgs["result"]["notificationToken"]>
  export type NotificationTokenInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
  }
  export type NotificationTokenIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
  }
  export type NotificationTokenIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
  }

  export type $NotificationTokenPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "NotificationToken"
    objects: {
      user: Prisma.$UserPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      userId: string
      fcmToken: string
      deviceType: string | null
      isActive: boolean
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["notificationToken"]>
    composites: {}
  }

  type NotificationTokenGetPayload<S extends boolean | null | undefined | NotificationTokenDefaultArgs> = $Result.GetResult<Prisma.$NotificationTokenPayload, S>

  type NotificationTokenCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<NotificationTokenFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: NotificationTokenCountAggregateInputType | true
    }

  export interface NotificationTokenDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['NotificationToken'], meta: { name: 'NotificationToken' } }
    /**
     * Find zero or one NotificationToken that matches the filter.
     * @param {NotificationTokenFindUniqueArgs} args - Arguments to find a NotificationToken
     * @example
     * // Get one NotificationToken
     * const notificationToken = await prisma.notificationToken.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends NotificationTokenFindUniqueArgs>(args: SelectSubset<T, NotificationTokenFindUniqueArgs<ExtArgs>>): Prisma__NotificationTokenClient<$Result.GetResult<Prisma.$NotificationTokenPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one NotificationToken that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {NotificationTokenFindUniqueOrThrowArgs} args - Arguments to find a NotificationToken
     * @example
     * // Get one NotificationToken
     * const notificationToken = await prisma.notificationToken.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends NotificationTokenFindUniqueOrThrowArgs>(args: SelectSubset<T, NotificationTokenFindUniqueOrThrowArgs<ExtArgs>>): Prisma__NotificationTokenClient<$Result.GetResult<Prisma.$NotificationTokenPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first NotificationToken that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {NotificationTokenFindFirstArgs} args - Arguments to find a NotificationToken
     * @example
     * // Get one NotificationToken
     * const notificationToken = await prisma.notificationToken.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends NotificationTokenFindFirstArgs>(args?: SelectSubset<T, NotificationTokenFindFirstArgs<ExtArgs>>): Prisma__NotificationTokenClient<$Result.GetResult<Prisma.$NotificationTokenPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first NotificationToken that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {NotificationTokenFindFirstOrThrowArgs} args - Arguments to find a NotificationToken
     * @example
     * // Get one NotificationToken
     * const notificationToken = await prisma.notificationToken.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends NotificationTokenFindFirstOrThrowArgs>(args?: SelectSubset<T, NotificationTokenFindFirstOrThrowArgs<ExtArgs>>): Prisma__NotificationTokenClient<$Result.GetResult<Prisma.$NotificationTokenPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more NotificationTokens that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {NotificationTokenFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all NotificationTokens
     * const notificationTokens = await prisma.notificationToken.findMany()
     * 
     * // Get first 10 NotificationTokens
     * const notificationTokens = await prisma.notificationToken.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const notificationTokenWithIdOnly = await prisma.notificationToken.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends NotificationTokenFindManyArgs>(args?: SelectSubset<T, NotificationTokenFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$NotificationTokenPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a NotificationToken.
     * @param {NotificationTokenCreateArgs} args - Arguments to create a NotificationToken.
     * @example
     * // Create one NotificationToken
     * const NotificationToken = await prisma.notificationToken.create({
     *   data: {
     *     // ... data to create a NotificationToken
     *   }
     * })
     * 
     */
    create<T extends NotificationTokenCreateArgs>(args: SelectSubset<T, NotificationTokenCreateArgs<ExtArgs>>): Prisma__NotificationTokenClient<$Result.GetResult<Prisma.$NotificationTokenPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many NotificationTokens.
     * @param {NotificationTokenCreateManyArgs} args - Arguments to create many NotificationTokens.
     * @example
     * // Create many NotificationTokens
     * const notificationToken = await prisma.notificationToken.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends NotificationTokenCreateManyArgs>(args?: SelectSubset<T, NotificationTokenCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many NotificationTokens and returns the data saved in the database.
     * @param {NotificationTokenCreateManyAndReturnArgs} args - Arguments to create many NotificationTokens.
     * @example
     * // Create many NotificationTokens
     * const notificationToken = await prisma.notificationToken.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many NotificationTokens and only return the `id`
     * const notificationTokenWithIdOnly = await prisma.notificationToken.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends NotificationTokenCreateManyAndReturnArgs>(args?: SelectSubset<T, NotificationTokenCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$NotificationTokenPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a NotificationToken.
     * @param {NotificationTokenDeleteArgs} args - Arguments to delete one NotificationToken.
     * @example
     * // Delete one NotificationToken
     * const NotificationToken = await prisma.notificationToken.delete({
     *   where: {
     *     // ... filter to delete one NotificationToken
     *   }
     * })
     * 
     */
    delete<T extends NotificationTokenDeleteArgs>(args: SelectSubset<T, NotificationTokenDeleteArgs<ExtArgs>>): Prisma__NotificationTokenClient<$Result.GetResult<Prisma.$NotificationTokenPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one NotificationToken.
     * @param {NotificationTokenUpdateArgs} args - Arguments to update one NotificationToken.
     * @example
     * // Update one NotificationToken
     * const notificationToken = await prisma.notificationToken.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends NotificationTokenUpdateArgs>(args: SelectSubset<T, NotificationTokenUpdateArgs<ExtArgs>>): Prisma__NotificationTokenClient<$Result.GetResult<Prisma.$NotificationTokenPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more NotificationTokens.
     * @param {NotificationTokenDeleteManyArgs} args - Arguments to filter NotificationTokens to delete.
     * @example
     * // Delete a few NotificationTokens
     * const { count } = await prisma.notificationToken.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends NotificationTokenDeleteManyArgs>(args?: SelectSubset<T, NotificationTokenDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more NotificationTokens.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {NotificationTokenUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many NotificationTokens
     * const notificationToken = await prisma.notificationToken.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends NotificationTokenUpdateManyArgs>(args: SelectSubset<T, NotificationTokenUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more NotificationTokens and returns the data updated in the database.
     * @param {NotificationTokenUpdateManyAndReturnArgs} args - Arguments to update many NotificationTokens.
     * @example
     * // Update many NotificationTokens
     * const notificationToken = await prisma.notificationToken.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more NotificationTokens and only return the `id`
     * const notificationTokenWithIdOnly = await prisma.notificationToken.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends NotificationTokenUpdateManyAndReturnArgs>(args: SelectSubset<T, NotificationTokenUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$NotificationTokenPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one NotificationToken.
     * @param {NotificationTokenUpsertArgs} args - Arguments to update or create a NotificationToken.
     * @example
     * // Update or create a NotificationToken
     * const notificationToken = await prisma.notificationToken.upsert({
     *   create: {
     *     // ... data to create a NotificationToken
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the NotificationToken we want to update
     *   }
     * })
     */
    upsert<T extends NotificationTokenUpsertArgs>(args: SelectSubset<T, NotificationTokenUpsertArgs<ExtArgs>>): Prisma__NotificationTokenClient<$Result.GetResult<Prisma.$NotificationTokenPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of NotificationTokens.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {NotificationTokenCountArgs} args - Arguments to filter NotificationTokens to count.
     * @example
     * // Count the number of NotificationTokens
     * const count = await prisma.notificationToken.count({
     *   where: {
     *     // ... the filter for the NotificationTokens we want to count
     *   }
     * })
    **/
    count<T extends NotificationTokenCountArgs>(
      args?: Subset<T, NotificationTokenCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], NotificationTokenCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a NotificationToken.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {NotificationTokenAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends NotificationTokenAggregateArgs>(args: Subset<T, NotificationTokenAggregateArgs>): Prisma.PrismaPromise<GetNotificationTokenAggregateType<T>>

    /**
     * Group by NotificationToken.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {NotificationTokenGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends NotificationTokenGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: NotificationTokenGroupByArgs['orderBy'] }
        : { orderBy?: NotificationTokenGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, NotificationTokenGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetNotificationTokenGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the NotificationToken model
   */
  readonly fields: NotificationTokenFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for NotificationToken.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__NotificationTokenClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    user<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the NotificationToken model
   */
  interface NotificationTokenFieldRefs {
    readonly id: FieldRef<"NotificationToken", 'String'>
    readonly userId: FieldRef<"NotificationToken", 'String'>
    readonly fcmToken: FieldRef<"NotificationToken", 'String'>
    readonly deviceType: FieldRef<"NotificationToken", 'String'>
    readonly isActive: FieldRef<"NotificationToken", 'Boolean'>
    readonly createdAt: FieldRef<"NotificationToken", 'DateTime'>
    readonly updatedAt: FieldRef<"NotificationToken", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * NotificationToken findUnique
   */
  export type NotificationTokenFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the NotificationToken
     */
    select?: NotificationTokenSelect<ExtArgs> | null
    /**
     * Omit specific fields from the NotificationToken
     */
    omit?: NotificationTokenOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NotificationTokenInclude<ExtArgs> | null
    /**
     * Filter, which NotificationToken to fetch.
     */
    where: NotificationTokenWhereUniqueInput
  }

  /**
   * NotificationToken findUniqueOrThrow
   */
  export type NotificationTokenFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the NotificationToken
     */
    select?: NotificationTokenSelect<ExtArgs> | null
    /**
     * Omit specific fields from the NotificationToken
     */
    omit?: NotificationTokenOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NotificationTokenInclude<ExtArgs> | null
    /**
     * Filter, which NotificationToken to fetch.
     */
    where: NotificationTokenWhereUniqueInput
  }

  /**
   * NotificationToken findFirst
   */
  export type NotificationTokenFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the NotificationToken
     */
    select?: NotificationTokenSelect<ExtArgs> | null
    /**
     * Omit specific fields from the NotificationToken
     */
    omit?: NotificationTokenOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NotificationTokenInclude<ExtArgs> | null
    /**
     * Filter, which NotificationToken to fetch.
     */
    where?: NotificationTokenWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of NotificationTokens to fetch.
     */
    orderBy?: NotificationTokenOrderByWithRelationInput | NotificationTokenOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for NotificationTokens.
     */
    cursor?: NotificationTokenWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` NotificationTokens from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` NotificationTokens.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of NotificationTokens.
     */
    distinct?: NotificationTokenScalarFieldEnum | NotificationTokenScalarFieldEnum[]
  }

  /**
   * NotificationToken findFirstOrThrow
   */
  export type NotificationTokenFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the NotificationToken
     */
    select?: NotificationTokenSelect<ExtArgs> | null
    /**
     * Omit specific fields from the NotificationToken
     */
    omit?: NotificationTokenOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NotificationTokenInclude<ExtArgs> | null
    /**
     * Filter, which NotificationToken to fetch.
     */
    where?: NotificationTokenWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of NotificationTokens to fetch.
     */
    orderBy?: NotificationTokenOrderByWithRelationInput | NotificationTokenOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for NotificationTokens.
     */
    cursor?: NotificationTokenWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` NotificationTokens from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` NotificationTokens.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of NotificationTokens.
     */
    distinct?: NotificationTokenScalarFieldEnum | NotificationTokenScalarFieldEnum[]
  }

  /**
   * NotificationToken findMany
   */
  export type NotificationTokenFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the NotificationToken
     */
    select?: NotificationTokenSelect<ExtArgs> | null
    /**
     * Omit specific fields from the NotificationToken
     */
    omit?: NotificationTokenOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NotificationTokenInclude<ExtArgs> | null
    /**
     * Filter, which NotificationTokens to fetch.
     */
    where?: NotificationTokenWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of NotificationTokens to fetch.
     */
    orderBy?: NotificationTokenOrderByWithRelationInput | NotificationTokenOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing NotificationTokens.
     */
    cursor?: NotificationTokenWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` NotificationTokens from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` NotificationTokens.
     */
    skip?: number
    distinct?: NotificationTokenScalarFieldEnum | NotificationTokenScalarFieldEnum[]
  }

  /**
   * NotificationToken create
   */
  export type NotificationTokenCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the NotificationToken
     */
    select?: NotificationTokenSelect<ExtArgs> | null
    /**
     * Omit specific fields from the NotificationToken
     */
    omit?: NotificationTokenOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NotificationTokenInclude<ExtArgs> | null
    /**
     * The data needed to create a NotificationToken.
     */
    data: XOR<NotificationTokenCreateInput, NotificationTokenUncheckedCreateInput>
  }

  /**
   * NotificationToken createMany
   */
  export type NotificationTokenCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many NotificationTokens.
     */
    data: NotificationTokenCreateManyInput | NotificationTokenCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * NotificationToken createManyAndReturn
   */
  export type NotificationTokenCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the NotificationToken
     */
    select?: NotificationTokenSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the NotificationToken
     */
    omit?: NotificationTokenOmit<ExtArgs> | null
    /**
     * The data used to create many NotificationTokens.
     */
    data: NotificationTokenCreateManyInput | NotificationTokenCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NotificationTokenIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * NotificationToken update
   */
  export type NotificationTokenUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the NotificationToken
     */
    select?: NotificationTokenSelect<ExtArgs> | null
    /**
     * Omit specific fields from the NotificationToken
     */
    omit?: NotificationTokenOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NotificationTokenInclude<ExtArgs> | null
    /**
     * The data needed to update a NotificationToken.
     */
    data: XOR<NotificationTokenUpdateInput, NotificationTokenUncheckedUpdateInput>
    /**
     * Choose, which NotificationToken to update.
     */
    where: NotificationTokenWhereUniqueInput
  }

  /**
   * NotificationToken updateMany
   */
  export type NotificationTokenUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update NotificationTokens.
     */
    data: XOR<NotificationTokenUpdateManyMutationInput, NotificationTokenUncheckedUpdateManyInput>
    /**
     * Filter which NotificationTokens to update
     */
    where?: NotificationTokenWhereInput
    /**
     * Limit how many NotificationTokens to update.
     */
    limit?: number
  }

  /**
   * NotificationToken updateManyAndReturn
   */
  export type NotificationTokenUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the NotificationToken
     */
    select?: NotificationTokenSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the NotificationToken
     */
    omit?: NotificationTokenOmit<ExtArgs> | null
    /**
     * The data used to update NotificationTokens.
     */
    data: XOR<NotificationTokenUpdateManyMutationInput, NotificationTokenUncheckedUpdateManyInput>
    /**
     * Filter which NotificationTokens to update
     */
    where?: NotificationTokenWhereInput
    /**
     * Limit how many NotificationTokens to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NotificationTokenIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * NotificationToken upsert
   */
  export type NotificationTokenUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the NotificationToken
     */
    select?: NotificationTokenSelect<ExtArgs> | null
    /**
     * Omit specific fields from the NotificationToken
     */
    omit?: NotificationTokenOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NotificationTokenInclude<ExtArgs> | null
    /**
     * The filter to search for the NotificationToken to update in case it exists.
     */
    where: NotificationTokenWhereUniqueInput
    /**
     * In case the NotificationToken found by the `where` argument doesn't exist, create a new NotificationToken with this data.
     */
    create: XOR<NotificationTokenCreateInput, NotificationTokenUncheckedCreateInput>
    /**
     * In case the NotificationToken was found with the provided `where` argument, update it with this data.
     */
    update: XOR<NotificationTokenUpdateInput, NotificationTokenUncheckedUpdateInput>
  }

  /**
   * NotificationToken delete
   */
  export type NotificationTokenDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the NotificationToken
     */
    select?: NotificationTokenSelect<ExtArgs> | null
    /**
     * Omit specific fields from the NotificationToken
     */
    omit?: NotificationTokenOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NotificationTokenInclude<ExtArgs> | null
    /**
     * Filter which NotificationToken to delete.
     */
    where: NotificationTokenWhereUniqueInput
  }

  /**
   * NotificationToken deleteMany
   */
  export type NotificationTokenDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which NotificationTokens to delete
     */
    where?: NotificationTokenWhereInput
    /**
     * Limit how many NotificationTokens to delete.
     */
    limit?: number
  }

  /**
   * NotificationToken without action
   */
  export type NotificationTokenDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the NotificationToken
     */
    select?: NotificationTokenSelect<ExtArgs> | null
    /**
     * Omit specific fields from the NotificationToken
     */
    omit?: NotificationTokenOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NotificationTokenInclude<ExtArgs> | null
  }


  /**
   * Model SupportTicket
   */

  export type AggregateSupportTicket = {
    _count: SupportTicketCountAggregateOutputType | null
    _min: SupportTicketMinAggregateOutputType | null
    _max: SupportTicketMaxAggregateOutputType | null
  }

  export type SupportTicketMinAggregateOutputType = {
    id: string | null
    orderId: string | null
    agentId: string | null
    partnerId: string | null
    userId: string | null
    issueType: string | null
    description: string | null
    status: $Enums.TicketStatus | null
    resolvedAt: Date | null
    adminNotes: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type SupportTicketMaxAggregateOutputType = {
    id: string | null
    orderId: string | null
    agentId: string | null
    partnerId: string | null
    userId: string | null
    issueType: string | null
    description: string | null
    status: $Enums.TicketStatus | null
    resolvedAt: Date | null
    adminNotes: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type SupportTicketCountAggregateOutputType = {
    id: number
    orderId: number
    agentId: number
    partnerId: number
    userId: number
    issueType: number
    description: number
    status: number
    resolvedAt: number
    adminNotes: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type SupportTicketMinAggregateInputType = {
    id?: true
    orderId?: true
    agentId?: true
    partnerId?: true
    userId?: true
    issueType?: true
    description?: true
    status?: true
    resolvedAt?: true
    adminNotes?: true
    createdAt?: true
    updatedAt?: true
  }

  export type SupportTicketMaxAggregateInputType = {
    id?: true
    orderId?: true
    agentId?: true
    partnerId?: true
    userId?: true
    issueType?: true
    description?: true
    status?: true
    resolvedAt?: true
    adminNotes?: true
    createdAt?: true
    updatedAt?: true
  }

  export type SupportTicketCountAggregateInputType = {
    id?: true
    orderId?: true
    agentId?: true
    partnerId?: true
    userId?: true
    issueType?: true
    description?: true
    status?: true
    resolvedAt?: true
    adminNotes?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type SupportTicketAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which SupportTicket to aggregate.
     */
    where?: SupportTicketWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of SupportTickets to fetch.
     */
    orderBy?: SupportTicketOrderByWithRelationInput | SupportTicketOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: SupportTicketWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` SupportTickets from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` SupportTickets.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned SupportTickets
    **/
    _count?: true | SupportTicketCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: SupportTicketMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: SupportTicketMaxAggregateInputType
  }

  export type GetSupportTicketAggregateType<T extends SupportTicketAggregateArgs> = {
        [P in keyof T & keyof AggregateSupportTicket]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateSupportTicket[P]>
      : GetScalarType<T[P], AggregateSupportTicket[P]>
  }




  export type SupportTicketGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: SupportTicketWhereInput
    orderBy?: SupportTicketOrderByWithAggregationInput | SupportTicketOrderByWithAggregationInput[]
    by: SupportTicketScalarFieldEnum[] | SupportTicketScalarFieldEnum
    having?: SupportTicketScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: SupportTicketCountAggregateInputType | true
    _min?: SupportTicketMinAggregateInputType
    _max?: SupportTicketMaxAggregateInputType
  }

  export type SupportTicketGroupByOutputType = {
    id: string
    orderId: string | null
    agentId: string | null
    partnerId: string | null
    userId: string
    issueType: string
    description: string
    status: $Enums.TicketStatus
    resolvedAt: Date | null
    adminNotes: string | null
    createdAt: Date
    updatedAt: Date
    _count: SupportTicketCountAggregateOutputType | null
    _min: SupportTicketMinAggregateOutputType | null
    _max: SupportTicketMaxAggregateOutputType | null
  }

  type GetSupportTicketGroupByPayload<T extends SupportTicketGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<SupportTicketGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof SupportTicketGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], SupportTicketGroupByOutputType[P]>
            : GetScalarType<T[P], SupportTicketGroupByOutputType[P]>
        }
      >
    >


  export type SupportTicketSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    orderId?: boolean
    agentId?: boolean
    partnerId?: boolean
    userId?: boolean
    issueType?: boolean
    description?: boolean
    status?: boolean
    resolvedAt?: boolean
    adminNotes?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    order?: boolean | SupportTicket$orderArgs<ExtArgs>
    agent?: boolean | SupportTicket$agentArgs<ExtArgs>
    partner?: boolean | SupportTicket$partnerArgs<ExtArgs>
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["supportTicket"]>

  export type SupportTicketSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    orderId?: boolean
    agentId?: boolean
    partnerId?: boolean
    userId?: boolean
    issueType?: boolean
    description?: boolean
    status?: boolean
    resolvedAt?: boolean
    adminNotes?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    order?: boolean | SupportTicket$orderArgs<ExtArgs>
    agent?: boolean | SupportTicket$agentArgs<ExtArgs>
    partner?: boolean | SupportTicket$partnerArgs<ExtArgs>
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["supportTicket"]>

  export type SupportTicketSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    orderId?: boolean
    agentId?: boolean
    partnerId?: boolean
    userId?: boolean
    issueType?: boolean
    description?: boolean
    status?: boolean
    resolvedAt?: boolean
    adminNotes?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    order?: boolean | SupportTicket$orderArgs<ExtArgs>
    agent?: boolean | SupportTicket$agentArgs<ExtArgs>
    partner?: boolean | SupportTicket$partnerArgs<ExtArgs>
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["supportTicket"]>

  export type SupportTicketSelectScalar = {
    id?: boolean
    orderId?: boolean
    agentId?: boolean
    partnerId?: boolean
    userId?: boolean
    issueType?: boolean
    description?: boolean
    status?: boolean
    resolvedAt?: boolean
    adminNotes?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type SupportTicketOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "orderId" | "agentId" | "partnerId" | "userId" | "issueType" | "description" | "status" | "resolvedAt" | "adminNotes" | "createdAt" | "updatedAt", ExtArgs["result"]["supportTicket"]>
  export type SupportTicketInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    order?: boolean | SupportTicket$orderArgs<ExtArgs>
    agent?: boolean | SupportTicket$agentArgs<ExtArgs>
    partner?: boolean | SupportTicket$partnerArgs<ExtArgs>
    user?: boolean | UserDefaultArgs<ExtArgs>
  }
  export type SupportTicketIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    order?: boolean | SupportTicket$orderArgs<ExtArgs>
    agent?: boolean | SupportTicket$agentArgs<ExtArgs>
    partner?: boolean | SupportTicket$partnerArgs<ExtArgs>
    user?: boolean | UserDefaultArgs<ExtArgs>
  }
  export type SupportTicketIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    order?: boolean | SupportTicket$orderArgs<ExtArgs>
    agent?: boolean | SupportTicket$agentArgs<ExtArgs>
    partner?: boolean | SupportTicket$partnerArgs<ExtArgs>
    user?: boolean | UserDefaultArgs<ExtArgs>
  }

  export type $SupportTicketPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "SupportTicket"
    objects: {
      order: Prisma.$OrderPayload<ExtArgs> | null
      agent: Prisma.$AgentPayload<ExtArgs> | null
      partner: Prisma.$PartnerPayload<ExtArgs> | null
      user: Prisma.$UserPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      orderId: string | null
      agentId: string | null
      partnerId: string | null
      userId: string
      issueType: string
      description: string
      status: $Enums.TicketStatus
      resolvedAt: Date | null
      adminNotes: string | null
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["supportTicket"]>
    composites: {}
  }

  type SupportTicketGetPayload<S extends boolean | null | undefined | SupportTicketDefaultArgs> = $Result.GetResult<Prisma.$SupportTicketPayload, S>

  type SupportTicketCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<SupportTicketFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: SupportTicketCountAggregateInputType | true
    }

  export interface SupportTicketDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['SupportTicket'], meta: { name: 'SupportTicket' } }
    /**
     * Find zero or one SupportTicket that matches the filter.
     * @param {SupportTicketFindUniqueArgs} args - Arguments to find a SupportTicket
     * @example
     * // Get one SupportTicket
     * const supportTicket = await prisma.supportTicket.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends SupportTicketFindUniqueArgs>(args: SelectSubset<T, SupportTicketFindUniqueArgs<ExtArgs>>): Prisma__SupportTicketClient<$Result.GetResult<Prisma.$SupportTicketPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one SupportTicket that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {SupportTicketFindUniqueOrThrowArgs} args - Arguments to find a SupportTicket
     * @example
     * // Get one SupportTicket
     * const supportTicket = await prisma.supportTicket.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends SupportTicketFindUniqueOrThrowArgs>(args: SelectSubset<T, SupportTicketFindUniqueOrThrowArgs<ExtArgs>>): Prisma__SupportTicketClient<$Result.GetResult<Prisma.$SupportTicketPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first SupportTicket that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SupportTicketFindFirstArgs} args - Arguments to find a SupportTicket
     * @example
     * // Get one SupportTicket
     * const supportTicket = await prisma.supportTicket.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends SupportTicketFindFirstArgs>(args?: SelectSubset<T, SupportTicketFindFirstArgs<ExtArgs>>): Prisma__SupportTicketClient<$Result.GetResult<Prisma.$SupportTicketPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first SupportTicket that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SupportTicketFindFirstOrThrowArgs} args - Arguments to find a SupportTicket
     * @example
     * // Get one SupportTicket
     * const supportTicket = await prisma.supportTicket.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends SupportTicketFindFirstOrThrowArgs>(args?: SelectSubset<T, SupportTicketFindFirstOrThrowArgs<ExtArgs>>): Prisma__SupportTicketClient<$Result.GetResult<Prisma.$SupportTicketPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more SupportTickets that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SupportTicketFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all SupportTickets
     * const supportTickets = await prisma.supportTicket.findMany()
     * 
     * // Get first 10 SupportTickets
     * const supportTickets = await prisma.supportTicket.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const supportTicketWithIdOnly = await prisma.supportTicket.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends SupportTicketFindManyArgs>(args?: SelectSubset<T, SupportTicketFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SupportTicketPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a SupportTicket.
     * @param {SupportTicketCreateArgs} args - Arguments to create a SupportTicket.
     * @example
     * // Create one SupportTicket
     * const SupportTicket = await prisma.supportTicket.create({
     *   data: {
     *     // ... data to create a SupportTicket
     *   }
     * })
     * 
     */
    create<T extends SupportTicketCreateArgs>(args: SelectSubset<T, SupportTicketCreateArgs<ExtArgs>>): Prisma__SupportTicketClient<$Result.GetResult<Prisma.$SupportTicketPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many SupportTickets.
     * @param {SupportTicketCreateManyArgs} args - Arguments to create many SupportTickets.
     * @example
     * // Create many SupportTickets
     * const supportTicket = await prisma.supportTicket.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends SupportTicketCreateManyArgs>(args?: SelectSubset<T, SupportTicketCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many SupportTickets and returns the data saved in the database.
     * @param {SupportTicketCreateManyAndReturnArgs} args - Arguments to create many SupportTickets.
     * @example
     * // Create many SupportTickets
     * const supportTicket = await prisma.supportTicket.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many SupportTickets and only return the `id`
     * const supportTicketWithIdOnly = await prisma.supportTicket.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends SupportTicketCreateManyAndReturnArgs>(args?: SelectSubset<T, SupportTicketCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SupportTicketPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a SupportTicket.
     * @param {SupportTicketDeleteArgs} args - Arguments to delete one SupportTicket.
     * @example
     * // Delete one SupportTicket
     * const SupportTicket = await prisma.supportTicket.delete({
     *   where: {
     *     // ... filter to delete one SupportTicket
     *   }
     * })
     * 
     */
    delete<T extends SupportTicketDeleteArgs>(args: SelectSubset<T, SupportTicketDeleteArgs<ExtArgs>>): Prisma__SupportTicketClient<$Result.GetResult<Prisma.$SupportTicketPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one SupportTicket.
     * @param {SupportTicketUpdateArgs} args - Arguments to update one SupportTicket.
     * @example
     * // Update one SupportTicket
     * const supportTicket = await prisma.supportTicket.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends SupportTicketUpdateArgs>(args: SelectSubset<T, SupportTicketUpdateArgs<ExtArgs>>): Prisma__SupportTicketClient<$Result.GetResult<Prisma.$SupportTicketPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more SupportTickets.
     * @param {SupportTicketDeleteManyArgs} args - Arguments to filter SupportTickets to delete.
     * @example
     * // Delete a few SupportTickets
     * const { count } = await prisma.supportTicket.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends SupportTicketDeleteManyArgs>(args?: SelectSubset<T, SupportTicketDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more SupportTickets.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SupportTicketUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many SupportTickets
     * const supportTicket = await prisma.supportTicket.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends SupportTicketUpdateManyArgs>(args: SelectSubset<T, SupportTicketUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more SupportTickets and returns the data updated in the database.
     * @param {SupportTicketUpdateManyAndReturnArgs} args - Arguments to update many SupportTickets.
     * @example
     * // Update many SupportTickets
     * const supportTicket = await prisma.supportTicket.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more SupportTickets and only return the `id`
     * const supportTicketWithIdOnly = await prisma.supportTicket.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends SupportTicketUpdateManyAndReturnArgs>(args: SelectSubset<T, SupportTicketUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SupportTicketPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one SupportTicket.
     * @param {SupportTicketUpsertArgs} args - Arguments to update or create a SupportTicket.
     * @example
     * // Update or create a SupportTicket
     * const supportTicket = await prisma.supportTicket.upsert({
     *   create: {
     *     // ... data to create a SupportTicket
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the SupportTicket we want to update
     *   }
     * })
     */
    upsert<T extends SupportTicketUpsertArgs>(args: SelectSubset<T, SupportTicketUpsertArgs<ExtArgs>>): Prisma__SupportTicketClient<$Result.GetResult<Prisma.$SupportTicketPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of SupportTickets.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SupportTicketCountArgs} args - Arguments to filter SupportTickets to count.
     * @example
     * // Count the number of SupportTickets
     * const count = await prisma.supportTicket.count({
     *   where: {
     *     // ... the filter for the SupportTickets we want to count
     *   }
     * })
    **/
    count<T extends SupportTicketCountArgs>(
      args?: Subset<T, SupportTicketCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], SupportTicketCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a SupportTicket.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SupportTicketAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends SupportTicketAggregateArgs>(args: Subset<T, SupportTicketAggregateArgs>): Prisma.PrismaPromise<GetSupportTicketAggregateType<T>>

    /**
     * Group by SupportTicket.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SupportTicketGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends SupportTicketGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: SupportTicketGroupByArgs['orderBy'] }
        : { orderBy?: SupportTicketGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, SupportTicketGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetSupportTicketGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the SupportTicket model
   */
  readonly fields: SupportTicketFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for SupportTicket.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__SupportTicketClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    order<T extends SupportTicket$orderArgs<ExtArgs> = {}>(args?: Subset<T, SupportTicket$orderArgs<ExtArgs>>): Prisma__OrderClient<$Result.GetResult<Prisma.$OrderPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    agent<T extends SupportTicket$agentArgs<ExtArgs> = {}>(args?: Subset<T, SupportTicket$agentArgs<ExtArgs>>): Prisma__AgentClient<$Result.GetResult<Prisma.$AgentPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    partner<T extends SupportTicket$partnerArgs<ExtArgs> = {}>(args?: Subset<T, SupportTicket$partnerArgs<ExtArgs>>): Prisma__PartnerClient<$Result.GetResult<Prisma.$PartnerPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    user<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the SupportTicket model
   */
  interface SupportTicketFieldRefs {
    readonly id: FieldRef<"SupportTicket", 'String'>
    readonly orderId: FieldRef<"SupportTicket", 'String'>
    readonly agentId: FieldRef<"SupportTicket", 'String'>
    readonly partnerId: FieldRef<"SupportTicket", 'String'>
    readonly userId: FieldRef<"SupportTicket", 'String'>
    readonly issueType: FieldRef<"SupportTicket", 'String'>
    readonly description: FieldRef<"SupportTicket", 'String'>
    readonly status: FieldRef<"SupportTicket", 'TicketStatus'>
    readonly resolvedAt: FieldRef<"SupportTicket", 'DateTime'>
    readonly adminNotes: FieldRef<"SupportTicket", 'String'>
    readonly createdAt: FieldRef<"SupportTicket", 'DateTime'>
    readonly updatedAt: FieldRef<"SupportTicket", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * SupportTicket findUnique
   */
  export type SupportTicketFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SupportTicket
     */
    select?: SupportTicketSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SupportTicket
     */
    omit?: SupportTicketOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SupportTicketInclude<ExtArgs> | null
    /**
     * Filter, which SupportTicket to fetch.
     */
    where: SupportTicketWhereUniqueInput
  }

  /**
   * SupportTicket findUniqueOrThrow
   */
  export type SupportTicketFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SupportTicket
     */
    select?: SupportTicketSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SupportTicket
     */
    omit?: SupportTicketOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SupportTicketInclude<ExtArgs> | null
    /**
     * Filter, which SupportTicket to fetch.
     */
    where: SupportTicketWhereUniqueInput
  }

  /**
   * SupportTicket findFirst
   */
  export type SupportTicketFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SupportTicket
     */
    select?: SupportTicketSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SupportTicket
     */
    omit?: SupportTicketOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SupportTicketInclude<ExtArgs> | null
    /**
     * Filter, which SupportTicket to fetch.
     */
    where?: SupportTicketWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of SupportTickets to fetch.
     */
    orderBy?: SupportTicketOrderByWithRelationInput | SupportTicketOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for SupportTickets.
     */
    cursor?: SupportTicketWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` SupportTickets from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` SupportTickets.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of SupportTickets.
     */
    distinct?: SupportTicketScalarFieldEnum | SupportTicketScalarFieldEnum[]
  }

  /**
   * SupportTicket findFirstOrThrow
   */
  export type SupportTicketFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SupportTicket
     */
    select?: SupportTicketSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SupportTicket
     */
    omit?: SupportTicketOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SupportTicketInclude<ExtArgs> | null
    /**
     * Filter, which SupportTicket to fetch.
     */
    where?: SupportTicketWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of SupportTickets to fetch.
     */
    orderBy?: SupportTicketOrderByWithRelationInput | SupportTicketOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for SupportTickets.
     */
    cursor?: SupportTicketWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` SupportTickets from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` SupportTickets.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of SupportTickets.
     */
    distinct?: SupportTicketScalarFieldEnum | SupportTicketScalarFieldEnum[]
  }

  /**
   * SupportTicket findMany
   */
  export type SupportTicketFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SupportTicket
     */
    select?: SupportTicketSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SupportTicket
     */
    omit?: SupportTicketOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SupportTicketInclude<ExtArgs> | null
    /**
     * Filter, which SupportTickets to fetch.
     */
    where?: SupportTicketWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of SupportTickets to fetch.
     */
    orderBy?: SupportTicketOrderByWithRelationInput | SupportTicketOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing SupportTickets.
     */
    cursor?: SupportTicketWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` SupportTickets from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` SupportTickets.
     */
    skip?: number
    distinct?: SupportTicketScalarFieldEnum | SupportTicketScalarFieldEnum[]
  }

  /**
   * SupportTicket create
   */
  export type SupportTicketCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SupportTicket
     */
    select?: SupportTicketSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SupportTicket
     */
    omit?: SupportTicketOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SupportTicketInclude<ExtArgs> | null
    /**
     * The data needed to create a SupportTicket.
     */
    data: XOR<SupportTicketCreateInput, SupportTicketUncheckedCreateInput>
  }

  /**
   * SupportTicket createMany
   */
  export type SupportTicketCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many SupportTickets.
     */
    data: SupportTicketCreateManyInput | SupportTicketCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * SupportTicket createManyAndReturn
   */
  export type SupportTicketCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SupportTicket
     */
    select?: SupportTicketSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the SupportTicket
     */
    omit?: SupportTicketOmit<ExtArgs> | null
    /**
     * The data used to create many SupportTickets.
     */
    data: SupportTicketCreateManyInput | SupportTicketCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SupportTicketIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * SupportTicket update
   */
  export type SupportTicketUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SupportTicket
     */
    select?: SupportTicketSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SupportTicket
     */
    omit?: SupportTicketOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SupportTicketInclude<ExtArgs> | null
    /**
     * The data needed to update a SupportTicket.
     */
    data: XOR<SupportTicketUpdateInput, SupportTicketUncheckedUpdateInput>
    /**
     * Choose, which SupportTicket to update.
     */
    where: SupportTicketWhereUniqueInput
  }

  /**
   * SupportTicket updateMany
   */
  export type SupportTicketUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update SupportTickets.
     */
    data: XOR<SupportTicketUpdateManyMutationInput, SupportTicketUncheckedUpdateManyInput>
    /**
     * Filter which SupportTickets to update
     */
    where?: SupportTicketWhereInput
    /**
     * Limit how many SupportTickets to update.
     */
    limit?: number
  }

  /**
   * SupportTicket updateManyAndReturn
   */
  export type SupportTicketUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SupportTicket
     */
    select?: SupportTicketSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the SupportTicket
     */
    omit?: SupportTicketOmit<ExtArgs> | null
    /**
     * The data used to update SupportTickets.
     */
    data: XOR<SupportTicketUpdateManyMutationInput, SupportTicketUncheckedUpdateManyInput>
    /**
     * Filter which SupportTickets to update
     */
    where?: SupportTicketWhereInput
    /**
     * Limit how many SupportTickets to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SupportTicketIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * SupportTicket upsert
   */
  export type SupportTicketUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SupportTicket
     */
    select?: SupportTicketSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SupportTicket
     */
    omit?: SupportTicketOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SupportTicketInclude<ExtArgs> | null
    /**
     * The filter to search for the SupportTicket to update in case it exists.
     */
    where: SupportTicketWhereUniqueInput
    /**
     * In case the SupportTicket found by the `where` argument doesn't exist, create a new SupportTicket with this data.
     */
    create: XOR<SupportTicketCreateInput, SupportTicketUncheckedCreateInput>
    /**
     * In case the SupportTicket was found with the provided `where` argument, update it with this data.
     */
    update: XOR<SupportTicketUpdateInput, SupportTicketUncheckedUpdateInput>
  }

  /**
   * SupportTicket delete
   */
  export type SupportTicketDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SupportTicket
     */
    select?: SupportTicketSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SupportTicket
     */
    omit?: SupportTicketOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SupportTicketInclude<ExtArgs> | null
    /**
     * Filter which SupportTicket to delete.
     */
    where: SupportTicketWhereUniqueInput
  }

  /**
   * SupportTicket deleteMany
   */
  export type SupportTicketDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which SupportTickets to delete
     */
    where?: SupportTicketWhereInput
    /**
     * Limit how many SupportTickets to delete.
     */
    limit?: number
  }

  /**
   * SupportTicket.order
   */
  export type SupportTicket$orderArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Order
     */
    select?: OrderSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Order
     */
    omit?: OrderOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OrderInclude<ExtArgs> | null
    where?: OrderWhereInput
  }

  /**
   * SupportTicket.agent
   */
  export type SupportTicket$agentArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Agent
     */
    select?: AgentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Agent
     */
    omit?: AgentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AgentInclude<ExtArgs> | null
    where?: AgentWhereInput
  }

  /**
   * SupportTicket.partner
   */
  export type SupportTicket$partnerArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Partner
     */
    select?: PartnerSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Partner
     */
    omit?: PartnerOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PartnerInclude<ExtArgs> | null
    where?: PartnerWhereInput
  }

  /**
   * SupportTicket without action
   */
  export type SupportTicketDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SupportTicket
     */
    select?: SupportTicketSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SupportTicket
     */
    omit?: SupportTicketOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SupportTicketInclude<ExtArgs> | null
  }


  /**
   * Model AppEvent
   */

  export type AggregateAppEvent = {
    _count: AppEventCountAggregateOutputType | null
    _min: AppEventMinAggregateOutputType | null
    _max: AppEventMaxAggregateOutputType | null
  }

  export type AppEventMinAggregateOutputType = {
    id: string | null
    userId: string | null
    actorType: $Enums.ActorType | null
    eventType: $Enums.EventType | null
    entityType: string | null
    entityId: string | null
    createdAt: Date | null
  }

  export type AppEventMaxAggregateOutputType = {
    id: string | null
    userId: string | null
    actorType: $Enums.ActorType | null
    eventType: $Enums.EventType | null
    entityType: string | null
    entityId: string | null
    createdAt: Date | null
  }

  export type AppEventCountAggregateOutputType = {
    id: number
    userId: number
    actorType: number
    eventType: number
    entityType: number
    entityId: number
    metadata: number
    createdAt: number
    _all: number
  }


  export type AppEventMinAggregateInputType = {
    id?: true
    userId?: true
    actorType?: true
    eventType?: true
    entityType?: true
    entityId?: true
    createdAt?: true
  }

  export type AppEventMaxAggregateInputType = {
    id?: true
    userId?: true
    actorType?: true
    eventType?: true
    entityType?: true
    entityId?: true
    createdAt?: true
  }

  export type AppEventCountAggregateInputType = {
    id?: true
    userId?: true
    actorType?: true
    eventType?: true
    entityType?: true
    entityId?: true
    metadata?: true
    createdAt?: true
    _all?: true
  }

  export type AppEventAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which AppEvent to aggregate.
     */
    where?: AppEventWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of AppEvents to fetch.
     */
    orderBy?: AppEventOrderByWithRelationInput | AppEventOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: AppEventWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` AppEvents from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` AppEvents.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned AppEvents
    **/
    _count?: true | AppEventCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: AppEventMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: AppEventMaxAggregateInputType
  }

  export type GetAppEventAggregateType<T extends AppEventAggregateArgs> = {
        [P in keyof T & keyof AggregateAppEvent]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateAppEvent[P]>
      : GetScalarType<T[P], AggregateAppEvent[P]>
  }




  export type AppEventGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: AppEventWhereInput
    orderBy?: AppEventOrderByWithAggregationInput | AppEventOrderByWithAggregationInput[]
    by: AppEventScalarFieldEnum[] | AppEventScalarFieldEnum
    having?: AppEventScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: AppEventCountAggregateInputType | true
    _min?: AppEventMinAggregateInputType
    _max?: AppEventMaxAggregateInputType
  }

  export type AppEventGroupByOutputType = {
    id: string
    userId: string | null
    actorType: $Enums.ActorType
    eventType: $Enums.EventType
    entityType: string | null
    entityId: string | null
    metadata: JsonValue | null
    createdAt: Date
    _count: AppEventCountAggregateOutputType | null
    _min: AppEventMinAggregateOutputType | null
    _max: AppEventMaxAggregateOutputType | null
  }

  type GetAppEventGroupByPayload<T extends AppEventGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<AppEventGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof AppEventGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], AppEventGroupByOutputType[P]>
            : GetScalarType<T[P], AppEventGroupByOutputType[P]>
        }
      >
    >


  export type AppEventSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    actorType?: boolean
    eventType?: boolean
    entityType?: boolean
    entityId?: boolean
    metadata?: boolean
    createdAt?: boolean
  }, ExtArgs["result"]["appEvent"]>

  export type AppEventSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    actorType?: boolean
    eventType?: boolean
    entityType?: boolean
    entityId?: boolean
    metadata?: boolean
    createdAt?: boolean
  }, ExtArgs["result"]["appEvent"]>

  export type AppEventSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    actorType?: boolean
    eventType?: boolean
    entityType?: boolean
    entityId?: boolean
    metadata?: boolean
    createdAt?: boolean
  }, ExtArgs["result"]["appEvent"]>

  export type AppEventSelectScalar = {
    id?: boolean
    userId?: boolean
    actorType?: boolean
    eventType?: boolean
    entityType?: boolean
    entityId?: boolean
    metadata?: boolean
    createdAt?: boolean
  }

  export type AppEventOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "userId" | "actorType" | "eventType" | "entityType" | "entityId" | "metadata" | "createdAt", ExtArgs["result"]["appEvent"]>

  export type $AppEventPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "AppEvent"
    objects: {}
    scalars: $Extensions.GetPayloadResult<{
      id: string
      userId: string | null
      actorType: $Enums.ActorType
      eventType: $Enums.EventType
      entityType: string | null
      entityId: string | null
      metadata: Prisma.JsonValue | null
      createdAt: Date
    }, ExtArgs["result"]["appEvent"]>
    composites: {}
  }

  type AppEventGetPayload<S extends boolean | null | undefined | AppEventDefaultArgs> = $Result.GetResult<Prisma.$AppEventPayload, S>

  type AppEventCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<AppEventFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: AppEventCountAggregateInputType | true
    }

  export interface AppEventDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['AppEvent'], meta: { name: 'AppEvent' } }
    /**
     * Find zero or one AppEvent that matches the filter.
     * @param {AppEventFindUniqueArgs} args - Arguments to find a AppEvent
     * @example
     * // Get one AppEvent
     * const appEvent = await prisma.appEvent.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends AppEventFindUniqueArgs>(args: SelectSubset<T, AppEventFindUniqueArgs<ExtArgs>>): Prisma__AppEventClient<$Result.GetResult<Prisma.$AppEventPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one AppEvent that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {AppEventFindUniqueOrThrowArgs} args - Arguments to find a AppEvent
     * @example
     * // Get one AppEvent
     * const appEvent = await prisma.appEvent.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends AppEventFindUniqueOrThrowArgs>(args: SelectSubset<T, AppEventFindUniqueOrThrowArgs<ExtArgs>>): Prisma__AppEventClient<$Result.GetResult<Prisma.$AppEventPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first AppEvent that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AppEventFindFirstArgs} args - Arguments to find a AppEvent
     * @example
     * // Get one AppEvent
     * const appEvent = await prisma.appEvent.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends AppEventFindFirstArgs>(args?: SelectSubset<T, AppEventFindFirstArgs<ExtArgs>>): Prisma__AppEventClient<$Result.GetResult<Prisma.$AppEventPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first AppEvent that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AppEventFindFirstOrThrowArgs} args - Arguments to find a AppEvent
     * @example
     * // Get one AppEvent
     * const appEvent = await prisma.appEvent.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends AppEventFindFirstOrThrowArgs>(args?: SelectSubset<T, AppEventFindFirstOrThrowArgs<ExtArgs>>): Prisma__AppEventClient<$Result.GetResult<Prisma.$AppEventPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more AppEvents that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AppEventFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all AppEvents
     * const appEvents = await prisma.appEvent.findMany()
     * 
     * // Get first 10 AppEvents
     * const appEvents = await prisma.appEvent.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const appEventWithIdOnly = await prisma.appEvent.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends AppEventFindManyArgs>(args?: SelectSubset<T, AppEventFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AppEventPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a AppEvent.
     * @param {AppEventCreateArgs} args - Arguments to create a AppEvent.
     * @example
     * // Create one AppEvent
     * const AppEvent = await prisma.appEvent.create({
     *   data: {
     *     // ... data to create a AppEvent
     *   }
     * })
     * 
     */
    create<T extends AppEventCreateArgs>(args: SelectSubset<T, AppEventCreateArgs<ExtArgs>>): Prisma__AppEventClient<$Result.GetResult<Prisma.$AppEventPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many AppEvents.
     * @param {AppEventCreateManyArgs} args - Arguments to create many AppEvents.
     * @example
     * // Create many AppEvents
     * const appEvent = await prisma.appEvent.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends AppEventCreateManyArgs>(args?: SelectSubset<T, AppEventCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many AppEvents and returns the data saved in the database.
     * @param {AppEventCreateManyAndReturnArgs} args - Arguments to create many AppEvents.
     * @example
     * // Create many AppEvents
     * const appEvent = await prisma.appEvent.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many AppEvents and only return the `id`
     * const appEventWithIdOnly = await prisma.appEvent.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends AppEventCreateManyAndReturnArgs>(args?: SelectSubset<T, AppEventCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AppEventPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a AppEvent.
     * @param {AppEventDeleteArgs} args - Arguments to delete one AppEvent.
     * @example
     * // Delete one AppEvent
     * const AppEvent = await prisma.appEvent.delete({
     *   where: {
     *     // ... filter to delete one AppEvent
     *   }
     * })
     * 
     */
    delete<T extends AppEventDeleteArgs>(args: SelectSubset<T, AppEventDeleteArgs<ExtArgs>>): Prisma__AppEventClient<$Result.GetResult<Prisma.$AppEventPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one AppEvent.
     * @param {AppEventUpdateArgs} args - Arguments to update one AppEvent.
     * @example
     * // Update one AppEvent
     * const appEvent = await prisma.appEvent.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends AppEventUpdateArgs>(args: SelectSubset<T, AppEventUpdateArgs<ExtArgs>>): Prisma__AppEventClient<$Result.GetResult<Prisma.$AppEventPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more AppEvents.
     * @param {AppEventDeleteManyArgs} args - Arguments to filter AppEvents to delete.
     * @example
     * // Delete a few AppEvents
     * const { count } = await prisma.appEvent.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends AppEventDeleteManyArgs>(args?: SelectSubset<T, AppEventDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more AppEvents.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AppEventUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many AppEvents
     * const appEvent = await prisma.appEvent.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends AppEventUpdateManyArgs>(args: SelectSubset<T, AppEventUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more AppEvents and returns the data updated in the database.
     * @param {AppEventUpdateManyAndReturnArgs} args - Arguments to update many AppEvents.
     * @example
     * // Update many AppEvents
     * const appEvent = await prisma.appEvent.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more AppEvents and only return the `id`
     * const appEventWithIdOnly = await prisma.appEvent.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends AppEventUpdateManyAndReturnArgs>(args: SelectSubset<T, AppEventUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AppEventPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one AppEvent.
     * @param {AppEventUpsertArgs} args - Arguments to update or create a AppEvent.
     * @example
     * // Update or create a AppEvent
     * const appEvent = await prisma.appEvent.upsert({
     *   create: {
     *     // ... data to create a AppEvent
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the AppEvent we want to update
     *   }
     * })
     */
    upsert<T extends AppEventUpsertArgs>(args: SelectSubset<T, AppEventUpsertArgs<ExtArgs>>): Prisma__AppEventClient<$Result.GetResult<Prisma.$AppEventPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of AppEvents.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AppEventCountArgs} args - Arguments to filter AppEvents to count.
     * @example
     * // Count the number of AppEvents
     * const count = await prisma.appEvent.count({
     *   where: {
     *     // ... the filter for the AppEvents we want to count
     *   }
     * })
    **/
    count<T extends AppEventCountArgs>(
      args?: Subset<T, AppEventCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], AppEventCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a AppEvent.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AppEventAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends AppEventAggregateArgs>(args: Subset<T, AppEventAggregateArgs>): Prisma.PrismaPromise<GetAppEventAggregateType<T>>

    /**
     * Group by AppEvent.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AppEventGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends AppEventGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: AppEventGroupByArgs['orderBy'] }
        : { orderBy?: AppEventGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, AppEventGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetAppEventGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the AppEvent model
   */
  readonly fields: AppEventFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for AppEvent.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__AppEventClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the AppEvent model
   */
  interface AppEventFieldRefs {
    readonly id: FieldRef<"AppEvent", 'String'>
    readonly userId: FieldRef<"AppEvent", 'String'>
    readonly actorType: FieldRef<"AppEvent", 'ActorType'>
    readonly eventType: FieldRef<"AppEvent", 'EventType'>
    readonly entityType: FieldRef<"AppEvent", 'String'>
    readonly entityId: FieldRef<"AppEvent", 'String'>
    readonly metadata: FieldRef<"AppEvent", 'Json'>
    readonly createdAt: FieldRef<"AppEvent", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * AppEvent findUnique
   */
  export type AppEventFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AppEvent
     */
    select?: AppEventSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AppEvent
     */
    omit?: AppEventOmit<ExtArgs> | null
    /**
     * Filter, which AppEvent to fetch.
     */
    where: AppEventWhereUniqueInput
  }

  /**
   * AppEvent findUniqueOrThrow
   */
  export type AppEventFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AppEvent
     */
    select?: AppEventSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AppEvent
     */
    omit?: AppEventOmit<ExtArgs> | null
    /**
     * Filter, which AppEvent to fetch.
     */
    where: AppEventWhereUniqueInput
  }

  /**
   * AppEvent findFirst
   */
  export type AppEventFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AppEvent
     */
    select?: AppEventSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AppEvent
     */
    omit?: AppEventOmit<ExtArgs> | null
    /**
     * Filter, which AppEvent to fetch.
     */
    where?: AppEventWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of AppEvents to fetch.
     */
    orderBy?: AppEventOrderByWithRelationInput | AppEventOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for AppEvents.
     */
    cursor?: AppEventWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` AppEvents from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` AppEvents.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of AppEvents.
     */
    distinct?: AppEventScalarFieldEnum | AppEventScalarFieldEnum[]
  }

  /**
   * AppEvent findFirstOrThrow
   */
  export type AppEventFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AppEvent
     */
    select?: AppEventSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AppEvent
     */
    omit?: AppEventOmit<ExtArgs> | null
    /**
     * Filter, which AppEvent to fetch.
     */
    where?: AppEventWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of AppEvents to fetch.
     */
    orderBy?: AppEventOrderByWithRelationInput | AppEventOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for AppEvents.
     */
    cursor?: AppEventWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` AppEvents from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` AppEvents.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of AppEvents.
     */
    distinct?: AppEventScalarFieldEnum | AppEventScalarFieldEnum[]
  }

  /**
   * AppEvent findMany
   */
  export type AppEventFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AppEvent
     */
    select?: AppEventSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AppEvent
     */
    omit?: AppEventOmit<ExtArgs> | null
    /**
     * Filter, which AppEvents to fetch.
     */
    where?: AppEventWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of AppEvents to fetch.
     */
    orderBy?: AppEventOrderByWithRelationInput | AppEventOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing AppEvents.
     */
    cursor?: AppEventWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` AppEvents from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` AppEvents.
     */
    skip?: number
    distinct?: AppEventScalarFieldEnum | AppEventScalarFieldEnum[]
  }

  /**
   * AppEvent create
   */
  export type AppEventCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AppEvent
     */
    select?: AppEventSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AppEvent
     */
    omit?: AppEventOmit<ExtArgs> | null
    /**
     * The data needed to create a AppEvent.
     */
    data: XOR<AppEventCreateInput, AppEventUncheckedCreateInput>
  }

  /**
   * AppEvent createMany
   */
  export type AppEventCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many AppEvents.
     */
    data: AppEventCreateManyInput | AppEventCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * AppEvent createManyAndReturn
   */
  export type AppEventCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AppEvent
     */
    select?: AppEventSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the AppEvent
     */
    omit?: AppEventOmit<ExtArgs> | null
    /**
     * The data used to create many AppEvents.
     */
    data: AppEventCreateManyInput | AppEventCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * AppEvent update
   */
  export type AppEventUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AppEvent
     */
    select?: AppEventSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AppEvent
     */
    omit?: AppEventOmit<ExtArgs> | null
    /**
     * The data needed to update a AppEvent.
     */
    data: XOR<AppEventUpdateInput, AppEventUncheckedUpdateInput>
    /**
     * Choose, which AppEvent to update.
     */
    where: AppEventWhereUniqueInput
  }

  /**
   * AppEvent updateMany
   */
  export type AppEventUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update AppEvents.
     */
    data: XOR<AppEventUpdateManyMutationInput, AppEventUncheckedUpdateManyInput>
    /**
     * Filter which AppEvents to update
     */
    where?: AppEventWhereInput
    /**
     * Limit how many AppEvents to update.
     */
    limit?: number
  }

  /**
   * AppEvent updateManyAndReturn
   */
  export type AppEventUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AppEvent
     */
    select?: AppEventSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the AppEvent
     */
    omit?: AppEventOmit<ExtArgs> | null
    /**
     * The data used to update AppEvents.
     */
    data: XOR<AppEventUpdateManyMutationInput, AppEventUncheckedUpdateManyInput>
    /**
     * Filter which AppEvents to update
     */
    where?: AppEventWhereInput
    /**
     * Limit how many AppEvents to update.
     */
    limit?: number
  }

  /**
   * AppEvent upsert
   */
  export type AppEventUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AppEvent
     */
    select?: AppEventSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AppEvent
     */
    omit?: AppEventOmit<ExtArgs> | null
    /**
     * The filter to search for the AppEvent to update in case it exists.
     */
    where: AppEventWhereUniqueInput
    /**
     * In case the AppEvent found by the `where` argument doesn't exist, create a new AppEvent with this data.
     */
    create: XOR<AppEventCreateInput, AppEventUncheckedCreateInput>
    /**
     * In case the AppEvent was found with the provided `where` argument, update it with this data.
     */
    update: XOR<AppEventUpdateInput, AppEventUncheckedUpdateInput>
  }

  /**
   * AppEvent delete
   */
  export type AppEventDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AppEvent
     */
    select?: AppEventSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AppEvent
     */
    omit?: AppEventOmit<ExtArgs> | null
    /**
     * Filter which AppEvent to delete.
     */
    where: AppEventWhereUniqueInput
  }

  /**
   * AppEvent deleteMany
   */
  export type AppEventDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which AppEvents to delete
     */
    where?: AppEventWhereInput
    /**
     * Limit how many AppEvents to delete.
     */
    limit?: number
  }

  /**
   * AppEvent without action
   */
  export type AppEventDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AppEvent
     */
    select?: AppEventSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AppEvent
     */
    omit?: AppEventOmit<ExtArgs> | null
  }


  /**
   * Model DailyStats
   */

  export type AggregateDailyStats = {
    _count: DailyStatsCountAggregateOutputType | null
    _avg: DailyStatsAvgAggregateOutputType | null
    _sum: DailyStatsSumAggregateOutputType | null
    _min: DailyStatsMinAggregateOutputType | null
    _max: DailyStatsMaxAggregateOutputType | null
  }

  export type DailyStatsAvgAggregateOutputType = {
    totalOrders: number | null
    completedOrders: number | null
    cancelledOrders: number | null
    activeAgents: number | null
    avgAssignmentTime: number | null
    totalPayout: number | null
  }

  export type DailyStatsSumAggregateOutputType = {
    totalOrders: number | null
    completedOrders: number | null
    cancelledOrders: number | null
    activeAgents: number | null
    avgAssignmentTime: number | null
    totalPayout: number | null
  }

  export type DailyStatsMinAggregateOutputType = {
    id: string | null
    date: Date | null
    totalOrders: number | null
    completedOrders: number | null
    cancelledOrders: number | null
    activeAgents: number | null
    avgAssignmentTime: number | null
    totalPayout: number | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type DailyStatsMaxAggregateOutputType = {
    id: string | null
    date: Date | null
    totalOrders: number | null
    completedOrders: number | null
    cancelledOrders: number | null
    activeAgents: number | null
    avgAssignmentTime: number | null
    totalPayout: number | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type DailyStatsCountAggregateOutputType = {
    id: number
    date: number
    totalOrders: number
    completedOrders: number
    cancelledOrders: number
    activeAgents: number
    avgAssignmentTime: number
    totalPayout: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type DailyStatsAvgAggregateInputType = {
    totalOrders?: true
    completedOrders?: true
    cancelledOrders?: true
    activeAgents?: true
    avgAssignmentTime?: true
    totalPayout?: true
  }

  export type DailyStatsSumAggregateInputType = {
    totalOrders?: true
    completedOrders?: true
    cancelledOrders?: true
    activeAgents?: true
    avgAssignmentTime?: true
    totalPayout?: true
  }

  export type DailyStatsMinAggregateInputType = {
    id?: true
    date?: true
    totalOrders?: true
    completedOrders?: true
    cancelledOrders?: true
    activeAgents?: true
    avgAssignmentTime?: true
    totalPayout?: true
    createdAt?: true
    updatedAt?: true
  }

  export type DailyStatsMaxAggregateInputType = {
    id?: true
    date?: true
    totalOrders?: true
    completedOrders?: true
    cancelledOrders?: true
    activeAgents?: true
    avgAssignmentTime?: true
    totalPayout?: true
    createdAt?: true
    updatedAt?: true
  }

  export type DailyStatsCountAggregateInputType = {
    id?: true
    date?: true
    totalOrders?: true
    completedOrders?: true
    cancelledOrders?: true
    activeAgents?: true
    avgAssignmentTime?: true
    totalPayout?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type DailyStatsAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which DailyStats to aggregate.
     */
    where?: DailyStatsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of DailyStats to fetch.
     */
    orderBy?: DailyStatsOrderByWithRelationInput | DailyStatsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: DailyStatsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` DailyStats from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` DailyStats.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned DailyStats
    **/
    _count?: true | DailyStatsCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: DailyStatsAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: DailyStatsSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: DailyStatsMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: DailyStatsMaxAggregateInputType
  }

  export type GetDailyStatsAggregateType<T extends DailyStatsAggregateArgs> = {
        [P in keyof T & keyof AggregateDailyStats]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateDailyStats[P]>
      : GetScalarType<T[P], AggregateDailyStats[P]>
  }




  export type DailyStatsGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: DailyStatsWhereInput
    orderBy?: DailyStatsOrderByWithAggregationInput | DailyStatsOrderByWithAggregationInput[]
    by: DailyStatsScalarFieldEnum[] | DailyStatsScalarFieldEnum
    having?: DailyStatsScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: DailyStatsCountAggregateInputType | true
    _avg?: DailyStatsAvgAggregateInputType
    _sum?: DailyStatsSumAggregateInputType
    _min?: DailyStatsMinAggregateInputType
    _max?: DailyStatsMaxAggregateInputType
  }

  export type DailyStatsGroupByOutputType = {
    id: string
    date: Date
    totalOrders: number
    completedOrders: number
    cancelledOrders: number
    activeAgents: number
    avgAssignmentTime: number | null
    totalPayout: number
    createdAt: Date
    updatedAt: Date
    _count: DailyStatsCountAggregateOutputType | null
    _avg: DailyStatsAvgAggregateOutputType | null
    _sum: DailyStatsSumAggregateOutputType | null
    _min: DailyStatsMinAggregateOutputType | null
    _max: DailyStatsMaxAggregateOutputType | null
  }

  type GetDailyStatsGroupByPayload<T extends DailyStatsGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<DailyStatsGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof DailyStatsGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], DailyStatsGroupByOutputType[P]>
            : GetScalarType<T[P], DailyStatsGroupByOutputType[P]>
        }
      >
    >


  export type DailyStatsSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    date?: boolean
    totalOrders?: boolean
    completedOrders?: boolean
    cancelledOrders?: boolean
    activeAgents?: boolean
    avgAssignmentTime?: boolean
    totalPayout?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }, ExtArgs["result"]["dailyStats"]>

  export type DailyStatsSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    date?: boolean
    totalOrders?: boolean
    completedOrders?: boolean
    cancelledOrders?: boolean
    activeAgents?: boolean
    avgAssignmentTime?: boolean
    totalPayout?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }, ExtArgs["result"]["dailyStats"]>

  export type DailyStatsSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    date?: boolean
    totalOrders?: boolean
    completedOrders?: boolean
    cancelledOrders?: boolean
    activeAgents?: boolean
    avgAssignmentTime?: boolean
    totalPayout?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }, ExtArgs["result"]["dailyStats"]>

  export type DailyStatsSelectScalar = {
    id?: boolean
    date?: boolean
    totalOrders?: boolean
    completedOrders?: boolean
    cancelledOrders?: boolean
    activeAgents?: boolean
    avgAssignmentTime?: boolean
    totalPayout?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type DailyStatsOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "date" | "totalOrders" | "completedOrders" | "cancelledOrders" | "activeAgents" | "avgAssignmentTime" | "totalPayout" | "createdAt" | "updatedAt", ExtArgs["result"]["dailyStats"]>

  export type $DailyStatsPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "DailyStats"
    objects: {}
    scalars: $Extensions.GetPayloadResult<{
      id: string
      date: Date
      totalOrders: number
      completedOrders: number
      cancelledOrders: number
      activeAgents: number
      avgAssignmentTime: number | null
      totalPayout: number
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["dailyStats"]>
    composites: {}
  }

  type DailyStatsGetPayload<S extends boolean | null | undefined | DailyStatsDefaultArgs> = $Result.GetResult<Prisma.$DailyStatsPayload, S>

  type DailyStatsCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<DailyStatsFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: DailyStatsCountAggregateInputType | true
    }

  export interface DailyStatsDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['DailyStats'], meta: { name: 'DailyStats' } }
    /**
     * Find zero or one DailyStats that matches the filter.
     * @param {DailyStatsFindUniqueArgs} args - Arguments to find a DailyStats
     * @example
     * // Get one DailyStats
     * const dailyStats = await prisma.dailyStats.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends DailyStatsFindUniqueArgs>(args: SelectSubset<T, DailyStatsFindUniqueArgs<ExtArgs>>): Prisma__DailyStatsClient<$Result.GetResult<Prisma.$DailyStatsPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one DailyStats that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {DailyStatsFindUniqueOrThrowArgs} args - Arguments to find a DailyStats
     * @example
     * // Get one DailyStats
     * const dailyStats = await prisma.dailyStats.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends DailyStatsFindUniqueOrThrowArgs>(args: SelectSubset<T, DailyStatsFindUniqueOrThrowArgs<ExtArgs>>): Prisma__DailyStatsClient<$Result.GetResult<Prisma.$DailyStatsPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first DailyStats that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DailyStatsFindFirstArgs} args - Arguments to find a DailyStats
     * @example
     * // Get one DailyStats
     * const dailyStats = await prisma.dailyStats.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends DailyStatsFindFirstArgs>(args?: SelectSubset<T, DailyStatsFindFirstArgs<ExtArgs>>): Prisma__DailyStatsClient<$Result.GetResult<Prisma.$DailyStatsPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first DailyStats that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DailyStatsFindFirstOrThrowArgs} args - Arguments to find a DailyStats
     * @example
     * // Get one DailyStats
     * const dailyStats = await prisma.dailyStats.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends DailyStatsFindFirstOrThrowArgs>(args?: SelectSubset<T, DailyStatsFindFirstOrThrowArgs<ExtArgs>>): Prisma__DailyStatsClient<$Result.GetResult<Prisma.$DailyStatsPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more DailyStats that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DailyStatsFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all DailyStats
     * const dailyStats = await prisma.dailyStats.findMany()
     * 
     * // Get first 10 DailyStats
     * const dailyStats = await prisma.dailyStats.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const dailyStatsWithIdOnly = await prisma.dailyStats.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends DailyStatsFindManyArgs>(args?: SelectSubset<T, DailyStatsFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$DailyStatsPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a DailyStats.
     * @param {DailyStatsCreateArgs} args - Arguments to create a DailyStats.
     * @example
     * // Create one DailyStats
     * const DailyStats = await prisma.dailyStats.create({
     *   data: {
     *     // ... data to create a DailyStats
     *   }
     * })
     * 
     */
    create<T extends DailyStatsCreateArgs>(args: SelectSubset<T, DailyStatsCreateArgs<ExtArgs>>): Prisma__DailyStatsClient<$Result.GetResult<Prisma.$DailyStatsPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many DailyStats.
     * @param {DailyStatsCreateManyArgs} args - Arguments to create many DailyStats.
     * @example
     * // Create many DailyStats
     * const dailyStats = await prisma.dailyStats.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends DailyStatsCreateManyArgs>(args?: SelectSubset<T, DailyStatsCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many DailyStats and returns the data saved in the database.
     * @param {DailyStatsCreateManyAndReturnArgs} args - Arguments to create many DailyStats.
     * @example
     * // Create many DailyStats
     * const dailyStats = await prisma.dailyStats.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many DailyStats and only return the `id`
     * const dailyStatsWithIdOnly = await prisma.dailyStats.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends DailyStatsCreateManyAndReturnArgs>(args?: SelectSubset<T, DailyStatsCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$DailyStatsPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a DailyStats.
     * @param {DailyStatsDeleteArgs} args - Arguments to delete one DailyStats.
     * @example
     * // Delete one DailyStats
     * const DailyStats = await prisma.dailyStats.delete({
     *   where: {
     *     // ... filter to delete one DailyStats
     *   }
     * })
     * 
     */
    delete<T extends DailyStatsDeleteArgs>(args: SelectSubset<T, DailyStatsDeleteArgs<ExtArgs>>): Prisma__DailyStatsClient<$Result.GetResult<Prisma.$DailyStatsPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one DailyStats.
     * @param {DailyStatsUpdateArgs} args - Arguments to update one DailyStats.
     * @example
     * // Update one DailyStats
     * const dailyStats = await prisma.dailyStats.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends DailyStatsUpdateArgs>(args: SelectSubset<T, DailyStatsUpdateArgs<ExtArgs>>): Prisma__DailyStatsClient<$Result.GetResult<Prisma.$DailyStatsPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more DailyStats.
     * @param {DailyStatsDeleteManyArgs} args - Arguments to filter DailyStats to delete.
     * @example
     * // Delete a few DailyStats
     * const { count } = await prisma.dailyStats.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends DailyStatsDeleteManyArgs>(args?: SelectSubset<T, DailyStatsDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more DailyStats.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DailyStatsUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many DailyStats
     * const dailyStats = await prisma.dailyStats.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends DailyStatsUpdateManyArgs>(args: SelectSubset<T, DailyStatsUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more DailyStats and returns the data updated in the database.
     * @param {DailyStatsUpdateManyAndReturnArgs} args - Arguments to update many DailyStats.
     * @example
     * // Update many DailyStats
     * const dailyStats = await prisma.dailyStats.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more DailyStats and only return the `id`
     * const dailyStatsWithIdOnly = await prisma.dailyStats.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends DailyStatsUpdateManyAndReturnArgs>(args: SelectSubset<T, DailyStatsUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$DailyStatsPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one DailyStats.
     * @param {DailyStatsUpsertArgs} args - Arguments to update or create a DailyStats.
     * @example
     * // Update or create a DailyStats
     * const dailyStats = await prisma.dailyStats.upsert({
     *   create: {
     *     // ... data to create a DailyStats
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the DailyStats we want to update
     *   }
     * })
     */
    upsert<T extends DailyStatsUpsertArgs>(args: SelectSubset<T, DailyStatsUpsertArgs<ExtArgs>>): Prisma__DailyStatsClient<$Result.GetResult<Prisma.$DailyStatsPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of DailyStats.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DailyStatsCountArgs} args - Arguments to filter DailyStats to count.
     * @example
     * // Count the number of DailyStats
     * const count = await prisma.dailyStats.count({
     *   where: {
     *     // ... the filter for the DailyStats we want to count
     *   }
     * })
    **/
    count<T extends DailyStatsCountArgs>(
      args?: Subset<T, DailyStatsCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], DailyStatsCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a DailyStats.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DailyStatsAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends DailyStatsAggregateArgs>(args: Subset<T, DailyStatsAggregateArgs>): Prisma.PrismaPromise<GetDailyStatsAggregateType<T>>

    /**
     * Group by DailyStats.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DailyStatsGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends DailyStatsGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: DailyStatsGroupByArgs['orderBy'] }
        : { orderBy?: DailyStatsGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, DailyStatsGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetDailyStatsGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the DailyStats model
   */
  readonly fields: DailyStatsFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for DailyStats.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__DailyStatsClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the DailyStats model
   */
  interface DailyStatsFieldRefs {
    readonly id: FieldRef<"DailyStats", 'String'>
    readonly date: FieldRef<"DailyStats", 'DateTime'>
    readonly totalOrders: FieldRef<"DailyStats", 'Int'>
    readonly completedOrders: FieldRef<"DailyStats", 'Int'>
    readonly cancelledOrders: FieldRef<"DailyStats", 'Int'>
    readonly activeAgents: FieldRef<"DailyStats", 'Int'>
    readonly avgAssignmentTime: FieldRef<"DailyStats", 'Float'>
    readonly totalPayout: FieldRef<"DailyStats", 'Float'>
    readonly createdAt: FieldRef<"DailyStats", 'DateTime'>
    readonly updatedAt: FieldRef<"DailyStats", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * DailyStats findUnique
   */
  export type DailyStatsFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DailyStats
     */
    select?: DailyStatsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the DailyStats
     */
    omit?: DailyStatsOmit<ExtArgs> | null
    /**
     * Filter, which DailyStats to fetch.
     */
    where: DailyStatsWhereUniqueInput
  }

  /**
   * DailyStats findUniqueOrThrow
   */
  export type DailyStatsFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DailyStats
     */
    select?: DailyStatsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the DailyStats
     */
    omit?: DailyStatsOmit<ExtArgs> | null
    /**
     * Filter, which DailyStats to fetch.
     */
    where: DailyStatsWhereUniqueInput
  }

  /**
   * DailyStats findFirst
   */
  export type DailyStatsFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DailyStats
     */
    select?: DailyStatsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the DailyStats
     */
    omit?: DailyStatsOmit<ExtArgs> | null
    /**
     * Filter, which DailyStats to fetch.
     */
    where?: DailyStatsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of DailyStats to fetch.
     */
    orderBy?: DailyStatsOrderByWithRelationInput | DailyStatsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for DailyStats.
     */
    cursor?: DailyStatsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` DailyStats from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` DailyStats.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of DailyStats.
     */
    distinct?: DailyStatsScalarFieldEnum | DailyStatsScalarFieldEnum[]
  }

  /**
   * DailyStats findFirstOrThrow
   */
  export type DailyStatsFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DailyStats
     */
    select?: DailyStatsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the DailyStats
     */
    omit?: DailyStatsOmit<ExtArgs> | null
    /**
     * Filter, which DailyStats to fetch.
     */
    where?: DailyStatsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of DailyStats to fetch.
     */
    orderBy?: DailyStatsOrderByWithRelationInput | DailyStatsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for DailyStats.
     */
    cursor?: DailyStatsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` DailyStats from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` DailyStats.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of DailyStats.
     */
    distinct?: DailyStatsScalarFieldEnum | DailyStatsScalarFieldEnum[]
  }

  /**
   * DailyStats findMany
   */
  export type DailyStatsFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DailyStats
     */
    select?: DailyStatsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the DailyStats
     */
    omit?: DailyStatsOmit<ExtArgs> | null
    /**
     * Filter, which DailyStats to fetch.
     */
    where?: DailyStatsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of DailyStats to fetch.
     */
    orderBy?: DailyStatsOrderByWithRelationInput | DailyStatsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing DailyStats.
     */
    cursor?: DailyStatsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` DailyStats from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` DailyStats.
     */
    skip?: number
    distinct?: DailyStatsScalarFieldEnum | DailyStatsScalarFieldEnum[]
  }

  /**
   * DailyStats create
   */
  export type DailyStatsCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DailyStats
     */
    select?: DailyStatsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the DailyStats
     */
    omit?: DailyStatsOmit<ExtArgs> | null
    /**
     * The data needed to create a DailyStats.
     */
    data: XOR<DailyStatsCreateInput, DailyStatsUncheckedCreateInput>
  }

  /**
   * DailyStats createMany
   */
  export type DailyStatsCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many DailyStats.
     */
    data: DailyStatsCreateManyInput | DailyStatsCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * DailyStats createManyAndReturn
   */
  export type DailyStatsCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DailyStats
     */
    select?: DailyStatsSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the DailyStats
     */
    omit?: DailyStatsOmit<ExtArgs> | null
    /**
     * The data used to create many DailyStats.
     */
    data: DailyStatsCreateManyInput | DailyStatsCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * DailyStats update
   */
  export type DailyStatsUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DailyStats
     */
    select?: DailyStatsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the DailyStats
     */
    omit?: DailyStatsOmit<ExtArgs> | null
    /**
     * The data needed to update a DailyStats.
     */
    data: XOR<DailyStatsUpdateInput, DailyStatsUncheckedUpdateInput>
    /**
     * Choose, which DailyStats to update.
     */
    where: DailyStatsWhereUniqueInput
  }

  /**
   * DailyStats updateMany
   */
  export type DailyStatsUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update DailyStats.
     */
    data: XOR<DailyStatsUpdateManyMutationInput, DailyStatsUncheckedUpdateManyInput>
    /**
     * Filter which DailyStats to update
     */
    where?: DailyStatsWhereInput
    /**
     * Limit how many DailyStats to update.
     */
    limit?: number
  }

  /**
   * DailyStats updateManyAndReturn
   */
  export type DailyStatsUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DailyStats
     */
    select?: DailyStatsSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the DailyStats
     */
    omit?: DailyStatsOmit<ExtArgs> | null
    /**
     * The data used to update DailyStats.
     */
    data: XOR<DailyStatsUpdateManyMutationInput, DailyStatsUncheckedUpdateManyInput>
    /**
     * Filter which DailyStats to update
     */
    where?: DailyStatsWhereInput
    /**
     * Limit how many DailyStats to update.
     */
    limit?: number
  }

  /**
   * DailyStats upsert
   */
  export type DailyStatsUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DailyStats
     */
    select?: DailyStatsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the DailyStats
     */
    omit?: DailyStatsOmit<ExtArgs> | null
    /**
     * The filter to search for the DailyStats to update in case it exists.
     */
    where: DailyStatsWhereUniqueInput
    /**
     * In case the DailyStats found by the `where` argument doesn't exist, create a new DailyStats with this data.
     */
    create: XOR<DailyStatsCreateInput, DailyStatsUncheckedCreateInput>
    /**
     * In case the DailyStats was found with the provided `where` argument, update it with this data.
     */
    update: XOR<DailyStatsUpdateInput, DailyStatsUncheckedUpdateInput>
  }

  /**
   * DailyStats delete
   */
  export type DailyStatsDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DailyStats
     */
    select?: DailyStatsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the DailyStats
     */
    omit?: DailyStatsOmit<ExtArgs> | null
    /**
     * Filter which DailyStats to delete.
     */
    where: DailyStatsWhereUniqueInput
  }

  /**
   * DailyStats deleteMany
   */
  export type DailyStatsDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which DailyStats to delete
     */
    where?: DailyStatsWhereInput
    /**
     * Limit how many DailyStats to delete.
     */
    limit?: number
  }

  /**
   * DailyStats without action
   */
  export type DailyStatsDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DailyStats
     */
    select?: DailyStatsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the DailyStats
     */
    omit?: DailyStatsOmit<ExtArgs> | null
  }


  /**
   * Model PartnerDailyStats
   */

  export type AggregatePartnerDailyStats = {
    _count: PartnerDailyStatsCountAggregateOutputType | null
    _avg: PartnerDailyStatsAvgAggregateOutputType | null
    _sum: PartnerDailyStatsSumAggregateOutputType | null
    _min: PartnerDailyStatsMinAggregateOutputType | null
    _max: PartnerDailyStatsMaxAggregateOutputType | null
  }

  export type PartnerDailyStatsAvgAggregateOutputType = {
    totalOrders: number | null
    completedOrders: number | null
    cancelledOrders: number | null
    avgAssignmentTime: number | null
  }

  export type PartnerDailyStatsSumAggregateOutputType = {
    totalOrders: number | null
    completedOrders: number | null
    cancelledOrders: number | null
    avgAssignmentTime: number | null
  }

  export type PartnerDailyStatsMinAggregateOutputType = {
    id: string | null
    partnerId: string | null
    date: Date | null
    totalOrders: number | null
    completedOrders: number | null
    cancelledOrders: number | null
    avgAssignmentTime: number | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type PartnerDailyStatsMaxAggregateOutputType = {
    id: string | null
    partnerId: string | null
    date: Date | null
    totalOrders: number | null
    completedOrders: number | null
    cancelledOrders: number | null
    avgAssignmentTime: number | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type PartnerDailyStatsCountAggregateOutputType = {
    id: number
    partnerId: number
    date: number
    totalOrders: number
    completedOrders: number
    cancelledOrders: number
    avgAssignmentTime: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type PartnerDailyStatsAvgAggregateInputType = {
    totalOrders?: true
    completedOrders?: true
    cancelledOrders?: true
    avgAssignmentTime?: true
  }

  export type PartnerDailyStatsSumAggregateInputType = {
    totalOrders?: true
    completedOrders?: true
    cancelledOrders?: true
    avgAssignmentTime?: true
  }

  export type PartnerDailyStatsMinAggregateInputType = {
    id?: true
    partnerId?: true
    date?: true
    totalOrders?: true
    completedOrders?: true
    cancelledOrders?: true
    avgAssignmentTime?: true
    createdAt?: true
    updatedAt?: true
  }

  export type PartnerDailyStatsMaxAggregateInputType = {
    id?: true
    partnerId?: true
    date?: true
    totalOrders?: true
    completedOrders?: true
    cancelledOrders?: true
    avgAssignmentTime?: true
    createdAt?: true
    updatedAt?: true
  }

  export type PartnerDailyStatsCountAggregateInputType = {
    id?: true
    partnerId?: true
    date?: true
    totalOrders?: true
    completedOrders?: true
    cancelledOrders?: true
    avgAssignmentTime?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type PartnerDailyStatsAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which PartnerDailyStats to aggregate.
     */
    where?: PartnerDailyStatsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of PartnerDailyStats to fetch.
     */
    orderBy?: PartnerDailyStatsOrderByWithRelationInput | PartnerDailyStatsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: PartnerDailyStatsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` PartnerDailyStats from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` PartnerDailyStats.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned PartnerDailyStats
    **/
    _count?: true | PartnerDailyStatsCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: PartnerDailyStatsAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: PartnerDailyStatsSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: PartnerDailyStatsMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: PartnerDailyStatsMaxAggregateInputType
  }

  export type GetPartnerDailyStatsAggregateType<T extends PartnerDailyStatsAggregateArgs> = {
        [P in keyof T & keyof AggregatePartnerDailyStats]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregatePartnerDailyStats[P]>
      : GetScalarType<T[P], AggregatePartnerDailyStats[P]>
  }




  export type PartnerDailyStatsGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: PartnerDailyStatsWhereInput
    orderBy?: PartnerDailyStatsOrderByWithAggregationInput | PartnerDailyStatsOrderByWithAggregationInput[]
    by: PartnerDailyStatsScalarFieldEnum[] | PartnerDailyStatsScalarFieldEnum
    having?: PartnerDailyStatsScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: PartnerDailyStatsCountAggregateInputType | true
    _avg?: PartnerDailyStatsAvgAggregateInputType
    _sum?: PartnerDailyStatsSumAggregateInputType
    _min?: PartnerDailyStatsMinAggregateInputType
    _max?: PartnerDailyStatsMaxAggregateInputType
  }

  export type PartnerDailyStatsGroupByOutputType = {
    id: string
    partnerId: string
    date: Date
    totalOrders: number
    completedOrders: number
    cancelledOrders: number
    avgAssignmentTime: number | null
    createdAt: Date
    updatedAt: Date
    _count: PartnerDailyStatsCountAggregateOutputType | null
    _avg: PartnerDailyStatsAvgAggregateOutputType | null
    _sum: PartnerDailyStatsSumAggregateOutputType | null
    _min: PartnerDailyStatsMinAggregateOutputType | null
    _max: PartnerDailyStatsMaxAggregateOutputType | null
  }

  type GetPartnerDailyStatsGroupByPayload<T extends PartnerDailyStatsGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<PartnerDailyStatsGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof PartnerDailyStatsGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], PartnerDailyStatsGroupByOutputType[P]>
            : GetScalarType<T[P], PartnerDailyStatsGroupByOutputType[P]>
        }
      >
    >


  export type PartnerDailyStatsSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    partnerId?: boolean
    date?: boolean
    totalOrders?: boolean
    completedOrders?: boolean
    cancelledOrders?: boolean
    avgAssignmentTime?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    partner?: boolean | PartnerDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["partnerDailyStats"]>

  export type PartnerDailyStatsSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    partnerId?: boolean
    date?: boolean
    totalOrders?: boolean
    completedOrders?: boolean
    cancelledOrders?: boolean
    avgAssignmentTime?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    partner?: boolean | PartnerDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["partnerDailyStats"]>

  export type PartnerDailyStatsSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    partnerId?: boolean
    date?: boolean
    totalOrders?: boolean
    completedOrders?: boolean
    cancelledOrders?: boolean
    avgAssignmentTime?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    partner?: boolean | PartnerDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["partnerDailyStats"]>

  export type PartnerDailyStatsSelectScalar = {
    id?: boolean
    partnerId?: boolean
    date?: boolean
    totalOrders?: boolean
    completedOrders?: boolean
    cancelledOrders?: boolean
    avgAssignmentTime?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type PartnerDailyStatsOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "partnerId" | "date" | "totalOrders" | "completedOrders" | "cancelledOrders" | "avgAssignmentTime" | "createdAt" | "updatedAt", ExtArgs["result"]["partnerDailyStats"]>
  export type PartnerDailyStatsInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    partner?: boolean | PartnerDefaultArgs<ExtArgs>
  }
  export type PartnerDailyStatsIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    partner?: boolean | PartnerDefaultArgs<ExtArgs>
  }
  export type PartnerDailyStatsIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    partner?: boolean | PartnerDefaultArgs<ExtArgs>
  }

  export type $PartnerDailyStatsPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "PartnerDailyStats"
    objects: {
      partner: Prisma.$PartnerPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      partnerId: string
      date: Date
      totalOrders: number
      completedOrders: number
      cancelledOrders: number
      avgAssignmentTime: number | null
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["partnerDailyStats"]>
    composites: {}
  }

  type PartnerDailyStatsGetPayload<S extends boolean | null | undefined | PartnerDailyStatsDefaultArgs> = $Result.GetResult<Prisma.$PartnerDailyStatsPayload, S>

  type PartnerDailyStatsCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<PartnerDailyStatsFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: PartnerDailyStatsCountAggregateInputType | true
    }

  export interface PartnerDailyStatsDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['PartnerDailyStats'], meta: { name: 'PartnerDailyStats' } }
    /**
     * Find zero or one PartnerDailyStats that matches the filter.
     * @param {PartnerDailyStatsFindUniqueArgs} args - Arguments to find a PartnerDailyStats
     * @example
     * // Get one PartnerDailyStats
     * const partnerDailyStats = await prisma.partnerDailyStats.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends PartnerDailyStatsFindUniqueArgs>(args: SelectSubset<T, PartnerDailyStatsFindUniqueArgs<ExtArgs>>): Prisma__PartnerDailyStatsClient<$Result.GetResult<Prisma.$PartnerDailyStatsPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one PartnerDailyStats that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {PartnerDailyStatsFindUniqueOrThrowArgs} args - Arguments to find a PartnerDailyStats
     * @example
     * // Get one PartnerDailyStats
     * const partnerDailyStats = await prisma.partnerDailyStats.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends PartnerDailyStatsFindUniqueOrThrowArgs>(args: SelectSubset<T, PartnerDailyStatsFindUniqueOrThrowArgs<ExtArgs>>): Prisma__PartnerDailyStatsClient<$Result.GetResult<Prisma.$PartnerDailyStatsPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first PartnerDailyStats that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PartnerDailyStatsFindFirstArgs} args - Arguments to find a PartnerDailyStats
     * @example
     * // Get one PartnerDailyStats
     * const partnerDailyStats = await prisma.partnerDailyStats.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends PartnerDailyStatsFindFirstArgs>(args?: SelectSubset<T, PartnerDailyStatsFindFirstArgs<ExtArgs>>): Prisma__PartnerDailyStatsClient<$Result.GetResult<Prisma.$PartnerDailyStatsPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first PartnerDailyStats that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PartnerDailyStatsFindFirstOrThrowArgs} args - Arguments to find a PartnerDailyStats
     * @example
     * // Get one PartnerDailyStats
     * const partnerDailyStats = await prisma.partnerDailyStats.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends PartnerDailyStatsFindFirstOrThrowArgs>(args?: SelectSubset<T, PartnerDailyStatsFindFirstOrThrowArgs<ExtArgs>>): Prisma__PartnerDailyStatsClient<$Result.GetResult<Prisma.$PartnerDailyStatsPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more PartnerDailyStats that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PartnerDailyStatsFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all PartnerDailyStats
     * const partnerDailyStats = await prisma.partnerDailyStats.findMany()
     * 
     * // Get first 10 PartnerDailyStats
     * const partnerDailyStats = await prisma.partnerDailyStats.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const partnerDailyStatsWithIdOnly = await prisma.partnerDailyStats.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends PartnerDailyStatsFindManyArgs>(args?: SelectSubset<T, PartnerDailyStatsFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PartnerDailyStatsPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a PartnerDailyStats.
     * @param {PartnerDailyStatsCreateArgs} args - Arguments to create a PartnerDailyStats.
     * @example
     * // Create one PartnerDailyStats
     * const PartnerDailyStats = await prisma.partnerDailyStats.create({
     *   data: {
     *     // ... data to create a PartnerDailyStats
     *   }
     * })
     * 
     */
    create<T extends PartnerDailyStatsCreateArgs>(args: SelectSubset<T, PartnerDailyStatsCreateArgs<ExtArgs>>): Prisma__PartnerDailyStatsClient<$Result.GetResult<Prisma.$PartnerDailyStatsPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many PartnerDailyStats.
     * @param {PartnerDailyStatsCreateManyArgs} args - Arguments to create many PartnerDailyStats.
     * @example
     * // Create many PartnerDailyStats
     * const partnerDailyStats = await prisma.partnerDailyStats.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends PartnerDailyStatsCreateManyArgs>(args?: SelectSubset<T, PartnerDailyStatsCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many PartnerDailyStats and returns the data saved in the database.
     * @param {PartnerDailyStatsCreateManyAndReturnArgs} args - Arguments to create many PartnerDailyStats.
     * @example
     * // Create many PartnerDailyStats
     * const partnerDailyStats = await prisma.partnerDailyStats.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many PartnerDailyStats and only return the `id`
     * const partnerDailyStatsWithIdOnly = await prisma.partnerDailyStats.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends PartnerDailyStatsCreateManyAndReturnArgs>(args?: SelectSubset<T, PartnerDailyStatsCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PartnerDailyStatsPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a PartnerDailyStats.
     * @param {PartnerDailyStatsDeleteArgs} args - Arguments to delete one PartnerDailyStats.
     * @example
     * // Delete one PartnerDailyStats
     * const PartnerDailyStats = await prisma.partnerDailyStats.delete({
     *   where: {
     *     // ... filter to delete one PartnerDailyStats
     *   }
     * })
     * 
     */
    delete<T extends PartnerDailyStatsDeleteArgs>(args: SelectSubset<T, PartnerDailyStatsDeleteArgs<ExtArgs>>): Prisma__PartnerDailyStatsClient<$Result.GetResult<Prisma.$PartnerDailyStatsPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one PartnerDailyStats.
     * @param {PartnerDailyStatsUpdateArgs} args - Arguments to update one PartnerDailyStats.
     * @example
     * // Update one PartnerDailyStats
     * const partnerDailyStats = await prisma.partnerDailyStats.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends PartnerDailyStatsUpdateArgs>(args: SelectSubset<T, PartnerDailyStatsUpdateArgs<ExtArgs>>): Prisma__PartnerDailyStatsClient<$Result.GetResult<Prisma.$PartnerDailyStatsPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more PartnerDailyStats.
     * @param {PartnerDailyStatsDeleteManyArgs} args - Arguments to filter PartnerDailyStats to delete.
     * @example
     * // Delete a few PartnerDailyStats
     * const { count } = await prisma.partnerDailyStats.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends PartnerDailyStatsDeleteManyArgs>(args?: SelectSubset<T, PartnerDailyStatsDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more PartnerDailyStats.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PartnerDailyStatsUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many PartnerDailyStats
     * const partnerDailyStats = await prisma.partnerDailyStats.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends PartnerDailyStatsUpdateManyArgs>(args: SelectSubset<T, PartnerDailyStatsUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more PartnerDailyStats and returns the data updated in the database.
     * @param {PartnerDailyStatsUpdateManyAndReturnArgs} args - Arguments to update many PartnerDailyStats.
     * @example
     * // Update many PartnerDailyStats
     * const partnerDailyStats = await prisma.partnerDailyStats.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more PartnerDailyStats and only return the `id`
     * const partnerDailyStatsWithIdOnly = await prisma.partnerDailyStats.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends PartnerDailyStatsUpdateManyAndReturnArgs>(args: SelectSubset<T, PartnerDailyStatsUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PartnerDailyStatsPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one PartnerDailyStats.
     * @param {PartnerDailyStatsUpsertArgs} args - Arguments to update or create a PartnerDailyStats.
     * @example
     * // Update or create a PartnerDailyStats
     * const partnerDailyStats = await prisma.partnerDailyStats.upsert({
     *   create: {
     *     // ... data to create a PartnerDailyStats
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the PartnerDailyStats we want to update
     *   }
     * })
     */
    upsert<T extends PartnerDailyStatsUpsertArgs>(args: SelectSubset<T, PartnerDailyStatsUpsertArgs<ExtArgs>>): Prisma__PartnerDailyStatsClient<$Result.GetResult<Prisma.$PartnerDailyStatsPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of PartnerDailyStats.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PartnerDailyStatsCountArgs} args - Arguments to filter PartnerDailyStats to count.
     * @example
     * // Count the number of PartnerDailyStats
     * const count = await prisma.partnerDailyStats.count({
     *   where: {
     *     // ... the filter for the PartnerDailyStats we want to count
     *   }
     * })
    **/
    count<T extends PartnerDailyStatsCountArgs>(
      args?: Subset<T, PartnerDailyStatsCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], PartnerDailyStatsCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a PartnerDailyStats.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PartnerDailyStatsAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends PartnerDailyStatsAggregateArgs>(args: Subset<T, PartnerDailyStatsAggregateArgs>): Prisma.PrismaPromise<GetPartnerDailyStatsAggregateType<T>>

    /**
     * Group by PartnerDailyStats.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PartnerDailyStatsGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends PartnerDailyStatsGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: PartnerDailyStatsGroupByArgs['orderBy'] }
        : { orderBy?: PartnerDailyStatsGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, PartnerDailyStatsGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetPartnerDailyStatsGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the PartnerDailyStats model
   */
  readonly fields: PartnerDailyStatsFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for PartnerDailyStats.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__PartnerDailyStatsClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    partner<T extends PartnerDefaultArgs<ExtArgs> = {}>(args?: Subset<T, PartnerDefaultArgs<ExtArgs>>): Prisma__PartnerClient<$Result.GetResult<Prisma.$PartnerPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the PartnerDailyStats model
   */
  interface PartnerDailyStatsFieldRefs {
    readonly id: FieldRef<"PartnerDailyStats", 'String'>
    readonly partnerId: FieldRef<"PartnerDailyStats", 'String'>
    readonly date: FieldRef<"PartnerDailyStats", 'DateTime'>
    readonly totalOrders: FieldRef<"PartnerDailyStats", 'Int'>
    readonly completedOrders: FieldRef<"PartnerDailyStats", 'Int'>
    readonly cancelledOrders: FieldRef<"PartnerDailyStats", 'Int'>
    readonly avgAssignmentTime: FieldRef<"PartnerDailyStats", 'Float'>
    readonly createdAt: FieldRef<"PartnerDailyStats", 'DateTime'>
    readonly updatedAt: FieldRef<"PartnerDailyStats", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * PartnerDailyStats findUnique
   */
  export type PartnerDailyStatsFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PartnerDailyStats
     */
    select?: PartnerDailyStatsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PartnerDailyStats
     */
    omit?: PartnerDailyStatsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PartnerDailyStatsInclude<ExtArgs> | null
    /**
     * Filter, which PartnerDailyStats to fetch.
     */
    where: PartnerDailyStatsWhereUniqueInput
  }

  /**
   * PartnerDailyStats findUniqueOrThrow
   */
  export type PartnerDailyStatsFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PartnerDailyStats
     */
    select?: PartnerDailyStatsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PartnerDailyStats
     */
    omit?: PartnerDailyStatsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PartnerDailyStatsInclude<ExtArgs> | null
    /**
     * Filter, which PartnerDailyStats to fetch.
     */
    where: PartnerDailyStatsWhereUniqueInput
  }

  /**
   * PartnerDailyStats findFirst
   */
  export type PartnerDailyStatsFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PartnerDailyStats
     */
    select?: PartnerDailyStatsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PartnerDailyStats
     */
    omit?: PartnerDailyStatsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PartnerDailyStatsInclude<ExtArgs> | null
    /**
     * Filter, which PartnerDailyStats to fetch.
     */
    where?: PartnerDailyStatsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of PartnerDailyStats to fetch.
     */
    orderBy?: PartnerDailyStatsOrderByWithRelationInput | PartnerDailyStatsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for PartnerDailyStats.
     */
    cursor?: PartnerDailyStatsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` PartnerDailyStats from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` PartnerDailyStats.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of PartnerDailyStats.
     */
    distinct?: PartnerDailyStatsScalarFieldEnum | PartnerDailyStatsScalarFieldEnum[]
  }

  /**
   * PartnerDailyStats findFirstOrThrow
   */
  export type PartnerDailyStatsFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PartnerDailyStats
     */
    select?: PartnerDailyStatsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PartnerDailyStats
     */
    omit?: PartnerDailyStatsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PartnerDailyStatsInclude<ExtArgs> | null
    /**
     * Filter, which PartnerDailyStats to fetch.
     */
    where?: PartnerDailyStatsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of PartnerDailyStats to fetch.
     */
    orderBy?: PartnerDailyStatsOrderByWithRelationInput | PartnerDailyStatsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for PartnerDailyStats.
     */
    cursor?: PartnerDailyStatsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` PartnerDailyStats from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` PartnerDailyStats.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of PartnerDailyStats.
     */
    distinct?: PartnerDailyStatsScalarFieldEnum | PartnerDailyStatsScalarFieldEnum[]
  }

  /**
   * PartnerDailyStats findMany
   */
  export type PartnerDailyStatsFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PartnerDailyStats
     */
    select?: PartnerDailyStatsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PartnerDailyStats
     */
    omit?: PartnerDailyStatsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PartnerDailyStatsInclude<ExtArgs> | null
    /**
     * Filter, which PartnerDailyStats to fetch.
     */
    where?: PartnerDailyStatsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of PartnerDailyStats to fetch.
     */
    orderBy?: PartnerDailyStatsOrderByWithRelationInput | PartnerDailyStatsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing PartnerDailyStats.
     */
    cursor?: PartnerDailyStatsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` PartnerDailyStats from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` PartnerDailyStats.
     */
    skip?: number
    distinct?: PartnerDailyStatsScalarFieldEnum | PartnerDailyStatsScalarFieldEnum[]
  }

  /**
   * PartnerDailyStats create
   */
  export type PartnerDailyStatsCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PartnerDailyStats
     */
    select?: PartnerDailyStatsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PartnerDailyStats
     */
    omit?: PartnerDailyStatsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PartnerDailyStatsInclude<ExtArgs> | null
    /**
     * The data needed to create a PartnerDailyStats.
     */
    data: XOR<PartnerDailyStatsCreateInput, PartnerDailyStatsUncheckedCreateInput>
  }

  /**
   * PartnerDailyStats createMany
   */
  export type PartnerDailyStatsCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many PartnerDailyStats.
     */
    data: PartnerDailyStatsCreateManyInput | PartnerDailyStatsCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * PartnerDailyStats createManyAndReturn
   */
  export type PartnerDailyStatsCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PartnerDailyStats
     */
    select?: PartnerDailyStatsSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the PartnerDailyStats
     */
    omit?: PartnerDailyStatsOmit<ExtArgs> | null
    /**
     * The data used to create many PartnerDailyStats.
     */
    data: PartnerDailyStatsCreateManyInput | PartnerDailyStatsCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PartnerDailyStatsIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * PartnerDailyStats update
   */
  export type PartnerDailyStatsUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PartnerDailyStats
     */
    select?: PartnerDailyStatsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PartnerDailyStats
     */
    omit?: PartnerDailyStatsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PartnerDailyStatsInclude<ExtArgs> | null
    /**
     * The data needed to update a PartnerDailyStats.
     */
    data: XOR<PartnerDailyStatsUpdateInput, PartnerDailyStatsUncheckedUpdateInput>
    /**
     * Choose, which PartnerDailyStats to update.
     */
    where: PartnerDailyStatsWhereUniqueInput
  }

  /**
   * PartnerDailyStats updateMany
   */
  export type PartnerDailyStatsUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update PartnerDailyStats.
     */
    data: XOR<PartnerDailyStatsUpdateManyMutationInput, PartnerDailyStatsUncheckedUpdateManyInput>
    /**
     * Filter which PartnerDailyStats to update
     */
    where?: PartnerDailyStatsWhereInput
    /**
     * Limit how many PartnerDailyStats to update.
     */
    limit?: number
  }

  /**
   * PartnerDailyStats updateManyAndReturn
   */
  export type PartnerDailyStatsUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PartnerDailyStats
     */
    select?: PartnerDailyStatsSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the PartnerDailyStats
     */
    omit?: PartnerDailyStatsOmit<ExtArgs> | null
    /**
     * The data used to update PartnerDailyStats.
     */
    data: XOR<PartnerDailyStatsUpdateManyMutationInput, PartnerDailyStatsUncheckedUpdateManyInput>
    /**
     * Filter which PartnerDailyStats to update
     */
    where?: PartnerDailyStatsWhereInput
    /**
     * Limit how many PartnerDailyStats to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PartnerDailyStatsIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * PartnerDailyStats upsert
   */
  export type PartnerDailyStatsUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PartnerDailyStats
     */
    select?: PartnerDailyStatsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PartnerDailyStats
     */
    omit?: PartnerDailyStatsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PartnerDailyStatsInclude<ExtArgs> | null
    /**
     * The filter to search for the PartnerDailyStats to update in case it exists.
     */
    where: PartnerDailyStatsWhereUniqueInput
    /**
     * In case the PartnerDailyStats found by the `where` argument doesn't exist, create a new PartnerDailyStats with this data.
     */
    create: XOR<PartnerDailyStatsCreateInput, PartnerDailyStatsUncheckedCreateInput>
    /**
     * In case the PartnerDailyStats was found with the provided `where` argument, update it with this data.
     */
    update: XOR<PartnerDailyStatsUpdateInput, PartnerDailyStatsUncheckedUpdateInput>
  }

  /**
   * PartnerDailyStats delete
   */
  export type PartnerDailyStatsDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PartnerDailyStats
     */
    select?: PartnerDailyStatsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PartnerDailyStats
     */
    omit?: PartnerDailyStatsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PartnerDailyStatsInclude<ExtArgs> | null
    /**
     * Filter which PartnerDailyStats to delete.
     */
    where: PartnerDailyStatsWhereUniqueInput
  }

  /**
   * PartnerDailyStats deleteMany
   */
  export type PartnerDailyStatsDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which PartnerDailyStats to delete
     */
    where?: PartnerDailyStatsWhereInput
    /**
     * Limit how many PartnerDailyStats to delete.
     */
    limit?: number
  }

  /**
   * PartnerDailyStats without action
   */
  export type PartnerDailyStatsDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PartnerDailyStats
     */
    select?: PartnerDailyStatsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PartnerDailyStats
     */
    omit?: PartnerDailyStatsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PartnerDailyStatsInclude<ExtArgs> | null
  }


  /**
   * Model PartnerRevenue
   */

  export type AggregatePartnerRevenue = {
    _count: PartnerRevenueCountAggregateOutputType | null
    _avg: PartnerRevenueAvgAggregateOutputType | null
    _sum: PartnerRevenueSumAggregateOutputType | null
    _min: PartnerRevenueMinAggregateOutputType | null
    _max: PartnerRevenueMaxAggregateOutputType | null
  }

  export type PartnerRevenueAvgAggregateOutputType = {
    orderAmount: number | null
    deliveryFee: number | null
    platformFee: number | null
    netRevenue: number | null
  }

  export type PartnerRevenueSumAggregateOutputType = {
    orderAmount: number | null
    deliveryFee: number | null
    platformFee: number | null
    netRevenue: number | null
  }

  export type PartnerRevenueMinAggregateOutputType = {
    id: string | null
    partnerId: string | null
    orderId: string | null
    orderAmount: number | null
    deliveryFee: number | null
    platformFee: number | null
    netRevenue: number | null
    status: string | null
    processedAt: Date | null
    periodStart: Date | null
    periodEnd: Date | null
    periodType: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type PartnerRevenueMaxAggregateOutputType = {
    id: string | null
    partnerId: string | null
    orderId: string | null
    orderAmount: number | null
    deliveryFee: number | null
    platformFee: number | null
    netRevenue: number | null
    status: string | null
    processedAt: Date | null
    periodStart: Date | null
    periodEnd: Date | null
    periodType: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type PartnerRevenueCountAggregateOutputType = {
    id: number
    partnerId: number
    orderId: number
    orderAmount: number
    deliveryFee: number
    platformFee: number
    netRevenue: number
    status: number
    processedAt: number
    periodStart: number
    periodEnd: number
    periodType: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type PartnerRevenueAvgAggregateInputType = {
    orderAmount?: true
    deliveryFee?: true
    platformFee?: true
    netRevenue?: true
  }

  export type PartnerRevenueSumAggregateInputType = {
    orderAmount?: true
    deliveryFee?: true
    platformFee?: true
    netRevenue?: true
  }

  export type PartnerRevenueMinAggregateInputType = {
    id?: true
    partnerId?: true
    orderId?: true
    orderAmount?: true
    deliveryFee?: true
    platformFee?: true
    netRevenue?: true
    status?: true
    processedAt?: true
    periodStart?: true
    periodEnd?: true
    periodType?: true
    createdAt?: true
    updatedAt?: true
  }

  export type PartnerRevenueMaxAggregateInputType = {
    id?: true
    partnerId?: true
    orderId?: true
    orderAmount?: true
    deliveryFee?: true
    platformFee?: true
    netRevenue?: true
    status?: true
    processedAt?: true
    periodStart?: true
    periodEnd?: true
    periodType?: true
    createdAt?: true
    updatedAt?: true
  }

  export type PartnerRevenueCountAggregateInputType = {
    id?: true
    partnerId?: true
    orderId?: true
    orderAmount?: true
    deliveryFee?: true
    platformFee?: true
    netRevenue?: true
    status?: true
    processedAt?: true
    periodStart?: true
    periodEnd?: true
    periodType?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type PartnerRevenueAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which PartnerRevenue to aggregate.
     */
    where?: PartnerRevenueWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of PartnerRevenues to fetch.
     */
    orderBy?: PartnerRevenueOrderByWithRelationInput | PartnerRevenueOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: PartnerRevenueWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` PartnerRevenues from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` PartnerRevenues.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned PartnerRevenues
    **/
    _count?: true | PartnerRevenueCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: PartnerRevenueAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: PartnerRevenueSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: PartnerRevenueMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: PartnerRevenueMaxAggregateInputType
  }

  export type GetPartnerRevenueAggregateType<T extends PartnerRevenueAggregateArgs> = {
        [P in keyof T & keyof AggregatePartnerRevenue]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregatePartnerRevenue[P]>
      : GetScalarType<T[P], AggregatePartnerRevenue[P]>
  }




  export type PartnerRevenueGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: PartnerRevenueWhereInput
    orderBy?: PartnerRevenueOrderByWithAggregationInput | PartnerRevenueOrderByWithAggregationInput[]
    by: PartnerRevenueScalarFieldEnum[] | PartnerRevenueScalarFieldEnum
    having?: PartnerRevenueScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: PartnerRevenueCountAggregateInputType | true
    _avg?: PartnerRevenueAvgAggregateInputType
    _sum?: PartnerRevenueSumAggregateInputType
    _min?: PartnerRevenueMinAggregateInputType
    _max?: PartnerRevenueMaxAggregateInputType
  }

  export type PartnerRevenueGroupByOutputType = {
    id: string
    partnerId: string
    orderId: string
    orderAmount: number
    deliveryFee: number
    platformFee: number
    netRevenue: number
    status: string
    processedAt: Date | null
    periodStart: Date
    periodEnd: Date
    periodType: string
    createdAt: Date
    updatedAt: Date
    _count: PartnerRevenueCountAggregateOutputType | null
    _avg: PartnerRevenueAvgAggregateOutputType | null
    _sum: PartnerRevenueSumAggregateOutputType | null
    _min: PartnerRevenueMinAggregateOutputType | null
    _max: PartnerRevenueMaxAggregateOutputType | null
  }

  type GetPartnerRevenueGroupByPayload<T extends PartnerRevenueGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<PartnerRevenueGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof PartnerRevenueGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], PartnerRevenueGroupByOutputType[P]>
            : GetScalarType<T[P], PartnerRevenueGroupByOutputType[P]>
        }
      >
    >


  export type PartnerRevenueSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    partnerId?: boolean
    orderId?: boolean
    orderAmount?: boolean
    deliveryFee?: boolean
    platformFee?: boolean
    netRevenue?: boolean
    status?: boolean
    processedAt?: boolean
    periodStart?: boolean
    periodEnd?: boolean
    periodType?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    partner?: boolean | PartnerDefaultArgs<ExtArgs>
    order?: boolean | OrderDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["partnerRevenue"]>

  export type PartnerRevenueSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    partnerId?: boolean
    orderId?: boolean
    orderAmount?: boolean
    deliveryFee?: boolean
    platformFee?: boolean
    netRevenue?: boolean
    status?: boolean
    processedAt?: boolean
    periodStart?: boolean
    periodEnd?: boolean
    periodType?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    partner?: boolean | PartnerDefaultArgs<ExtArgs>
    order?: boolean | OrderDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["partnerRevenue"]>

  export type PartnerRevenueSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    partnerId?: boolean
    orderId?: boolean
    orderAmount?: boolean
    deliveryFee?: boolean
    platformFee?: boolean
    netRevenue?: boolean
    status?: boolean
    processedAt?: boolean
    periodStart?: boolean
    periodEnd?: boolean
    periodType?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    partner?: boolean | PartnerDefaultArgs<ExtArgs>
    order?: boolean | OrderDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["partnerRevenue"]>

  export type PartnerRevenueSelectScalar = {
    id?: boolean
    partnerId?: boolean
    orderId?: boolean
    orderAmount?: boolean
    deliveryFee?: boolean
    platformFee?: boolean
    netRevenue?: boolean
    status?: boolean
    processedAt?: boolean
    periodStart?: boolean
    periodEnd?: boolean
    periodType?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type PartnerRevenueOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "partnerId" | "orderId" | "orderAmount" | "deliveryFee" | "platformFee" | "netRevenue" | "status" | "processedAt" | "periodStart" | "periodEnd" | "periodType" | "createdAt" | "updatedAt", ExtArgs["result"]["partnerRevenue"]>
  export type PartnerRevenueInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    partner?: boolean | PartnerDefaultArgs<ExtArgs>
    order?: boolean | OrderDefaultArgs<ExtArgs>
  }
  export type PartnerRevenueIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    partner?: boolean | PartnerDefaultArgs<ExtArgs>
    order?: boolean | OrderDefaultArgs<ExtArgs>
  }
  export type PartnerRevenueIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    partner?: boolean | PartnerDefaultArgs<ExtArgs>
    order?: boolean | OrderDefaultArgs<ExtArgs>
  }

  export type $PartnerRevenuePayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "PartnerRevenue"
    objects: {
      partner: Prisma.$PartnerPayload<ExtArgs>
      order: Prisma.$OrderPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      partnerId: string
      orderId: string
      orderAmount: number
      deliveryFee: number
      platformFee: number
      netRevenue: number
      status: string
      processedAt: Date | null
      periodStart: Date
      periodEnd: Date
      periodType: string
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["partnerRevenue"]>
    composites: {}
  }

  type PartnerRevenueGetPayload<S extends boolean | null | undefined | PartnerRevenueDefaultArgs> = $Result.GetResult<Prisma.$PartnerRevenuePayload, S>

  type PartnerRevenueCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<PartnerRevenueFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: PartnerRevenueCountAggregateInputType | true
    }

  export interface PartnerRevenueDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['PartnerRevenue'], meta: { name: 'PartnerRevenue' } }
    /**
     * Find zero or one PartnerRevenue that matches the filter.
     * @param {PartnerRevenueFindUniqueArgs} args - Arguments to find a PartnerRevenue
     * @example
     * // Get one PartnerRevenue
     * const partnerRevenue = await prisma.partnerRevenue.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends PartnerRevenueFindUniqueArgs>(args: SelectSubset<T, PartnerRevenueFindUniqueArgs<ExtArgs>>): Prisma__PartnerRevenueClient<$Result.GetResult<Prisma.$PartnerRevenuePayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one PartnerRevenue that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {PartnerRevenueFindUniqueOrThrowArgs} args - Arguments to find a PartnerRevenue
     * @example
     * // Get one PartnerRevenue
     * const partnerRevenue = await prisma.partnerRevenue.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends PartnerRevenueFindUniqueOrThrowArgs>(args: SelectSubset<T, PartnerRevenueFindUniqueOrThrowArgs<ExtArgs>>): Prisma__PartnerRevenueClient<$Result.GetResult<Prisma.$PartnerRevenuePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first PartnerRevenue that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PartnerRevenueFindFirstArgs} args - Arguments to find a PartnerRevenue
     * @example
     * // Get one PartnerRevenue
     * const partnerRevenue = await prisma.partnerRevenue.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends PartnerRevenueFindFirstArgs>(args?: SelectSubset<T, PartnerRevenueFindFirstArgs<ExtArgs>>): Prisma__PartnerRevenueClient<$Result.GetResult<Prisma.$PartnerRevenuePayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first PartnerRevenue that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PartnerRevenueFindFirstOrThrowArgs} args - Arguments to find a PartnerRevenue
     * @example
     * // Get one PartnerRevenue
     * const partnerRevenue = await prisma.partnerRevenue.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends PartnerRevenueFindFirstOrThrowArgs>(args?: SelectSubset<T, PartnerRevenueFindFirstOrThrowArgs<ExtArgs>>): Prisma__PartnerRevenueClient<$Result.GetResult<Prisma.$PartnerRevenuePayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more PartnerRevenues that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PartnerRevenueFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all PartnerRevenues
     * const partnerRevenues = await prisma.partnerRevenue.findMany()
     * 
     * // Get first 10 PartnerRevenues
     * const partnerRevenues = await prisma.partnerRevenue.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const partnerRevenueWithIdOnly = await prisma.partnerRevenue.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends PartnerRevenueFindManyArgs>(args?: SelectSubset<T, PartnerRevenueFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PartnerRevenuePayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a PartnerRevenue.
     * @param {PartnerRevenueCreateArgs} args - Arguments to create a PartnerRevenue.
     * @example
     * // Create one PartnerRevenue
     * const PartnerRevenue = await prisma.partnerRevenue.create({
     *   data: {
     *     // ... data to create a PartnerRevenue
     *   }
     * })
     * 
     */
    create<T extends PartnerRevenueCreateArgs>(args: SelectSubset<T, PartnerRevenueCreateArgs<ExtArgs>>): Prisma__PartnerRevenueClient<$Result.GetResult<Prisma.$PartnerRevenuePayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many PartnerRevenues.
     * @param {PartnerRevenueCreateManyArgs} args - Arguments to create many PartnerRevenues.
     * @example
     * // Create many PartnerRevenues
     * const partnerRevenue = await prisma.partnerRevenue.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends PartnerRevenueCreateManyArgs>(args?: SelectSubset<T, PartnerRevenueCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many PartnerRevenues and returns the data saved in the database.
     * @param {PartnerRevenueCreateManyAndReturnArgs} args - Arguments to create many PartnerRevenues.
     * @example
     * // Create many PartnerRevenues
     * const partnerRevenue = await prisma.partnerRevenue.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many PartnerRevenues and only return the `id`
     * const partnerRevenueWithIdOnly = await prisma.partnerRevenue.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends PartnerRevenueCreateManyAndReturnArgs>(args?: SelectSubset<T, PartnerRevenueCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PartnerRevenuePayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a PartnerRevenue.
     * @param {PartnerRevenueDeleteArgs} args - Arguments to delete one PartnerRevenue.
     * @example
     * // Delete one PartnerRevenue
     * const PartnerRevenue = await prisma.partnerRevenue.delete({
     *   where: {
     *     // ... filter to delete one PartnerRevenue
     *   }
     * })
     * 
     */
    delete<T extends PartnerRevenueDeleteArgs>(args: SelectSubset<T, PartnerRevenueDeleteArgs<ExtArgs>>): Prisma__PartnerRevenueClient<$Result.GetResult<Prisma.$PartnerRevenuePayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one PartnerRevenue.
     * @param {PartnerRevenueUpdateArgs} args - Arguments to update one PartnerRevenue.
     * @example
     * // Update one PartnerRevenue
     * const partnerRevenue = await prisma.partnerRevenue.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends PartnerRevenueUpdateArgs>(args: SelectSubset<T, PartnerRevenueUpdateArgs<ExtArgs>>): Prisma__PartnerRevenueClient<$Result.GetResult<Prisma.$PartnerRevenuePayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more PartnerRevenues.
     * @param {PartnerRevenueDeleteManyArgs} args - Arguments to filter PartnerRevenues to delete.
     * @example
     * // Delete a few PartnerRevenues
     * const { count } = await prisma.partnerRevenue.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends PartnerRevenueDeleteManyArgs>(args?: SelectSubset<T, PartnerRevenueDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more PartnerRevenues.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PartnerRevenueUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many PartnerRevenues
     * const partnerRevenue = await prisma.partnerRevenue.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends PartnerRevenueUpdateManyArgs>(args: SelectSubset<T, PartnerRevenueUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more PartnerRevenues and returns the data updated in the database.
     * @param {PartnerRevenueUpdateManyAndReturnArgs} args - Arguments to update many PartnerRevenues.
     * @example
     * // Update many PartnerRevenues
     * const partnerRevenue = await prisma.partnerRevenue.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more PartnerRevenues and only return the `id`
     * const partnerRevenueWithIdOnly = await prisma.partnerRevenue.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends PartnerRevenueUpdateManyAndReturnArgs>(args: SelectSubset<T, PartnerRevenueUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PartnerRevenuePayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one PartnerRevenue.
     * @param {PartnerRevenueUpsertArgs} args - Arguments to update or create a PartnerRevenue.
     * @example
     * // Update or create a PartnerRevenue
     * const partnerRevenue = await prisma.partnerRevenue.upsert({
     *   create: {
     *     // ... data to create a PartnerRevenue
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the PartnerRevenue we want to update
     *   }
     * })
     */
    upsert<T extends PartnerRevenueUpsertArgs>(args: SelectSubset<T, PartnerRevenueUpsertArgs<ExtArgs>>): Prisma__PartnerRevenueClient<$Result.GetResult<Prisma.$PartnerRevenuePayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of PartnerRevenues.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PartnerRevenueCountArgs} args - Arguments to filter PartnerRevenues to count.
     * @example
     * // Count the number of PartnerRevenues
     * const count = await prisma.partnerRevenue.count({
     *   where: {
     *     // ... the filter for the PartnerRevenues we want to count
     *   }
     * })
    **/
    count<T extends PartnerRevenueCountArgs>(
      args?: Subset<T, PartnerRevenueCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], PartnerRevenueCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a PartnerRevenue.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PartnerRevenueAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends PartnerRevenueAggregateArgs>(args: Subset<T, PartnerRevenueAggregateArgs>): Prisma.PrismaPromise<GetPartnerRevenueAggregateType<T>>

    /**
     * Group by PartnerRevenue.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PartnerRevenueGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends PartnerRevenueGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: PartnerRevenueGroupByArgs['orderBy'] }
        : { orderBy?: PartnerRevenueGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, PartnerRevenueGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetPartnerRevenueGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the PartnerRevenue model
   */
  readonly fields: PartnerRevenueFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for PartnerRevenue.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__PartnerRevenueClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    partner<T extends PartnerDefaultArgs<ExtArgs> = {}>(args?: Subset<T, PartnerDefaultArgs<ExtArgs>>): Prisma__PartnerClient<$Result.GetResult<Prisma.$PartnerPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    order<T extends OrderDefaultArgs<ExtArgs> = {}>(args?: Subset<T, OrderDefaultArgs<ExtArgs>>): Prisma__OrderClient<$Result.GetResult<Prisma.$OrderPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the PartnerRevenue model
   */
  interface PartnerRevenueFieldRefs {
    readonly id: FieldRef<"PartnerRevenue", 'String'>
    readonly partnerId: FieldRef<"PartnerRevenue", 'String'>
    readonly orderId: FieldRef<"PartnerRevenue", 'String'>
    readonly orderAmount: FieldRef<"PartnerRevenue", 'Float'>
    readonly deliveryFee: FieldRef<"PartnerRevenue", 'Float'>
    readonly platformFee: FieldRef<"PartnerRevenue", 'Float'>
    readonly netRevenue: FieldRef<"PartnerRevenue", 'Float'>
    readonly status: FieldRef<"PartnerRevenue", 'String'>
    readonly processedAt: FieldRef<"PartnerRevenue", 'DateTime'>
    readonly periodStart: FieldRef<"PartnerRevenue", 'DateTime'>
    readonly periodEnd: FieldRef<"PartnerRevenue", 'DateTime'>
    readonly periodType: FieldRef<"PartnerRevenue", 'String'>
    readonly createdAt: FieldRef<"PartnerRevenue", 'DateTime'>
    readonly updatedAt: FieldRef<"PartnerRevenue", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * PartnerRevenue findUnique
   */
  export type PartnerRevenueFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PartnerRevenue
     */
    select?: PartnerRevenueSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PartnerRevenue
     */
    omit?: PartnerRevenueOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PartnerRevenueInclude<ExtArgs> | null
    /**
     * Filter, which PartnerRevenue to fetch.
     */
    where: PartnerRevenueWhereUniqueInput
  }

  /**
   * PartnerRevenue findUniqueOrThrow
   */
  export type PartnerRevenueFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PartnerRevenue
     */
    select?: PartnerRevenueSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PartnerRevenue
     */
    omit?: PartnerRevenueOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PartnerRevenueInclude<ExtArgs> | null
    /**
     * Filter, which PartnerRevenue to fetch.
     */
    where: PartnerRevenueWhereUniqueInput
  }

  /**
   * PartnerRevenue findFirst
   */
  export type PartnerRevenueFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PartnerRevenue
     */
    select?: PartnerRevenueSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PartnerRevenue
     */
    omit?: PartnerRevenueOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PartnerRevenueInclude<ExtArgs> | null
    /**
     * Filter, which PartnerRevenue to fetch.
     */
    where?: PartnerRevenueWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of PartnerRevenues to fetch.
     */
    orderBy?: PartnerRevenueOrderByWithRelationInput | PartnerRevenueOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for PartnerRevenues.
     */
    cursor?: PartnerRevenueWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` PartnerRevenues from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` PartnerRevenues.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of PartnerRevenues.
     */
    distinct?: PartnerRevenueScalarFieldEnum | PartnerRevenueScalarFieldEnum[]
  }

  /**
   * PartnerRevenue findFirstOrThrow
   */
  export type PartnerRevenueFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PartnerRevenue
     */
    select?: PartnerRevenueSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PartnerRevenue
     */
    omit?: PartnerRevenueOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PartnerRevenueInclude<ExtArgs> | null
    /**
     * Filter, which PartnerRevenue to fetch.
     */
    where?: PartnerRevenueWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of PartnerRevenues to fetch.
     */
    orderBy?: PartnerRevenueOrderByWithRelationInput | PartnerRevenueOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for PartnerRevenues.
     */
    cursor?: PartnerRevenueWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` PartnerRevenues from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` PartnerRevenues.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of PartnerRevenues.
     */
    distinct?: PartnerRevenueScalarFieldEnum | PartnerRevenueScalarFieldEnum[]
  }

  /**
   * PartnerRevenue findMany
   */
  export type PartnerRevenueFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PartnerRevenue
     */
    select?: PartnerRevenueSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PartnerRevenue
     */
    omit?: PartnerRevenueOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PartnerRevenueInclude<ExtArgs> | null
    /**
     * Filter, which PartnerRevenues to fetch.
     */
    where?: PartnerRevenueWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of PartnerRevenues to fetch.
     */
    orderBy?: PartnerRevenueOrderByWithRelationInput | PartnerRevenueOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing PartnerRevenues.
     */
    cursor?: PartnerRevenueWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` PartnerRevenues from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` PartnerRevenues.
     */
    skip?: number
    distinct?: PartnerRevenueScalarFieldEnum | PartnerRevenueScalarFieldEnum[]
  }

  /**
   * PartnerRevenue create
   */
  export type PartnerRevenueCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PartnerRevenue
     */
    select?: PartnerRevenueSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PartnerRevenue
     */
    omit?: PartnerRevenueOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PartnerRevenueInclude<ExtArgs> | null
    /**
     * The data needed to create a PartnerRevenue.
     */
    data: XOR<PartnerRevenueCreateInput, PartnerRevenueUncheckedCreateInput>
  }

  /**
   * PartnerRevenue createMany
   */
  export type PartnerRevenueCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many PartnerRevenues.
     */
    data: PartnerRevenueCreateManyInput | PartnerRevenueCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * PartnerRevenue createManyAndReturn
   */
  export type PartnerRevenueCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PartnerRevenue
     */
    select?: PartnerRevenueSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the PartnerRevenue
     */
    omit?: PartnerRevenueOmit<ExtArgs> | null
    /**
     * The data used to create many PartnerRevenues.
     */
    data: PartnerRevenueCreateManyInput | PartnerRevenueCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PartnerRevenueIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * PartnerRevenue update
   */
  export type PartnerRevenueUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PartnerRevenue
     */
    select?: PartnerRevenueSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PartnerRevenue
     */
    omit?: PartnerRevenueOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PartnerRevenueInclude<ExtArgs> | null
    /**
     * The data needed to update a PartnerRevenue.
     */
    data: XOR<PartnerRevenueUpdateInput, PartnerRevenueUncheckedUpdateInput>
    /**
     * Choose, which PartnerRevenue to update.
     */
    where: PartnerRevenueWhereUniqueInput
  }

  /**
   * PartnerRevenue updateMany
   */
  export type PartnerRevenueUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update PartnerRevenues.
     */
    data: XOR<PartnerRevenueUpdateManyMutationInput, PartnerRevenueUncheckedUpdateManyInput>
    /**
     * Filter which PartnerRevenues to update
     */
    where?: PartnerRevenueWhereInput
    /**
     * Limit how many PartnerRevenues to update.
     */
    limit?: number
  }

  /**
   * PartnerRevenue updateManyAndReturn
   */
  export type PartnerRevenueUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PartnerRevenue
     */
    select?: PartnerRevenueSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the PartnerRevenue
     */
    omit?: PartnerRevenueOmit<ExtArgs> | null
    /**
     * The data used to update PartnerRevenues.
     */
    data: XOR<PartnerRevenueUpdateManyMutationInput, PartnerRevenueUncheckedUpdateManyInput>
    /**
     * Filter which PartnerRevenues to update
     */
    where?: PartnerRevenueWhereInput
    /**
     * Limit how many PartnerRevenues to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PartnerRevenueIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * PartnerRevenue upsert
   */
  export type PartnerRevenueUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PartnerRevenue
     */
    select?: PartnerRevenueSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PartnerRevenue
     */
    omit?: PartnerRevenueOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PartnerRevenueInclude<ExtArgs> | null
    /**
     * The filter to search for the PartnerRevenue to update in case it exists.
     */
    where: PartnerRevenueWhereUniqueInput
    /**
     * In case the PartnerRevenue found by the `where` argument doesn't exist, create a new PartnerRevenue with this data.
     */
    create: XOR<PartnerRevenueCreateInput, PartnerRevenueUncheckedCreateInput>
    /**
     * In case the PartnerRevenue was found with the provided `where` argument, update it with this data.
     */
    update: XOR<PartnerRevenueUpdateInput, PartnerRevenueUncheckedUpdateInput>
  }

  /**
   * PartnerRevenue delete
   */
  export type PartnerRevenueDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PartnerRevenue
     */
    select?: PartnerRevenueSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PartnerRevenue
     */
    omit?: PartnerRevenueOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PartnerRevenueInclude<ExtArgs> | null
    /**
     * Filter which PartnerRevenue to delete.
     */
    where: PartnerRevenueWhereUniqueInput
  }

  /**
   * PartnerRevenue deleteMany
   */
  export type PartnerRevenueDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which PartnerRevenues to delete
     */
    where?: PartnerRevenueWhereInput
    /**
     * Limit how many PartnerRevenues to delete.
     */
    limit?: number
  }

  /**
   * PartnerRevenue without action
   */
  export type PartnerRevenueDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PartnerRevenue
     */
    select?: PartnerRevenueSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PartnerRevenue
     */
    omit?: PartnerRevenueOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PartnerRevenueInclude<ExtArgs> | null
  }


  /**
   * Model PlatformRevenue
   */

  export type AggregatePlatformRevenue = {
    _count: PlatformRevenueCountAggregateOutputType | null
    _avg: PlatformRevenueAvgAggregateOutputType | null
    _sum: PlatformRevenueSumAggregateOutputType | null
    _min: PlatformRevenueMinAggregateOutputType | null
    _max: PlatformRevenueMaxAggregateOutputType | null
  }

  export type PlatformRevenueAvgAggregateOutputType = {
    orderAmount: number | null
    platformFee: number | null
    agentPayout: number | null
    netRevenue: number | null
  }

  export type PlatformRevenueSumAggregateOutputType = {
    orderAmount: number | null
    platformFee: number | null
    agentPayout: number | null
    netRevenue: number | null
  }

  export type PlatformRevenueMinAggregateOutputType = {
    id: string | null
    orderId: string | null
    partnerId: string | null
    agentId: string | null
    orderAmount: number | null
    platformFee: number | null
    agentPayout: number | null
    netRevenue: number | null
    revenueType: string | null
    status: string | null
    processedAt: Date | null
    periodStart: Date | null
    periodEnd: Date | null
    periodType: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type PlatformRevenueMaxAggregateOutputType = {
    id: string | null
    orderId: string | null
    partnerId: string | null
    agentId: string | null
    orderAmount: number | null
    platformFee: number | null
    agentPayout: number | null
    netRevenue: number | null
    revenueType: string | null
    status: string | null
    processedAt: Date | null
    periodStart: Date | null
    periodEnd: Date | null
    periodType: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type PlatformRevenueCountAggregateOutputType = {
    id: number
    orderId: number
    partnerId: number
    agentId: number
    orderAmount: number
    platformFee: number
    agentPayout: number
    netRevenue: number
    revenueType: number
    status: number
    processedAt: number
    periodStart: number
    periodEnd: number
    periodType: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type PlatformRevenueAvgAggregateInputType = {
    orderAmount?: true
    platformFee?: true
    agentPayout?: true
    netRevenue?: true
  }

  export type PlatformRevenueSumAggregateInputType = {
    orderAmount?: true
    platformFee?: true
    agentPayout?: true
    netRevenue?: true
  }

  export type PlatformRevenueMinAggregateInputType = {
    id?: true
    orderId?: true
    partnerId?: true
    agentId?: true
    orderAmount?: true
    platformFee?: true
    agentPayout?: true
    netRevenue?: true
    revenueType?: true
    status?: true
    processedAt?: true
    periodStart?: true
    periodEnd?: true
    periodType?: true
    createdAt?: true
    updatedAt?: true
  }

  export type PlatformRevenueMaxAggregateInputType = {
    id?: true
    orderId?: true
    partnerId?: true
    agentId?: true
    orderAmount?: true
    platformFee?: true
    agentPayout?: true
    netRevenue?: true
    revenueType?: true
    status?: true
    processedAt?: true
    periodStart?: true
    periodEnd?: true
    periodType?: true
    createdAt?: true
    updatedAt?: true
  }

  export type PlatformRevenueCountAggregateInputType = {
    id?: true
    orderId?: true
    partnerId?: true
    agentId?: true
    orderAmount?: true
    platformFee?: true
    agentPayout?: true
    netRevenue?: true
    revenueType?: true
    status?: true
    processedAt?: true
    periodStart?: true
    periodEnd?: true
    periodType?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type PlatformRevenueAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which PlatformRevenue to aggregate.
     */
    where?: PlatformRevenueWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of PlatformRevenues to fetch.
     */
    orderBy?: PlatformRevenueOrderByWithRelationInput | PlatformRevenueOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: PlatformRevenueWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` PlatformRevenues from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` PlatformRevenues.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned PlatformRevenues
    **/
    _count?: true | PlatformRevenueCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: PlatformRevenueAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: PlatformRevenueSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: PlatformRevenueMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: PlatformRevenueMaxAggregateInputType
  }

  export type GetPlatformRevenueAggregateType<T extends PlatformRevenueAggregateArgs> = {
        [P in keyof T & keyof AggregatePlatformRevenue]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregatePlatformRevenue[P]>
      : GetScalarType<T[P], AggregatePlatformRevenue[P]>
  }




  export type PlatformRevenueGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: PlatformRevenueWhereInput
    orderBy?: PlatformRevenueOrderByWithAggregationInput | PlatformRevenueOrderByWithAggregationInput[]
    by: PlatformRevenueScalarFieldEnum[] | PlatformRevenueScalarFieldEnum
    having?: PlatformRevenueScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: PlatformRevenueCountAggregateInputType | true
    _avg?: PlatformRevenueAvgAggregateInputType
    _sum?: PlatformRevenueSumAggregateInputType
    _min?: PlatformRevenueMinAggregateInputType
    _max?: PlatformRevenueMaxAggregateInputType
  }

  export type PlatformRevenueGroupByOutputType = {
    id: string
    orderId: string
    partnerId: string
    agentId: string | null
    orderAmount: number
    platformFee: number
    agentPayout: number
    netRevenue: number
    revenueType: string
    status: string
    processedAt: Date | null
    periodStart: Date
    periodEnd: Date
    periodType: string
    createdAt: Date
    updatedAt: Date
    _count: PlatformRevenueCountAggregateOutputType | null
    _avg: PlatformRevenueAvgAggregateOutputType | null
    _sum: PlatformRevenueSumAggregateOutputType | null
    _min: PlatformRevenueMinAggregateOutputType | null
    _max: PlatformRevenueMaxAggregateOutputType | null
  }

  type GetPlatformRevenueGroupByPayload<T extends PlatformRevenueGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<PlatformRevenueGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof PlatformRevenueGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], PlatformRevenueGroupByOutputType[P]>
            : GetScalarType<T[P], PlatformRevenueGroupByOutputType[P]>
        }
      >
    >


  export type PlatformRevenueSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    orderId?: boolean
    partnerId?: boolean
    agentId?: boolean
    orderAmount?: boolean
    platformFee?: boolean
    agentPayout?: boolean
    netRevenue?: boolean
    revenueType?: boolean
    status?: boolean
    processedAt?: boolean
    periodStart?: boolean
    periodEnd?: boolean
    periodType?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    order?: boolean | OrderDefaultArgs<ExtArgs>
    partner?: boolean | PartnerDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["platformRevenue"]>

  export type PlatformRevenueSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    orderId?: boolean
    partnerId?: boolean
    agentId?: boolean
    orderAmount?: boolean
    platformFee?: boolean
    agentPayout?: boolean
    netRevenue?: boolean
    revenueType?: boolean
    status?: boolean
    processedAt?: boolean
    periodStart?: boolean
    periodEnd?: boolean
    periodType?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    order?: boolean | OrderDefaultArgs<ExtArgs>
    partner?: boolean | PartnerDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["platformRevenue"]>

  export type PlatformRevenueSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    orderId?: boolean
    partnerId?: boolean
    agentId?: boolean
    orderAmount?: boolean
    platformFee?: boolean
    agentPayout?: boolean
    netRevenue?: boolean
    revenueType?: boolean
    status?: boolean
    processedAt?: boolean
    periodStart?: boolean
    periodEnd?: boolean
    periodType?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    order?: boolean | OrderDefaultArgs<ExtArgs>
    partner?: boolean | PartnerDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["platformRevenue"]>

  export type PlatformRevenueSelectScalar = {
    id?: boolean
    orderId?: boolean
    partnerId?: boolean
    agentId?: boolean
    orderAmount?: boolean
    platformFee?: boolean
    agentPayout?: boolean
    netRevenue?: boolean
    revenueType?: boolean
    status?: boolean
    processedAt?: boolean
    periodStart?: boolean
    periodEnd?: boolean
    periodType?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type PlatformRevenueOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "orderId" | "partnerId" | "agentId" | "orderAmount" | "platformFee" | "agentPayout" | "netRevenue" | "revenueType" | "status" | "processedAt" | "periodStart" | "periodEnd" | "periodType" | "createdAt" | "updatedAt", ExtArgs["result"]["platformRevenue"]>
  export type PlatformRevenueInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    order?: boolean | OrderDefaultArgs<ExtArgs>
    partner?: boolean | PartnerDefaultArgs<ExtArgs>
  }
  export type PlatformRevenueIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    order?: boolean | OrderDefaultArgs<ExtArgs>
    partner?: boolean | PartnerDefaultArgs<ExtArgs>
  }
  export type PlatformRevenueIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    order?: boolean | OrderDefaultArgs<ExtArgs>
    partner?: boolean | PartnerDefaultArgs<ExtArgs>
  }

  export type $PlatformRevenuePayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "PlatformRevenue"
    objects: {
      order: Prisma.$OrderPayload<ExtArgs>
      partner: Prisma.$PartnerPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      orderId: string
      partnerId: string
      agentId: string | null
      orderAmount: number
      platformFee: number
      agentPayout: number
      netRevenue: number
      revenueType: string
      status: string
      processedAt: Date | null
      periodStart: Date
      periodEnd: Date
      periodType: string
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["platformRevenue"]>
    composites: {}
  }

  type PlatformRevenueGetPayload<S extends boolean | null | undefined | PlatformRevenueDefaultArgs> = $Result.GetResult<Prisma.$PlatformRevenuePayload, S>

  type PlatformRevenueCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<PlatformRevenueFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: PlatformRevenueCountAggregateInputType | true
    }

  export interface PlatformRevenueDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['PlatformRevenue'], meta: { name: 'PlatformRevenue' } }
    /**
     * Find zero or one PlatformRevenue that matches the filter.
     * @param {PlatformRevenueFindUniqueArgs} args - Arguments to find a PlatformRevenue
     * @example
     * // Get one PlatformRevenue
     * const platformRevenue = await prisma.platformRevenue.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends PlatformRevenueFindUniqueArgs>(args: SelectSubset<T, PlatformRevenueFindUniqueArgs<ExtArgs>>): Prisma__PlatformRevenueClient<$Result.GetResult<Prisma.$PlatformRevenuePayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one PlatformRevenue that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {PlatformRevenueFindUniqueOrThrowArgs} args - Arguments to find a PlatformRevenue
     * @example
     * // Get one PlatformRevenue
     * const platformRevenue = await prisma.platformRevenue.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends PlatformRevenueFindUniqueOrThrowArgs>(args: SelectSubset<T, PlatformRevenueFindUniqueOrThrowArgs<ExtArgs>>): Prisma__PlatformRevenueClient<$Result.GetResult<Prisma.$PlatformRevenuePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first PlatformRevenue that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PlatformRevenueFindFirstArgs} args - Arguments to find a PlatformRevenue
     * @example
     * // Get one PlatformRevenue
     * const platformRevenue = await prisma.platformRevenue.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends PlatformRevenueFindFirstArgs>(args?: SelectSubset<T, PlatformRevenueFindFirstArgs<ExtArgs>>): Prisma__PlatformRevenueClient<$Result.GetResult<Prisma.$PlatformRevenuePayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first PlatformRevenue that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PlatformRevenueFindFirstOrThrowArgs} args - Arguments to find a PlatformRevenue
     * @example
     * // Get one PlatformRevenue
     * const platformRevenue = await prisma.platformRevenue.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends PlatformRevenueFindFirstOrThrowArgs>(args?: SelectSubset<T, PlatformRevenueFindFirstOrThrowArgs<ExtArgs>>): Prisma__PlatformRevenueClient<$Result.GetResult<Prisma.$PlatformRevenuePayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more PlatformRevenues that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PlatformRevenueFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all PlatformRevenues
     * const platformRevenues = await prisma.platformRevenue.findMany()
     * 
     * // Get first 10 PlatformRevenues
     * const platformRevenues = await prisma.platformRevenue.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const platformRevenueWithIdOnly = await prisma.platformRevenue.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends PlatformRevenueFindManyArgs>(args?: SelectSubset<T, PlatformRevenueFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PlatformRevenuePayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a PlatformRevenue.
     * @param {PlatformRevenueCreateArgs} args - Arguments to create a PlatformRevenue.
     * @example
     * // Create one PlatformRevenue
     * const PlatformRevenue = await prisma.platformRevenue.create({
     *   data: {
     *     // ... data to create a PlatformRevenue
     *   }
     * })
     * 
     */
    create<T extends PlatformRevenueCreateArgs>(args: SelectSubset<T, PlatformRevenueCreateArgs<ExtArgs>>): Prisma__PlatformRevenueClient<$Result.GetResult<Prisma.$PlatformRevenuePayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many PlatformRevenues.
     * @param {PlatformRevenueCreateManyArgs} args - Arguments to create many PlatformRevenues.
     * @example
     * // Create many PlatformRevenues
     * const platformRevenue = await prisma.platformRevenue.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends PlatformRevenueCreateManyArgs>(args?: SelectSubset<T, PlatformRevenueCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many PlatformRevenues and returns the data saved in the database.
     * @param {PlatformRevenueCreateManyAndReturnArgs} args - Arguments to create many PlatformRevenues.
     * @example
     * // Create many PlatformRevenues
     * const platformRevenue = await prisma.platformRevenue.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many PlatformRevenues and only return the `id`
     * const platformRevenueWithIdOnly = await prisma.platformRevenue.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends PlatformRevenueCreateManyAndReturnArgs>(args?: SelectSubset<T, PlatformRevenueCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PlatformRevenuePayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a PlatformRevenue.
     * @param {PlatformRevenueDeleteArgs} args - Arguments to delete one PlatformRevenue.
     * @example
     * // Delete one PlatformRevenue
     * const PlatformRevenue = await prisma.platformRevenue.delete({
     *   where: {
     *     // ... filter to delete one PlatformRevenue
     *   }
     * })
     * 
     */
    delete<T extends PlatformRevenueDeleteArgs>(args: SelectSubset<T, PlatformRevenueDeleteArgs<ExtArgs>>): Prisma__PlatformRevenueClient<$Result.GetResult<Prisma.$PlatformRevenuePayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one PlatformRevenue.
     * @param {PlatformRevenueUpdateArgs} args - Arguments to update one PlatformRevenue.
     * @example
     * // Update one PlatformRevenue
     * const platformRevenue = await prisma.platformRevenue.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends PlatformRevenueUpdateArgs>(args: SelectSubset<T, PlatformRevenueUpdateArgs<ExtArgs>>): Prisma__PlatformRevenueClient<$Result.GetResult<Prisma.$PlatformRevenuePayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more PlatformRevenues.
     * @param {PlatformRevenueDeleteManyArgs} args - Arguments to filter PlatformRevenues to delete.
     * @example
     * // Delete a few PlatformRevenues
     * const { count } = await prisma.platformRevenue.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends PlatformRevenueDeleteManyArgs>(args?: SelectSubset<T, PlatformRevenueDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more PlatformRevenues.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PlatformRevenueUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many PlatformRevenues
     * const platformRevenue = await prisma.platformRevenue.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends PlatformRevenueUpdateManyArgs>(args: SelectSubset<T, PlatformRevenueUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more PlatformRevenues and returns the data updated in the database.
     * @param {PlatformRevenueUpdateManyAndReturnArgs} args - Arguments to update many PlatformRevenues.
     * @example
     * // Update many PlatformRevenues
     * const platformRevenue = await prisma.platformRevenue.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more PlatformRevenues and only return the `id`
     * const platformRevenueWithIdOnly = await prisma.platformRevenue.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends PlatformRevenueUpdateManyAndReturnArgs>(args: SelectSubset<T, PlatformRevenueUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PlatformRevenuePayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one PlatformRevenue.
     * @param {PlatformRevenueUpsertArgs} args - Arguments to update or create a PlatformRevenue.
     * @example
     * // Update or create a PlatformRevenue
     * const platformRevenue = await prisma.platformRevenue.upsert({
     *   create: {
     *     // ... data to create a PlatformRevenue
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the PlatformRevenue we want to update
     *   }
     * })
     */
    upsert<T extends PlatformRevenueUpsertArgs>(args: SelectSubset<T, PlatformRevenueUpsertArgs<ExtArgs>>): Prisma__PlatformRevenueClient<$Result.GetResult<Prisma.$PlatformRevenuePayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of PlatformRevenues.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PlatformRevenueCountArgs} args - Arguments to filter PlatformRevenues to count.
     * @example
     * // Count the number of PlatformRevenues
     * const count = await prisma.platformRevenue.count({
     *   where: {
     *     // ... the filter for the PlatformRevenues we want to count
     *   }
     * })
    **/
    count<T extends PlatformRevenueCountArgs>(
      args?: Subset<T, PlatformRevenueCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], PlatformRevenueCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a PlatformRevenue.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PlatformRevenueAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends PlatformRevenueAggregateArgs>(args: Subset<T, PlatformRevenueAggregateArgs>): Prisma.PrismaPromise<GetPlatformRevenueAggregateType<T>>

    /**
     * Group by PlatformRevenue.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PlatformRevenueGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends PlatformRevenueGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: PlatformRevenueGroupByArgs['orderBy'] }
        : { orderBy?: PlatformRevenueGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, PlatformRevenueGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetPlatformRevenueGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the PlatformRevenue model
   */
  readonly fields: PlatformRevenueFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for PlatformRevenue.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__PlatformRevenueClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    order<T extends OrderDefaultArgs<ExtArgs> = {}>(args?: Subset<T, OrderDefaultArgs<ExtArgs>>): Prisma__OrderClient<$Result.GetResult<Prisma.$OrderPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    partner<T extends PartnerDefaultArgs<ExtArgs> = {}>(args?: Subset<T, PartnerDefaultArgs<ExtArgs>>): Prisma__PartnerClient<$Result.GetResult<Prisma.$PartnerPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the PlatformRevenue model
   */
  interface PlatformRevenueFieldRefs {
    readonly id: FieldRef<"PlatformRevenue", 'String'>
    readonly orderId: FieldRef<"PlatformRevenue", 'String'>
    readonly partnerId: FieldRef<"PlatformRevenue", 'String'>
    readonly agentId: FieldRef<"PlatformRevenue", 'String'>
    readonly orderAmount: FieldRef<"PlatformRevenue", 'Float'>
    readonly platformFee: FieldRef<"PlatformRevenue", 'Float'>
    readonly agentPayout: FieldRef<"PlatformRevenue", 'Float'>
    readonly netRevenue: FieldRef<"PlatformRevenue", 'Float'>
    readonly revenueType: FieldRef<"PlatformRevenue", 'String'>
    readonly status: FieldRef<"PlatformRevenue", 'String'>
    readonly processedAt: FieldRef<"PlatformRevenue", 'DateTime'>
    readonly periodStart: FieldRef<"PlatformRevenue", 'DateTime'>
    readonly periodEnd: FieldRef<"PlatformRevenue", 'DateTime'>
    readonly periodType: FieldRef<"PlatformRevenue", 'String'>
    readonly createdAt: FieldRef<"PlatformRevenue", 'DateTime'>
    readonly updatedAt: FieldRef<"PlatformRevenue", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * PlatformRevenue findUnique
   */
  export type PlatformRevenueFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PlatformRevenue
     */
    select?: PlatformRevenueSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PlatformRevenue
     */
    omit?: PlatformRevenueOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PlatformRevenueInclude<ExtArgs> | null
    /**
     * Filter, which PlatformRevenue to fetch.
     */
    where: PlatformRevenueWhereUniqueInput
  }

  /**
   * PlatformRevenue findUniqueOrThrow
   */
  export type PlatformRevenueFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PlatformRevenue
     */
    select?: PlatformRevenueSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PlatformRevenue
     */
    omit?: PlatformRevenueOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PlatformRevenueInclude<ExtArgs> | null
    /**
     * Filter, which PlatformRevenue to fetch.
     */
    where: PlatformRevenueWhereUniqueInput
  }

  /**
   * PlatformRevenue findFirst
   */
  export type PlatformRevenueFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PlatformRevenue
     */
    select?: PlatformRevenueSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PlatformRevenue
     */
    omit?: PlatformRevenueOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PlatformRevenueInclude<ExtArgs> | null
    /**
     * Filter, which PlatformRevenue to fetch.
     */
    where?: PlatformRevenueWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of PlatformRevenues to fetch.
     */
    orderBy?: PlatformRevenueOrderByWithRelationInput | PlatformRevenueOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for PlatformRevenues.
     */
    cursor?: PlatformRevenueWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` PlatformRevenues from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` PlatformRevenues.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of PlatformRevenues.
     */
    distinct?: PlatformRevenueScalarFieldEnum | PlatformRevenueScalarFieldEnum[]
  }

  /**
   * PlatformRevenue findFirstOrThrow
   */
  export type PlatformRevenueFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PlatformRevenue
     */
    select?: PlatformRevenueSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PlatformRevenue
     */
    omit?: PlatformRevenueOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PlatformRevenueInclude<ExtArgs> | null
    /**
     * Filter, which PlatformRevenue to fetch.
     */
    where?: PlatformRevenueWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of PlatformRevenues to fetch.
     */
    orderBy?: PlatformRevenueOrderByWithRelationInput | PlatformRevenueOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for PlatformRevenues.
     */
    cursor?: PlatformRevenueWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` PlatformRevenues from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` PlatformRevenues.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of PlatformRevenues.
     */
    distinct?: PlatformRevenueScalarFieldEnum | PlatformRevenueScalarFieldEnum[]
  }

  /**
   * PlatformRevenue findMany
   */
  export type PlatformRevenueFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PlatformRevenue
     */
    select?: PlatformRevenueSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PlatformRevenue
     */
    omit?: PlatformRevenueOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PlatformRevenueInclude<ExtArgs> | null
    /**
     * Filter, which PlatformRevenues to fetch.
     */
    where?: PlatformRevenueWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of PlatformRevenues to fetch.
     */
    orderBy?: PlatformRevenueOrderByWithRelationInput | PlatformRevenueOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing PlatformRevenues.
     */
    cursor?: PlatformRevenueWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` PlatformRevenues from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` PlatformRevenues.
     */
    skip?: number
    distinct?: PlatformRevenueScalarFieldEnum | PlatformRevenueScalarFieldEnum[]
  }

  /**
   * PlatformRevenue create
   */
  export type PlatformRevenueCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PlatformRevenue
     */
    select?: PlatformRevenueSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PlatformRevenue
     */
    omit?: PlatformRevenueOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PlatformRevenueInclude<ExtArgs> | null
    /**
     * The data needed to create a PlatformRevenue.
     */
    data: XOR<PlatformRevenueCreateInput, PlatformRevenueUncheckedCreateInput>
  }

  /**
   * PlatformRevenue createMany
   */
  export type PlatformRevenueCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many PlatformRevenues.
     */
    data: PlatformRevenueCreateManyInput | PlatformRevenueCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * PlatformRevenue createManyAndReturn
   */
  export type PlatformRevenueCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PlatformRevenue
     */
    select?: PlatformRevenueSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the PlatformRevenue
     */
    omit?: PlatformRevenueOmit<ExtArgs> | null
    /**
     * The data used to create many PlatformRevenues.
     */
    data: PlatformRevenueCreateManyInput | PlatformRevenueCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PlatformRevenueIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * PlatformRevenue update
   */
  export type PlatformRevenueUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PlatformRevenue
     */
    select?: PlatformRevenueSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PlatformRevenue
     */
    omit?: PlatformRevenueOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PlatformRevenueInclude<ExtArgs> | null
    /**
     * The data needed to update a PlatformRevenue.
     */
    data: XOR<PlatformRevenueUpdateInput, PlatformRevenueUncheckedUpdateInput>
    /**
     * Choose, which PlatformRevenue to update.
     */
    where: PlatformRevenueWhereUniqueInput
  }

  /**
   * PlatformRevenue updateMany
   */
  export type PlatformRevenueUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update PlatformRevenues.
     */
    data: XOR<PlatformRevenueUpdateManyMutationInput, PlatformRevenueUncheckedUpdateManyInput>
    /**
     * Filter which PlatformRevenues to update
     */
    where?: PlatformRevenueWhereInput
    /**
     * Limit how many PlatformRevenues to update.
     */
    limit?: number
  }

  /**
   * PlatformRevenue updateManyAndReturn
   */
  export type PlatformRevenueUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PlatformRevenue
     */
    select?: PlatformRevenueSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the PlatformRevenue
     */
    omit?: PlatformRevenueOmit<ExtArgs> | null
    /**
     * The data used to update PlatformRevenues.
     */
    data: XOR<PlatformRevenueUpdateManyMutationInput, PlatformRevenueUncheckedUpdateManyInput>
    /**
     * Filter which PlatformRevenues to update
     */
    where?: PlatformRevenueWhereInput
    /**
     * Limit how many PlatformRevenues to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PlatformRevenueIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * PlatformRevenue upsert
   */
  export type PlatformRevenueUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PlatformRevenue
     */
    select?: PlatformRevenueSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PlatformRevenue
     */
    omit?: PlatformRevenueOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PlatformRevenueInclude<ExtArgs> | null
    /**
     * The filter to search for the PlatformRevenue to update in case it exists.
     */
    where: PlatformRevenueWhereUniqueInput
    /**
     * In case the PlatformRevenue found by the `where` argument doesn't exist, create a new PlatformRevenue with this data.
     */
    create: XOR<PlatformRevenueCreateInput, PlatformRevenueUncheckedCreateInput>
    /**
     * In case the PlatformRevenue was found with the provided `where` argument, update it with this data.
     */
    update: XOR<PlatformRevenueUpdateInput, PlatformRevenueUncheckedUpdateInput>
  }

  /**
   * PlatformRevenue delete
   */
  export type PlatformRevenueDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PlatformRevenue
     */
    select?: PlatformRevenueSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PlatformRevenue
     */
    omit?: PlatformRevenueOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PlatformRevenueInclude<ExtArgs> | null
    /**
     * Filter which PlatformRevenue to delete.
     */
    where: PlatformRevenueWhereUniqueInput
  }

  /**
   * PlatformRevenue deleteMany
   */
  export type PlatformRevenueDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which PlatformRevenues to delete
     */
    where?: PlatformRevenueWhereInput
    /**
     * Limit how many PlatformRevenues to delete.
     */
    limit?: number
  }

  /**
   * PlatformRevenue without action
   */
  export type PlatformRevenueDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PlatformRevenue
     */
    select?: PlatformRevenueSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PlatformRevenue
     */
    omit?: PlatformRevenueOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PlatformRevenueInclude<ExtArgs> | null
  }


  /**
   * Model AdminWallet
   */

  export type AggregateAdminWallet = {
    _count: AdminWalletCountAggregateOutputType | null
    _avg: AdminWalletAvgAggregateOutputType | null
    _sum: AdminWalletSumAggregateOutputType | null
    _min: AdminWalletMinAggregateOutputType | null
    _max: AdminWalletMaxAggregateOutputType | null
  }

  export type AdminWalletAvgAggregateOutputType = {
    balance: number | null
    totalDeposited: number | null
    totalPaidOut: number | null
  }

  export type AdminWalletSumAggregateOutputType = {
    balance: number | null
    totalDeposited: number | null
    totalPaidOut: number | null
  }

  export type AdminWalletMinAggregateOutputType = {
    id: string | null
    balance: number | null
    totalDeposited: number | null
    totalPaidOut: number | null
    lastUpdated: Date | null
    createdAt: Date | null
  }

  export type AdminWalletMaxAggregateOutputType = {
    id: string | null
    balance: number | null
    totalDeposited: number | null
    totalPaidOut: number | null
    lastUpdated: Date | null
    createdAt: Date | null
  }

  export type AdminWalletCountAggregateOutputType = {
    id: number
    balance: number
    totalDeposited: number
    totalPaidOut: number
    lastUpdated: number
    createdAt: number
    _all: number
  }


  export type AdminWalletAvgAggregateInputType = {
    balance?: true
    totalDeposited?: true
    totalPaidOut?: true
  }

  export type AdminWalletSumAggregateInputType = {
    balance?: true
    totalDeposited?: true
    totalPaidOut?: true
  }

  export type AdminWalletMinAggregateInputType = {
    id?: true
    balance?: true
    totalDeposited?: true
    totalPaidOut?: true
    lastUpdated?: true
    createdAt?: true
  }

  export type AdminWalletMaxAggregateInputType = {
    id?: true
    balance?: true
    totalDeposited?: true
    totalPaidOut?: true
    lastUpdated?: true
    createdAt?: true
  }

  export type AdminWalletCountAggregateInputType = {
    id?: true
    balance?: true
    totalDeposited?: true
    totalPaidOut?: true
    lastUpdated?: true
    createdAt?: true
    _all?: true
  }

  export type AdminWalletAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which AdminWallet to aggregate.
     */
    where?: AdminWalletWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of AdminWallets to fetch.
     */
    orderBy?: AdminWalletOrderByWithRelationInput | AdminWalletOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: AdminWalletWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` AdminWallets from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` AdminWallets.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned AdminWallets
    **/
    _count?: true | AdminWalletCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: AdminWalletAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: AdminWalletSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: AdminWalletMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: AdminWalletMaxAggregateInputType
  }

  export type GetAdminWalletAggregateType<T extends AdminWalletAggregateArgs> = {
        [P in keyof T & keyof AggregateAdminWallet]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateAdminWallet[P]>
      : GetScalarType<T[P], AggregateAdminWallet[P]>
  }




  export type AdminWalletGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: AdminWalletWhereInput
    orderBy?: AdminWalletOrderByWithAggregationInput | AdminWalletOrderByWithAggregationInput[]
    by: AdminWalletScalarFieldEnum[] | AdminWalletScalarFieldEnum
    having?: AdminWalletScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: AdminWalletCountAggregateInputType | true
    _avg?: AdminWalletAvgAggregateInputType
    _sum?: AdminWalletSumAggregateInputType
    _min?: AdminWalletMinAggregateInputType
    _max?: AdminWalletMaxAggregateInputType
  }

  export type AdminWalletGroupByOutputType = {
    id: string
    balance: number
    totalDeposited: number
    totalPaidOut: number
    lastUpdated: Date
    createdAt: Date
    _count: AdminWalletCountAggregateOutputType | null
    _avg: AdminWalletAvgAggregateOutputType | null
    _sum: AdminWalletSumAggregateOutputType | null
    _min: AdminWalletMinAggregateOutputType | null
    _max: AdminWalletMaxAggregateOutputType | null
  }

  type GetAdminWalletGroupByPayload<T extends AdminWalletGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<AdminWalletGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof AdminWalletGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], AdminWalletGroupByOutputType[P]>
            : GetScalarType<T[P], AdminWalletGroupByOutputType[P]>
        }
      >
    >


  export type AdminWalletSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    balance?: boolean
    totalDeposited?: boolean
    totalPaidOut?: boolean
    lastUpdated?: boolean
    createdAt?: boolean
    transactions?: boolean | AdminWallet$transactionsArgs<ExtArgs>
    _count?: boolean | AdminWalletCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["adminWallet"]>

  export type AdminWalletSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    balance?: boolean
    totalDeposited?: boolean
    totalPaidOut?: boolean
    lastUpdated?: boolean
    createdAt?: boolean
  }, ExtArgs["result"]["adminWallet"]>

  export type AdminWalletSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    balance?: boolean
    totalDeposited?: boolean
    totalPaidOut?: boolean
    lastUpdated?: boolean
    createdAt?: boolean
  }, ExtArgs["result"]["adminWallet"]>

  export type AdminWalletSelectScalar = {
    id?: boolean
    balance?: boolean
    totalDeposited?: boolean
    totalPaidOut?: boolean
    lastUpdated?: boolean
    createdAt?: boolean
  }

  export type AdminWalletOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "balance" | "totalDeposited" | "totalPaidOut" | "lastUpdated" | "createdAt", ExtArgs["result"]["adminWallet"]>
  export type AdminWalletInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    transactions?: boolean | AdminWallet$transactionsArgs<ExtArgs>
    _count?: boolean | AdminWalletCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type AdminWalletIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}
  export type AdminWalletIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}

  export type $AdminWalletPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "AdminWallet"
    objects: {
      transactions: Prisma.$WalletTransactionPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      balance: number
      totalDeposited: number
      totalPaidOut: number
      lastUpdated: Date
      createdAt: Date
    }, ExtArgs["result"]["adminWallet"]>
    composites: {}
  }

  type AdminWalletGetPayload<S extends boolean | null | undefined | AdminWalletDefaultArgs> = $Result.GetResult<Prisma.$AdminWalletPayload, S>

  type AdminWalletCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<AdminWalletFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: AdminWalletCountAggregateInputType | true
    }

  export interface AdminWalletDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['AdminWallet'], meta: { name: 'AdminWallet' } }
    /**
     * Find zero or one AdminWallet that matches the filter.
     * @param {AdminWalletFindUniqueArgs} args - Arguments to find a AdminWallet
     * @example
     * // Get one AdminWallet
     * const adminWallet = await prisma.adminWallet.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends AdminWalletFindUniqueArgs>(args: SelectSubset<T, AdminWalletFindUniqueArgs<ExtArgs>>): Prisma__AdminWalletClient<$Result.GetResult<Prisma.$AdminWalletPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one AdminWallet that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {AdminWalletFindUniqueOrThrowArgs} args - Arguments to find a AdminWallet
     * @example
     * // Get one AdminWallet
     * const adminWallet = await prisma.adminWallet.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends AdminWalletFindUniqueOrThrowArgs>(args: SelectSubset<T, AdminWalletFindUniqueOrThrowArgs<ExtArgs>>): Prisma__AdminWalletClient<$Result.GetResult<Prisma.$AdminWalletPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first AdminWallet that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AdminWalletFindFirstArgs} args - Arguments to find a AdminWallet
     * @example
     * // Get one AdminWallet
     * const adminWallet = await prisma.adminWallet.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends AdminWalletFindFirstArgs>(args?: SelectSubset<T, AdminWalletFindFirstArgs<ExtArgs>>): Prisma__AdminWalletClient<$Result.GetResult<Prisma.$AdminWalletPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first AdminWallet that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AdminWalletFindFirstOrThrowArgs} args - Arguments to find a AdminWallet
     * @example
     * // Get one AdminWallet
     * const adminWallet = await prisma.adminWallet.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends AdminWalletFindFirstOrThrowArgs>(args?: SelectSubset<T, AdminWalletFindFirstOrThrowArgs<ExtArgs>>): Prisma__AdminWalletClient<$Result.GetResult<Prisma.$AdminWalletPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more AdminWallets that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AdminWalletFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all AdminWallets
     * const adminWallets = await prisma.adminWallet.findMany()
     * 
     * // Get first 10 AdminWallets
     * const adminWallets = await prisma.adminWallet.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const adminWalletWithIdOnly = await prisma.adminWallet.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends AdminWalletFindManyArgs>(args?: SelectSubset<T, AdminWalletFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AdminWalletPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a AdminWallet.
     * @param {AdminWalletCreateArgs} args - Arguments to create a AdminWallet.
     * @example
     * // Create one AdminWallet
     * const AdminWallet = await prisma.adminWallet.create({
     *   data: {
     *     // ... data to create a AdminWallet
     *   }
     * })
     * 
     */
    create<T extends AdminWalletCreateArgs>(args: SelectSubset<T, AdminWalletCreateArgs<ExtArgs>>): Prisma__AdminWalletClient<$Result.GetResult<Prisma.$AdminWalletPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many AdminWallets.
     * @param {AdminWalletCreateManyArgs} args - Arguments to create many AdminWallets.
     * @example
     * // Create many AdminWallets
     * const adminWallet = await prisma.adminWallet.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends AdminWalletCreateManyArgs>(args?: SelectSubset<T, AdminWalletCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many AdminWallets and returns the data saved in the database.
     * @param {AdminWalletCreateManyAndReturnArgs} args - Arguments to create many AdminWallets.
     * @example
     * // Create many AdminWallets
     * const adminWallet = await prisma.adminWallet.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many AdminWallets and only return the `id`
     * const adminWalletWithIdOnly = await prisma.adminWallet.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends AdminWalletCreateManyAndReturnArgs>(args?: SelectSubset<T, AdminWalletCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AdminWalletPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a AdminWallet.
     * @param {AdminWalletDeleteArgs} args - Arguments to delete one AdminWallet.
     * @example
     * // Delete one AdminWallet
     * const AdminWallet = await prisma.adminWallet.delete({
     *   where: {
     *     // ... filter to delete one AdminWallet
     *   }
     * })
     * 
     */
    delete<T extends AdminWalletDeleteArgs>(args: SelectSubset<T, AdminWalletDeleteArgs<ExtArgs>>): Prisma__AdminWalletClient<$Result.GetResult<Prisma.$AdminWalletPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one AdminWallet.
     * @param {AdminWalletUpdateArgs} args - Arguments to update one AdminWallet.
     * @example
     * // Update one AdminWallet
     * const adminWallet = await prisma.adminWallet.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends AdminWalletUpdateArgs>(args: SelectSubset<T, AdminWalletUpdateArgs<ExtArgs>>): Prisma__AdminWalletClient<$Result.GetResult<Prisma.$AdminWalletPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more AdminWallets.
     * @param {AdminWalletDeleteManyArgs} args - Arguments to filter AdminWallets to delete.
     * @example
     * // Delete a few AdminWallets
     * const { count } = await prisma.adminWallet.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends AdminWalletDeleteManyArgs>(args?: SelectSubset<T, AdminWalletDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more AdminWallets.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AdminWalletUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many AdminWallets
     * const adminWallet = await prisma.adminWallet.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends AdminWalletUpdateManyArgs>(args: SelectSubset<T, AdminWalletUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more AdminWallets and returns the data updated in the database.
     * @param {AdminWalletUpdateManyAndReturnArgs} args - Arguments to update many AdminWallets.
     * @example
     * // Update many AdminWallets
     * const adminWallet = await prisma.adminWallet.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more AdminWallets and only return the `id`
     * const adminWalletWithIdOnly = await prisma.adminWallet.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends AdminWalletUpdateManyAndReturnArgs>(args: SelectSubset<T, AdminWalletUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AdminWalletPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one AdminWallet.
     * @param {AdminWalletUpsertArgs} args - Arguments to update or create a AdminWallet.
     * @example
     * // Update or create a AdminWallet
     * const adminWallet = await prisma.adminWallet.upsert({
     *   create: {
     *     // ... data to create a AdminWallet
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the AdminWallet we want to update
     *   }
     * })
     */
    upsert<T extends AdminWalletUpsertArgs>(args: SelectSubset<T, AdminWalletUpsertArgs<ExtArgs>>): Prisma__AdminWalletClient<$Result.GetResult<Prisma.$AdminWalletPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of AdminWallets.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AdminWalletCountArgs} args - Arguments to filter AdminWallets to count.
     * @example
     * // Count the number of AdminWallets
     * const count = await prisma.adminWallet.count({
     *   where: {
     *     // ... the filter for the AdminWallets we want to count
     *   }
     * })
    **/
    count<T extends AdminWalletCountArgs>(
      args?: Subset<T, AdminWalletCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], AdminWalletCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a AdminWallet.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AdminWalletAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends AdminWalletAggregateArgs>(args: Subset<T, AdminWalletAggregateArgs>): Prisma.PrismaPromise<GetAdminWalletAggregateType<T>>

    /**
     * Group by AdminWallet.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AdminWalletGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends AdminWalletGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: AdminWalletGroupByArgs['orderBy'] }
        : { orderBy?: AdminWalletGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, AdminWalletGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetAdminWalletGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the AdminWallet model
   */
  readonly fields: AdminWalletFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for AdminWallet.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__AdminWalletClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    transactions<T extends AdminWallet$transactionsArgs<ExtArgs> = {}>(args?: Subset<T, AdminWallet$transactionsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$WalletTransactionPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the AdminWallet model
   */
  interface AdminWalletFieldRefs {
    readonly id: FieldRef<"AdminWallet", 'String'>
    readonly balance: FieldRef<"AdminWallet", 'Float'>
    readonly totalDeposited: FieldRef<"AdminWallet", 'Float'>
    readonly totalPaidOut: FieldRef<"AdminWallet", 'Float'>
    readonly lastUpdated: FieldRef<"AdminWallet", 'DateTime'>
    readonly createdAt: FieldRef<"AdminWallet", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * AdminWallet findUnique
   */
  export type AdminWalletFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AdminWallet
     */
    select?: AdminWalletSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AdminWallet
     */
    omit?: AdminWalletOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AdminWalletInclude<ExtArgs> | null
    /**
     * Filter, which AdminWallet to fetch.
     */
    where: AdminWalletWhereUniqueInput
  }

  /**
   * AdminWallet findUniqueOrThrow
   */
  export type AdminWalletFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AdminWallet
     */
    select?: AdminWalletSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AdminWallet
     */
    omit?: AdminWalletOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AdminWalletInclude<ExtArgs> | null
    /**
     * Filter, which AdminWallet to fetch.
     */
    where: AdminWalletWhereUniqueInput
  }

  /**
   * AdminWallet findFirst
   */
  export type AdminWalletFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AdminWallet
     */
    select?: AdminWalletSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AdminWallet
     */
    omit?: AdminWalletOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AdminWalletInclude<ExtArgs> | null
    /**
     * Filter, which AdminWallet to fetch.
     */
    where?: AdminWalletWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of AdminWallets to fetch.
     */
    orderBy?: AdminWalletOrderByWithRelationInput | AdminWalletOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for AdminWallets.
     */
    cursor?: AdminWalletWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` AdminWallets from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` AdminWallets.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of AdminWallets.
     */
    distinct?: AdminWalletScalarFieldEnum | AdminWalletScalarFieldEnum[]
  }

  /**
   * AdminWallet findFirstOrThrow
   */
  export type AdminWalletFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AdminWallet
     */
    select?: AdminWalletSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AdminWallet
     */
    omit?: AdminWalletOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AdminWalletInclude<ExtArgs> | null
    /**
     * Filter, which AdminWallet to fetch.
     */
    where?: AdminWalletWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of AdminWallets to fetch.
     */
    orderBy?: AdminWalletOrderByWithRelationInput | AdminWalletOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for AdminWallets.
     */
    cursor?: AdminWalletWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` AdminWallets from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` AdminWallets.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of AdminWallets.
     */
    distinct?: AdminWalletScalarFieldEnum | AdminWalletScalarFieldEnum[]
  }

  /**
   * AdminWallet findMany
   */
  export type AdminWalletFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AdminWallet
     */
    select?: AdminWalletSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AdminWallet
     */
    omit?: AdminWalletOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AdminWalletInclude<ExtArgs> | null
    /**
     * Filter, which AdminWallets to fetch.
     */
    where?: AdminWalletWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of AdminWallets to fetch.
     */
    orderBy?: AdminWalletOrderByWithRelationInput | AdminWalletOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing AdminWallets.
     */
    cursor?: AdminWalletWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` AdminWallets from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` AdminWallets.
     */
    skip?: number
    distinct?: AdminWalletScalarFieldEnum | AdminWalletScalarFieldEnum[]
  }

  /**
   * AdminWallet create
   */
  export type AdminWalletCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AdminWallet
     */
    select?: AdminWalletSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AdminWallet
     */
    omit?: AdminWalletOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AdminWalletInclude<ExtArgs> | null
    /**
     * The data needed to create a AdminWallet.
     */
    data?: XOR<AdminWalletCreateInput, AdminWalletUncheckedCreateInput>
  }

  /**
   * AdminWallet createMany
   */
  export type AdminWalletCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many AdminWallets.
     */
    data: AdminWalletCreateManyInput | AdminWalletCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * AdminWallet createManyAndReturn
   */
  export type AdminWalletCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AdminWallet
     */
    select?: AdminWalletSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the AdminWallet
     */
    omit?: AdminWalletOmit<ExtArgs> | null
    /**
     * The data used to create many AdminWallets.
     */
    data: AdminWalletCreateManyInput | AdminWalletCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * AdminWallet update
   */
  export type AdminWalletUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AdminWallet
     */
    select?: AdminWalletSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AdminWallet
     */
    omit?: AdminWalletOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AdminWalletInclude<ExtArgs> | null
    /**
     * The data needed to update a AdminWallet.
     */
    data: XOR<AdminWalletUpdateInput, AdminWalletUncheckedUpdateInput>
    /**
     * Choose, which AdminWallet to update.
     */
    where: AdminWalletWhereUniqueInput
  }

  /**
   * AdminWallet updateMany
   */
  export type AdminWalletUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update AdminWallets.
     */
    data: XOR<AdminWalletUpdateManyMutationInput, AdminWalletUncheckedUpdateManyInput>
    /**
     * Filter which AdminWallets to update
     */
    where?: AdminWalletWhereInput
    /**
     * Limit how many AdminWallets to update.
     */
    limit?: number
  }

  /**
   * AdminWallet updateManyAndReturn
   */
  export type AdminWalletUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AdminWallet
     */
    select?: AdminWalletSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the AdminWallet
     */
    omit?: AdminWalletOmit<ExtArgs> | null
    /**
     * The data used to update AdminWallets.
     */
    data: XOR<AdminWalletUpdateManyMutationInput, AdminWalletUncheckedUpdateManyInput>
    /**
     * Filter which AdminWallets to update
     */
    where?: AdminWalletWhereInput
    /**
     * Limit how many AdminWallets to update.
     */
    limit?: number
  }

  /**
   * AdminWallet upsert
   */
  export type AdminWalletUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AdminWallet
     */
    select?: AdminWalletSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AdminWallet
     */
    omit?: AdminWalletOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AdminWalletInclude<ExtArgs> | null
    /**
     * The filter to search for the AdminWallet to update in case it exists.
     */
    where: AdminWalletWhereUniqueInput
    /**
     * In case the AdminWallet found by the `where` argument doesn't exist, create a new AdminWallet with this data.
     */
    create: XOR<AdminWalletCreateInput, AdminWalletUncheckedCreateInput>
    /**
     * In case the AdminWallet was found with the provided `where` argument, update it with this data.
     */
    update: XOR<AdminWalletUpdateInput, AdminWalletUncheckedUpdateInput>
  }

  /**
   * AdminWallet delete
   */
  export type AdminWalletDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AdminWallet
     */
    select?: AdminWalletSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AdminWallet
     */
    omit?: AdminWalletOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AdminWalletInclude<ExtArgs> | null
    /**
     * Filter which AdminWallet to delete.
     */
    where: AdminWalletWhereUniqueInput
  }

  /**
   * AdminWallet deleteMany
   */
  export type AdminWalletDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which AdminWallets to delete
     */
    where?: AdminWalletWhereInput
    /**
     * Limit how many AdminWallets to delete.
     */
    limit?: number
  }

  /**
   * AdminWallet.transactions
   */
  export type AdminWallet$transactionsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WalletTransaction
     */
    select?: WalletTransactionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the WalletTransaction
     */
    omit?: WalletTransactionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WalletTransactionInclude<ExtArgs> | null
    where?: WalletTransactionWhereInput
    orderBy?: WalletTransactionOrderByWithRelationInput | WalletTransactionOrderByWithRelationInput[]
    cursor?: WalletTransactionWhereUniqueInput
    take?: number
    skip?: number
    distinct?: WalletTransactionScalarFieldEnum | WalletTransactionScalarFieldEnum[]
  }

  /**
   * AdminWallet without action
   */
  export type AdminWalletDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AdminWallet
     */
    select?: AdminWalletSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AdminWallet
     */
    omit?: AdminWalletOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AdminWalletInclude<ExtArgs> | null
  }


  /**
   * Model AgentWallet
   */

  export type AggregateAgentWallet = {
    _count: AgentWalletCountAggregateOutputType | null
    _avg: AgentWalletAvgAggregateOutputType | null
    _sum: AgentWalletSumAggregateOutputType | null
    _min: AgentWalletMinAggregateOutputType | null
    _max: AgentWalletMaxAggregateOutputType | null
  }

  export type AgentWalletAvgAggregateOutputType = {
    balance: number | null
    totalEarned: number | null
    totalPaidOut: number | null
  }

  export type AgentWalletSumAggregateOutputType = {
    balance: number | null
    totalEarned: number | null
    totalPaidOut: number | null
  }

  export type AgentWalletMinAggregateOutputType = {
    id: string | null
    agentId: string | null
    balance: number | null
    totalEarned: number | null
    totalPaidOut: number | null
    lastPayoutDate: Date | null
    nextPayoutDate: Date | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type AgentWalletMaxAggregateOutputType = {
    id: string | null
    agentId: string | null
    balance: number | null
    totalEarned: number | null
    totalPaidOut: number | null
    lastPayoutDate: Date | null
    nextPayoutDate: Date | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type AgentWalletCountAggregateOutputType = {
    id: number
    agentId: number
    balance: number
    totalEarned: number
    totalPaidOut: number
    lastPayoutDate: number
    nextPayoutDate: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type AgentWalletAvgAggregateInputType = {
    balance?: true
    totalEarned?: true
    totalPaidOut?: true
  }

  export type AgentWalletSumAggregateInputType = {
    balance?: true
    totalEarned?: true
    totalPaidOut?: true
  }

  export type AgentWalletMinAggregateInputType = {
    id?: true
    agentId?: true
    balance?: true
    totalEarned?: true
    totalPaidOut?: true
    lastPayoutDate?: true
    nextPayoutDate?: true
    createdAt?: true
    updatedAt?: true
  }

  export type AgentWalletMaxAggregateInputType = {
    id?: true
    agentId?: true
    balance?: true
    totalEarned?: true
    totalPaidOut?: true
    lastPayoutDate?: true
    nextPayoutDate?: true
    createdAt?: true
    updatedAt?: true
  }

  export type AgentWalletCountAggregateInputType = {
    id?: true
    agentId?: true
    balance?: true
    totalEarned?: true
    totalPaidOut?: true
    lastPayoutDate?: true
    nextPayoutDate?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type AgentWalletAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which AgentWallet to aggregate.
     */
    where?: AgentWalletWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of AgentWallets to fetch.
     */
    orderBy?: AgentWalletOrderByWithRelationInput | AgentWalletOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: AgentWalletWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` AgentWallets from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` AgentWallets.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned AgentWallets
    **/
    _count?: true | AgentWalletCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: AgentWalletAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: AgentWalletSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: AgentWalletMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: AgentWalletMaxAggregateInputType
  }

  export type GetAgentWalletAggregateType<T extends AgentWalletAggregateArgs> = {
        [P in keyof T & keyof AggregateAgentWallet]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateAgentWallet[P]>
      : GetScalarType<T[P], AggregateAgentWallet[P]>
  }




  export type AgentWalletGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: AgentWalletWhereInput
    orderBy?: AgentWalletOrderByWithAggregationInput | AgentWalletOrderByWithAggregationInput[]
    by: AgentWalletScalarFieldEnum[] | AgentWalletScalarFieldEnum
    having?: AgentWalletScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: AgentWalletCountAggregateInputType | true
    _avg?: AgentWalletAvgAggregateInputType
    _sum?: AgentWalletSumAggregateInputType
    _min?: AgentWalletMinAggregateInputType
    _max?: AgentWalletMaxAggregateInputType
  }

  export type AgentWalletGroupByOutputType = {
    id: string
    agentId: string
    balance: number
    totalEarned: number
    totalPaidOut: number
    lastPayoutDate: Date | null
    nextPayoutDate: Date | null
    createdAt: Date
    updatedAt: Date
    _count: AgentWalletCountAggregateOutputType | null
    _avg: AgentWalletAvgAggregateOutputType | null
    _sum: AgentWalletSumAggregateOutputType | null
    _min: AgentWalletMinAggregateOutputType | null
    _max: AgentWalletMaxAggregateOutputType | null
  }

  type GetAgentWalletGroupByPayload<T extends AgentWalletGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<AgentWalletGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof AgentWalletGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], AgentWalletGroupByOutputType[P]>
            : GetScalarType<T[P], AgentWalletGroupByOutputType[P]>
        }
      >
    >


  export type AgentWalletSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    agentId?: boolean
    balance?: boolean
    totalEarned?: boolean
    totalPaidOut?: boolean
    lastPayoutDate?: boolean
    nextPayoutDate?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    agent?: boolean | AgentDefaultArgs<ExtArgs>
    transactions?: boolean | AgentWallet$transactionsArgs<ExtArgs>
    payouts?: boolean | AgentWallet$payoutsArgs<ExtArgs>
    _count?: boolean | AgentWalletCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["agentWallet"]>

  export type AgentWalletSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    agentId?: boolean
    balance?: boolean
    totalEarned?: boolean
    totalPaidOut?: boolean
    lastPayoutDate?: boolean
    nextPayoutDate?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    agent?: boolean | AgentDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["agentWallet"]>

  export type AgentWalletSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    agentId?: boolean
    balance?: boolean
    totalEarned?: boolean
    totalPaidOut?: boolean
    lastPayoutDate?: boolean
    nextPayoutDate?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    agent?: boolean | AgentDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["agentWallet"]>

  export type AgentWalletSelectScalar = {
    id?: boolean
    agentId?: boolean
    balance?: boolean
    totalEarned?: boolean
    totalPaidOut?: boolean
    lastPayoutDate?: boolean
    nextPayoutDate?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type AgentWalletOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "agentId" | "balance" | "totalEarned" | "totalPaidOut" | "lastPayoutDate" | "nextPayoutDate" | "createdAt" | "updatedAt", ExtArgs["result"]["agentWallet"]>
  export type AgentWalletInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    agent?: boolean | AgentDefaultArgs<ExtArgs>
    transactions?: boolean | AgentWallet$transactionsArgs<ExtArgs>
    payouts?: boolean | AgentWallet$payoutsArgs<ExtArgs>
    _count?: boolean | AgentWalletCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type AgentWalletIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    agent?: boolean | AgentDefaultArgs<ExtArgs>
  }
  export type AgentWalletIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    agent?: boolean | AgentDefaultArgs<ExtArgs>
  }

  export type $AgentWalletPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "AgentWallet"
    objects: {
      agent: Prisma.$AgentPayload<ExtArgs>
      transactions: Prisma.$WalletTransactionPayload<ExtArgs>[]
      payouts: Prisma.$WalletPayoutPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      agentId: string
      balance: number
      totalEarned: number
      totalPaidOut: number
      lastPayoutDate: Date | null
      nextPayoutDate: Date | null
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["agentWallet"]>
    composites: {}
  }

  type AgentWalletGetPayload<S extends boolean | null | undefined | AgentWalletDefaultArgs> = $Result.GetResult<Prisma.$AgentWalletPayload, S>

  type AgentWalletCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<AgentWalletFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: AgentWalletCountAggregateInputType | true
    }

  export interface AgentWalletDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['AgentWallet'], meta: { name: 'AgentWallet' } }
    /**
     * Find zero or one AgentWallet that matches the filter.
     * @param {AgentWalletFindUniqueArgs} args - Arguments to find a AgentWallet
     * @example
     * // Get one AgentWallet
     * const agentWallet = await prisma.agentWallet.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends AgentWalletFindUniqueArgs>(args: SelectSubset<T, AgentWalletFindUniqueArgs<ExtArgs>>): Prisma__AgentWalletClient<$Result.GetResult<Prisma.$AgentWalletPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one AgentWallet that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {AgentWalletFindUniqueOrThrowArgs} args - Arguments to find a AgentWallet
     * @example
     * // Get one AgentWallet
     * const agentWallet = await prisma.agentWallet.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends AgentWalletFindUniqueOrThrowArgs>(args: SelectSubset<T, AgentWalletFindUniqueOrThrowArgs<ExtArgs>>): Prisma__AgentWalletClient<$Result.GetResult<Prisma.$AgentWalletPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first AgentWallet that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AgentWalletFindFirstArgs} args - Arguments to find a AgentWallet
     * @example
     * // Get one AgentWallet
     * const agentWallet = await prisma.agentWallet.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends AgentWalletFindFirstArgs>(args?: SelectSubset<T, AgentWalletFindFirstArgs<ExtArgs>>): Prisma__AgentWalletClient<$Result.GetResult<Prisma.$AgentWalletPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first AgentWallet that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AgentWalletFindFirstOrThrowArgs} args - Arguments to find a AgentWallet
     * @example
     * // Get one AgentWallet
     * const agentWallet = await prisma.agentWallet.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends AgentWalletFindFirstOrThrowArgs>(args?: SelectSubset<T, AgentWalletFindFirstOrThrowArgs<ExtArgs>>): Prisma__AgentWalletClient<$Result.GetResult<Prisma.$AgentWalletPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more AgentWallets that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AgentWalletFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all AgentWallets
     * const agentWallets = await prisma.agentWallet.findMany()
     * 
     * // Get first 10 AgentWallets
     * const agentWallets = await prisma.agentWallet.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const agentWalletWithIdOnly = await prisma.agentWallet.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends AgentWalletFindManyArgs>(args?: SelectSubset<T, AgentWalletFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AgentWalletPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a AgentWallet.
     * @param {AgentWalletCreateArgs} args - Arguments to create a AgentWallet.
     * @example
     * // Create one AgentWallet
     * const AgentWallet = await prisma.agentWallet.create({
     *   data: {
     *     // ... data to create a AgentWallet
     *   }
     * })
     * 
     */
    create<T extends AgentWalletCreateArgs>(args: SelectSubset<T, AgentWalletCreateArgs<ExtArgs>>): Prisma__AgentWalletClient<$Result.GetResult<Prisma.$AgentWalletPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many AgentWallets.
     * @param {AgentWalletCreateManyArgs} args - Arguments to create many AgentWallets.
     * @example
     * // Create many AgentWallets
     * const agentWallet = await prisma.agentWallet.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends AgentWalletCreateManyArgs>(args?: SelectSubset<T, AgentWalletCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many AgentWallets and returns the data saved in the database.
     * @param {AgentWalletCreateManyAndReturnArgs} args - Arguments to create many AgentWallets.
     * @example
     * // Create many AgentWallets
     * const agentWallet = await prisma.agentWallet.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many AgentWallets and only return the `id`
     * const agentWalletWithIdOnly = await prisma.agentWallet.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends AgentWalletCreateManyAndReturnArgs>(args?: SelectSubset<T, AgentWalletCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AgentWalletPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a AgentWallet.
     * @param {AgentWalletDeleteArgs} args - Arguments to delete one AgentWallet.
     * @example
     * // Delete one AgentWallet
     * const AgentWallet = await prisma.agentWallet.delete({
     *   where: {
     *     // ... filter to delete one AgentWallet
     *   }
     * })
     * 
     */
    delete<T extends AgentWalletDeleteArgs>(args: SelectSubset<T, AgentWalletDeleteArgs<ExtArgs>>): Prisma__AgentWalletClient<$Result.GetResult<Prisma.$AgentWalletPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one AgentWallet.
     * @param {AgentWalletUpdateArgs} args - Arguments to update one AgentWallet.
     * @example
     * // Update one AgentWallet
     * const agentWallet = await prisma.agentWallet.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends AgentWalletUpdateArgs>(args: SelectSubset<T, AgentWalletUpdateArgs<ExtArgs>>): Prisma__AgentWalletClient<$Result.GetResult<Prisma.$AgentWalletPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more AgentWallets.
     * @param {AgentWalletDeleteManyArgs} args - Arguments to filter AgentWallets to delete.
     * @example
     * // Delete a few AgentWallets
     * const { count } = await prisma.agentWallet.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends AgentWalletDeleteManyArgs>(args?: SelectSubset<T, AgentWalletDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more AgentWallets.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AgentWalletUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many AgentWallets
     * const agentWallet = await prisma.agentWallet.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends AgentWalletUpdateManyArgs>(args: SelectSubset<T, AgentWalletUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more AgentWallets and returns the data updated in the database.
     * @param {AgentWalletUpdateManyAndReturnArgs} args - Arguments to update many AgentWallets.
     * @example
     * // Update many AgentWallets
     * const agentWallet = await prisma.agentWallet.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more AgentWallets and only return the `id`
     * const agentWalletWithIdOnly = await prisma.agentWallet.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends AgentWalletUpdateManyAndReturnArgs>(args: SelectSubset<T, AgentWalletUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AgentWalletPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one AgentWallet.
     * @param {AgentWalletUpsertArgs} args - Arguments to update or create a AgentWallet.
     * @example
     * // Update or create a AgentWallet
     * const agentWallet = await prisma.agentWallet.upsert({
     *   create: {
     *     // ... data to create a AgentWallet
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the AgentWallet we want to update
     *   }
     * })
     */
    upsert<T extends AgentWalletUpsertArgs>(args: SelectSubset<T, AgentWalletUpsertArgs<ExtArgs>>): Prisma__AgentWalletClient<$Result.GetResult<Prisma.$AgentWalletPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of AgentWallets.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AgentWalletCountArgs} args - Arguments to filter AgentWallets to count.
     * @example
     * // Count the number of AgentWallets
     * const count = await prisma.agentWallet.count({
     *   where: {
     *     // ... the filter for the AgentWallets we want to count
     *   }
     * })
    **/
    count<T extends AgentWalletCountArgs>(
      args?: Subset<T, AgentWalletCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], AgentWalletCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a AgentWallet.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AgentWalletAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends AgentWalletAggregateArgs>(args: Subset<T, AgentWalletAggregateArgs>): Prisma.PrismaPromise<GetAgentWalletAggregateType<T>>

    /**
     * Group by AgentWallet.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AgentWalletGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends AgentWalletGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: AgentWalletGroupByArgs['orderBy'] }
        : { orderBy?: AgentWalletGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, AgentWalletGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetAgentWalletGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the AgentWallet model
   */
  readonly fields: AgentWalletFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for AgentWallet.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__AgentWalletClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    agent<T extends AgentDefaultArgs<ExtArgs> = {}>(args?: Subset<T, AgentDefaultArgs<ExtArgs>>): Prisma__AgentClient<$Result.GetResult<Prisma.$AgentPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    transactions<T extends AgentWallet$transactionsArgs<ExtArgs> = {}>(args?: Subset<T, AgentWallet$transactionsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$WalletTransactionPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    payouts<T extends AgentWallet$payoutsArgs<ExtArgs> = {}>(args?: Subset<T, AgentWallet$payoutsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$WalletPayoutPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the AgentWallet model
   */
  interface AgentWalletFieldRefs {
    readonly id: FieldRef<"AgentWallet", 'String'>
    readonly agentId: FieldRef<"AgentWallet", 'String'>
    readonly balance: FieldRef<"AgentWallet", 'Float'>
    readonly totalEarned: FieldRef<"AgentWallet", 'Float'>
    readonly totalPaidOut: FieldRef<"AgentWallet", 'Float'>
    readonly lastPayoutDate: FieldRef<"AgentWallet", 'DateTime'>
    readonly nextPayoutDate: FieldRef<"AgentWallet", 'DateTime'>
    readonly createdAt: FieldRef<"AgentWallet", 'DateTime'>
    readonly updatedAt: FieldRef<"AgentWallet", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * AgentWallet findUnique
   */
  export type AgentWalletFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AgentWallet
     */
    select?: AgentWalletSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AgentWallet
     */
    omit?: AgentWalletOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AgentWalletInclude<ExtArgs> | null
    /**
     * Filter, which AgentWallet to fetch.
     */
    where: AgentWalletWhereUniqueInput
  }

  /**
   * AgentWallet findUniqueOrThrow
   */
  export type AgentWalletFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AgentWallet
     */
    select?: AgentWalletSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AgentWallet
     */
    omit?: AgentWalletOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AgentWalletInclude<ExtArgs> | null
    /**
     * Filter, which AgentWallet to fetch.
     */
    where: AgentWalletWhereUniqueInput
  }

  /**
   * AgentWallet findFirst
   */
  export type AgentWalletFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AgentWallet
     */
    select?: AgentWalletSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AgentWallet
     */
    omit?: AgentWalletOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AgentWalletInclude<ExtArgs> | null
    /**
     * Filter, which AgentWallet to fetch.
     */
    where?: AgentWalletWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of AgentWallets to fetch.
     */
    orderBy?: AgentWalletOrderByWithRelationInput | AgentWalletOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for AgentWallets.
     */
    cursor?: AgentWalletWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` AgentWallets from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` AgentWallets.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of AgentWallets.
     */
    distinct?: AgentWalletScalarFieldEnum | AgentWalletScalarFieldEnum[]
  }

  /**
   * AgentWallet findFirstOrThrow
   */
  export type AgentWalletFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AgentWallet
     */
    select?: AgentWalletSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AgentWallet
     */
    omit?: AgentWalletOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AgentWalletInclude<ExtArgs> | null
    /**
     * Filter, which AgentWallet to fetch.
     */
    where?: AgentWalletWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of AgentWallets to fetch.
     */
    orderBy?: AgentWalletOrderByWithRelationInput | AgentWalletOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for AgentWallets.
     */
    cursor?: AgentWalletWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` AgentWallets from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` AgentWallets.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of AgentWallets.
     */
    distinct?: AgentWalletScalarFieldEnum | AgentWalletScalarFieldEnum[]
  }

  /**
   * AgentWallet findMany
   */
  export type AgentWalletFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AgentWallet
     */
    select?: AgentWalletSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AgentWallet
     */
    omit?: AgentWalletOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AgentWalletInclude<ExtArgs> | null
    /**
     * Filter, which AgentWallets to fetch.
     */
    where?: AgentWalletWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of AgentWallets to fetch.
     */
    orderBy?: AgentWalletOrderByWithRelationInput | AgentWalletOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing AgentWallets.
     */
    cursor?: AgentWalletWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` AgentWallets from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` AgentWallets.
     */
    skip?: number
    distinct?: AgentWalletScalarFieldEnum | AgentWalletScalarFieldEnum[]
  }

  /**
   * AgentWallet create
   */
  export type AgentWalletCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AgentWallet
     */
    select?: AgentWalletSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AgentWallet
     */
    omit?: AgentWalletOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AgentWalletInclude<ExtArgs> | null
    /**
     * The data needed to create a AgentWallet.
     */
    data: XOR<AgentWalletCreateInput, AgentWalletUncheckedCreateInput>
  }

  /**
   * AgentWallet createMany
   */
  export type AgentWalletCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many AgentWallets.
     */
    data: AgentWalletCreateManyInput | AgentWalletCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * AgentWallet createManyAndReturn
   */
  export type AgentWalletCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AgentWallet
     */
    select?: AgentWalletSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the AgentWallet
     */
    omit?: AgentWalletOmit<ExtArgs> | null
    /**
     * The data used to create many AgentWallets.
     */
    data: AgentWalletCreateManyInput | AgentWalletCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AgentWalletIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * AgentWallet update
   */
  export type AgentWalletUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AgentWallet
     */
    select?: AgentWalletSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AgentWallet
     */
    omit?: AgentWalletOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AgentWalletInclude<ExtArgs> | null
    /**
     * The data needed to update a AgentWallet.
     */
    data: XOR<AgentWalletUpdateInput, AgentWalletUncheckedUpdateInput>
    /**
     * Choose, which AgentWallet to update.
     */
    where: AgentWalletWhereUniqueInput
  }

  /**
   * AgentWallet updateMany
   */
  export type AgentWalletUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update AgentWallets.
     */
    data: XOR<AgentWalletUpdateManyMutationInput, AgentWalletUncheckedUpdateManyInput>
    /**
     * Filter which AgentWallets to update
     */
    where?: AgentWalletWhereInput
    /**
     * Limit how many AgentWallets to update.
     */
    limit?: number
  }

  /**
   * AgentWallet updateManyAndReturn
   */
  export type AgentWalletUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AgentWallet
     */
    select?: AgentWalletSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the AgentWallet
     */
    omit?: AgentWalletOmit<ExtArgs> | null
    /**
     * The data used to update AgentWallets.
     */
    data: XOR<AgentWalletUpdateManyMutationInput, AgentWalletUncheckedUpdateManyInput>
    /**
     * Filter which AgentWallets to update
     */
    where?: AgentWalletWhereInput
    /**
     * Limit how many AgentWallets to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AgentWalletIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * AgentWallet upsert
   */
  export type AgentWalletUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AgentWallet
     */
    select?: AgentWalletSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AgentWallet
     */
    omit?: AgentWalletOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AgentWalletInclude<ExtArgs> | null
    /**
     * The filter to search for the AgentWallet to update in case it exists.
     */
    where: AgentWalletWhereUniqueInput
    /**
     * In case the AgentWallet found by the `where` argument doesn't exist, create a new AgentWallet with this data.
     */
    create: XOR<AgentWalletCreateInput, AgentWalletUncheckedCreateInput>
    /**
     * In case the AgentWallet was found with the provided `where` argument, update it with this data.
     */
    update: XOR<AgentWalletUpdateInput, AgentWalletUncheckedUpdateInput>
  }

  /**
   * AgentWallet delete
   */
  export type AgentWalletDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AgentWallet
     */
    select?: AgentWalletSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AgentWallet
     */
    omit?: AgentWalletOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AgentWalletInclude<ExtArgs> | null
    /**
     * Filter which AgentWallet to delete.
     */
    where: AgentWalletWhereUniqueInput
  }

  /**
   * AgentWallet deleteMany
   */
  export type AgentWalletDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which AgentWallets to delete
     */
    where?: AgentWalletWhereInput
    /**
     * Limit how many AgentWallets to delete.
     */
    limit?: number
  }

  /**
   * AgentWallet.transactions
   */
  export type AgentWallet$transactionsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WalletTransaction
     */
    select?: WalletTransactionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the WalletTransaction
     */
    omit?: WalletTransactionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WalletTransactionInclude<ExtArgs> | null
    where?: WalletTransactionWhereInput
    orderBy?: WalletTransactionOrderByWithRelationInput | WalletTransactionOrderByWithRelationInput[]
    cursor?: WalletTransactionWhereUniqueInput
    take?: number
    skip?: number
    distinct?: WalletTransactionScalarFieldEnum | WalletTransactionScalarFieldEnum[]
  }

  /**
   * AgentWallet.payouts
   */
  export type AgentWallet$payoutsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WalletPayout
     */
    select?: WalletPayoutSelect<ExtArgs> | null
    /**
     * Omit specific fields from the WalletPayout
     */
    omit?: WalletPayoutOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WalletPayoutInclude<ExtArgs> | null
    where?: WalletPayoutWhereInput
    orderBy?: WalletPayoutOrderByWithRelationInput | WalletPayoutOrderByWithRelationInput[]
    cursor?: WalletPayoutWhereUniqueInput
    take?: number
    skip?: number
    distinct?: WalletPayoutScalarFieldEnum | WalletPayoutScalarFieldEnum[]
  }

  /**
   * AgentWallet without action
   */
  export type AgentWalletDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AgentWallet
     */
    select?: AgentWalletSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AgentWallet
     */
    omit?: AgentWalletOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AgentWalletInclude<ExtArgs> | null
  }


  /**
   * Model WalletTransaction
   */

  export type AggregateWalletTransaction = {
    _count: WalletTransactionCountAggregateOutputType | null
    _avg: WalletTransactionAvgAggregateOutputType | null
    _sum: WalletTransactionSumAggregateOutputType | null
    _min: WalletTransactionMinAggregateOutputType | null
    _max: WalletTransactionMaxAggregateOutputType | null
  }

  export type WalletTransactionAvgAggregateOutputType = {
    amount: number | null
    balanceBefore: number | null
    balanceAfter: number | null
  }

  export type WalletTransactionSumAggregateOutputType = {
    amount: number | null
    balanceBefore: number | null
    balanceAfter: number | null
  }

  export type WalletTransactionMinAggregateOutputType = {
    id: string | null
    walletType: string | null
    adminWalletId: string | null
    agentWalletId: string | null
    orderId: string | null
    amount: number | null
    type: string | null
    description: string | null
    balanceBefore: number | null
    balanceAfter: number | null
    status: string | null
    createdAt: Date | null
  }

  export type WalletTransactionMaxAggregateOutputType = {
    id: string | null
    walletType: string | null
    adminWalletId: string | null
    agentWalletId: string | null
    orderId: string | null
    amount: number | null
    type: string | null
    description: string | null
    balanceBefore: number | null
    balanceAfter: number | null
    status: string | null
    createdAt: Date | null
  }

  export type WalletTransactionCountAggregateOutputType = {
    id: number
    walletType: number
    adminWalletId: number
    agentWalletId: number
    orderId: number
    amount: number
    type: number
    description: number
    balanceBefore: number
    balanceAfter: number
    status: number
    createdAt: number
    _all: number
  }


  export type WalletTransactionAvgAggregateInputType = {
    amount?: true
    balanceBefore?: true
    balanceAfter?: true
  }

  export type WalletTransactionSumAggregateInputType = {
    amount?: true
    balanceBefore?: true
    balanceAfter?: true
  }

  export type WalletTransactionMinAggregateInputType = {
    id?: true
    walletType?: true
    adminWalletId?: true
    agentWalletId?: true
    orderId?: true
    amount?: true
    type?: true
    description?: true
    balanceBefore?: true
    balanceAfter?: true
    status?: true
    createdAt?: true
  }

  export type WalletTransactionMaxAggregateInputType = {
    id?: true
    walletType?: true
    adminWalletId?: true
    agentWalletId?: true
    orderId?: true
    amount?: true
    type?: true
    description?: true
    balanceBefore?: true
    balanceAfter?: true
    status?: true
    createdAt?: true
  }

  export type WalletTransactionCountAggregateInputType = {
    id?: true
    walletType?: true
    adminWalletId?: true
    agentWalletId?: true
    orderId?: true
    amount?: true
    type?: true
    description?: true
    balanceBefore?: true
    balanceAfter?: true
    status?: true
    createdAt?: true
    _all?: true
  }

  export type WalletTransactionAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which WalletTransaction to aggregate.
     */
    where?: WalletTransactionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of WalletTransactions to fetch.
     */
    orderBy?: WalletTransactionOrderByWithRelationInput | WalletTransactionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: WalletTransactionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` WalletTransactions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` WalletTransactions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned WalletTransactions
    **/
    _count?: true | WalletTransactionCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: WalletTransactionAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: WalletTransactionSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: WalletTransactionMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: WalletTransactionMaxAggregateInputType
  }

  export type GetWalletTransactionAggregateType<T extends WalletTransactionAggregateArgs> = {
        [P in keyof T & keyof AggregateWalletTransaction]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateWalletTransaction[P]>
      : GetScalarType<T[P], AggregateWalletTransaction[P]>
  }




  export type WalletTransactionGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: WalletTransactionWhereInput
    orderBy?: WalletTransactionOrderByWithAggregationInput | WalletTransactionOrderByWithAggregationInput[]
    by: WalletTransactionScalarFieldEnum[] | WalletTransactionScalarFieldEnum
    having?: WalletTransactionScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: WalletTransactionCountAggregateInputType | true
    _avg?: WalletTransactionAvgAggregateInputType
    _sum?: WalletTransactionSumAggregateInputType
    _min?: WalletTransactionMinAggregateInputType
    _max?: WalletTransactionMaxAggregateInputType
  }

  export type WalletTransactionGroupByOutputType = {
    id: string
    walletType: string
    adminWalletId: string | null
    agentWalletId: string | null
    orderId: string | null
    amount: number
    type: string
    description: string | null
    balanceBefore: number
    balanceAfter: number
    status: string
    createdAt: Date
    _count: WalletTransactionCountAggregateOutputType | null
    _avg: WalletTransactionAvgAggregateOutputType | null
    _sum: WalletTransactionSumAggregateOutputType | null
    _min: WalletTransactionMinAggregateOutputType | null
    _max: WalletTransactionMaxAggregateOutputType | null
  }

  type GetWalletTransactionGroupByPayload<T extends WalletTransactionGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<WalletTransactionGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof WalletTransactionGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], WalletTransactionGroupByOutputType[P]>
            : GetScalarType<T[P], WalletTransactionGroupByOutputType[P]>
        }
      >
    >


  export type WalletTransactionSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    walletType?: boolean
    adminWalletId?: boolean
    agentWalletId?: boolean
    orderId?: boolean
    amount?: boolean
    type?: boolean
    description?: boolean
    balanceBefore?: boolean
    balanceAfter?: boolean
    status?: boolean
    createdAt?: boolean
    adminWallet?: boolean | WalletTransaction$adminWalletArgs<ExtArgs>
    agentWallet?: boolean | WalletTransaction$agentWalletArgs<ExtArgs>
    order?: boolean | WalletTransaction$orderArgs<ExtArgs>
  }, ExtArgs["result"]["walletTransaction"]>

  export type WalletTransactionSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    walletType?: boolean
    adminWalletId?: boolean
    agentWalletId?: boolean
    orderId?: boolean
    amount?: boolean
    type?: boolean
    description?: boolean
    balanceBefore?: boolean
    balanceAfter?: boolean
    status?: boolean
    createdAt?: boolean
    adminWallet?: boolean | WalletTransaction$adminWalletArgs<ExtArgs>
    agentWallet?: boolean | WalletTransaction$agentWalletArgs<ExtArgs>
    order?: boolean | WalletTransaction$orderArgs<ExtArgs>
  }, ExtArgs["result"]["walletTransaction"]>

  export type WalletTransactionSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    walletType?: boolean
    adminWalletId?: boolean
    agentWalletId?: boolean
    orderId?: boolean
    amount?: boolean
    type?: boolean
    description?: boolean
    balanceBefore?: boolean
    balanceAfter?: boolean
    status?: boolean
    createdAt?: boolean
    adminWallet?: boolean | WalletTransaction$adminWalletArgs<ExtArgs>
    agentWallet?: boolean | WalletTransaction$agentWalletArgs<ExtArgs>
    order?: boolean | WalletTransaction$orderArgs<ExtArgs>
  }, ExtArgs["result"]["walletTransaction"]>

  export type WalletTransactionSelectScalar = {
    id?: boolean
    walletType?: boolean
    adminWalletId?: boolean
    agentWalletId?: boolean
    orderId?: boolean
    amount?: boolean
    type?: boolean
    description?: boolean
    balanceBefore?: boolean
    balanceAfter?: boolean
    status?: boolean
    createdAt?: boolean
  }

  export type WalletTransactionOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "walletType" | "adminWalletId" | "agentWalletId" | "orderId" | "amount" | "type" | "description" | "balanceBefore" | "balanceAfter" | "status" | "createdAt", ExtArgs["result"]["walletTransaction"]>
  export type WalletTransactionInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    adminWallet?: boolean | WalletTransaction$adminWalletArgs<ExtArgs>
    agentWallet?: boolean | WalletTransaction$agentWalletArgs<ExtArgs>
    order?: boolean | WalletTransaction$orderArgs<ExtArgs>
  }
  export type WalletTransactionIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    adminWallet?: boolean | WalletTransaction$adminWalletArgs<ExtArgs>
    agentWallet?: boolean | WalletTransaction$agentWalletArgs<ExtArgs>
    order?: boolean | WalletTransaction$orderArgs<ExtArgs>
  }
  export type WalletTransactionIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    adminWallet?: boolean | WalletTransaction$adminWalletArgs<ExtArgs>
    agentWallet?: boolean | WalletTransaction$agentWalletArgs<ExtArgs>
    order?: boolean | WalletTransaction$orderArgs<ExtArgs>
  }

  export type $WalletTransactionPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "WalletTransaction"
    objects: {
      adminWallet: Prisma.$AdminWalletPayload<ExtArgs> | null
      agentWallet: Prisma.$AgentWalletPayload<ExtArgs> | null
      order: Prisma.$OrderPayload<ExtArgs> | null
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      walletType: string
      adminWalletId: string | null
      agentWalletId: string | null
      orderId: string | null
      amount: number
      type: string
      description: string | null
      balanceBefore: number
      balanceAfter: number
      status: string
      createdAt: Date
    }, ExtArgs["result"]["walletTransaction"]>
    composites: {}
  }

  type WalletTransactionGetPayload<S extends boolean | null | undefined | WalletTransactionDefaultArgs> = $Result.GetResult<Prisma.$WalletTransactionPayload, S>

  type WalletTransactionCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<WalletTransactionFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: WalletTransactionCountAggregateInputType | true
    }

  export interface WalletTransactionDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['WalletTransaction'], meta: { name: 'WalletTransaction' } }
    /**
     * Find zero or one WalletTransaction that matches the filter.
     * @param {WalletTransactionFindUniqueArgs} args - Arguments to find a WalletTransaction
     * @example
     * // Get one WalletTransaction
     * const walletTransaction = await prisma.walletTransaction.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends WalletTransactionFindUniqueArgs>(args: SelectSubset<T, WalletTransactionFindUniqueArgs<ExtArgs>>): Prisma__WalletTransactionClient<$Result.GetResult<Prisma.$WalletTransactionPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one WalletTransaction that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {WalletTransactionFindUniqueOrThrowArgs} args - Arguments to find a WalletTransaction
     * @example
     * // Get one WalletTransaction
     * const walletTransaction = await prisma.walletTransaction.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends WalletTransactionFindUniqueOrThrowArgs>(args: SelectSubset<T, WalletTransactionFindUniqueOrThrowArgs<ExtArgs>>): Prisma__WalletTransactionClient<$Result.GetResult<Prisma.$WalletTransactionPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first WalletTransaction that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {WalletTransactionFindFirstArgs} args - Arguments to find a WalletTransaction
     * @example
     * // Get one WalletTransaction
     * const walletTransaction = await prisma.walletTransaction.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends WalletTransactionFindFirstArgs>(args?: SelectSubset<T, WalletTransactionFindFirstArgs<ExtArgs>>): Prisma__WalletTransactionClient<$Result.GetResult<Prisma.$WalletTransactionPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first WalletTransaction that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {WalletTransactionFindFirstOrThrowArgs} args - Arguments to find a WalletTransaction
     * @example
     * // Get one WalletTransaction
     * const walletTransaction = await prisma.walletTransaction.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends WalletTransactionFindFirstOrThrowArgs>(args?: SelectSubset<T, WalletTransactionFindFirstOrThrowArgs<ExtArgs>>): Prisma__WalletTransactionClient<$Result.GetResult<Prisma.$WalletTransactionPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more WalletTransactions that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {WalletTransactionFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all WalletTransactions
     * const walletTransactions = await prisma.walletTransaction.findMany()
     * 
     * // Get first 10 WalletTransactions
     * const walletTransactions = await prisma.walletTransaction.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const walletTransactionWithIdOnly = await prisma.walletTransaction.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends WalletTransactionFindManyArgs>(args?: SelectSubset<T, WalletTransactionFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$WalletTransactionPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a WalletTransaction.
     * @param {WalletTransactionCreateArgs} args - Arguments to create a WalletTransaction.
     * @example
     * // Create one WalletTransaction
     * const WalletTransaction = await prisma.walletTransaction.create({
     *   data: {
     *     // ... data to create a WalletTransaction
     *   }
     * })
     * 
     */
    create<T extends WalletTransactionCreateArgs>(args: SelectSubset<T, WalletTransactionCreateArgs<ExtArgs>>): Prisma__WalletTransactionClient<$Result.GetResult<Prisma.$WalletTransactionPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many WalletTransactions.
     * @param {WalletTransactionCreateManyArgs} args - Arguments to create many WalletTransactions.
     * @example
     * // Create many WalletTransactions
     * const walletTransaction = await prisma.walletTransaction.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends WalletTransactionCreateManyArgs>(args?: SelectSubset<T, WalletTransactionCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many WalletTransactions and returns the data saved in the database.
     * @param {WalletTransactionCreateManyAndReturnArgs} args - Arguments to create many WalletTransactions.
     * @example
     * // Create many WalletTransactions
     * const walletTransaction = await prisma.walletTransaction.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many WalletTransactions and only return the `id`
     * const walletTransactionWithIdOnly = await prisma.walletTransaction.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends WalletTransactionCreateManyAndReturnArgs>(args?: SelectSubset<T, WalletTransactionCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$WalletTransactionPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a WalletTransaction.
     * @param {WalletTransactionDeleteArgs} args - Arguments to delete one WalletTransaction.
     * @example
     * // Delete one WalletTransaction
     * const WalletTransaction = await prisma.walletTransaction.delete({
     *   where: {
     *     // ... filter to delete one WalletTransaction
     *   }
     * })
     * 
     */
    delete<T extends WalletTransactionDeleteArgs>(args: SelectSubset<T, WalletTransactionDeleteArgs<ExtArgs>>): Prisma__WalletTransactionClient<$Result.GetResult<Prisma.$WalletTransactionPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one WalletTransaction.
     * @param {WalletTransactionUpdateArgs} args - Arguments to update one WalletTransaction.
     * @example
     * // Update one WalletTransaction
     * const walletTransaction = await prisma.walletTransaction.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends WalletTransactionUpdateArgs>(args: SelectSubset<T, WalletTransactionUpdateArgs<ExtArgs>>): Prisma__WalletTransactionClient<$Result.GetResult<Prisma.$WalletTransactionPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more WalletTransactions.
     * @param {WalletTransactionDeleteManyArgs} args - Arguments to filter WalletTransactions to delete.
     * @example
     * // Delete a few WalletTransactions
     * const { count } = await prisma.walletTransaction.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends WalletTransactionDeleteManyArgs>(args?: SelectSubset<T, WalletTransactionDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more WalletTransactions.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {WalletTransactionUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many WalletTransactions
     * const walletTransaction = await prisma.walletTransaction.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends WalletTransactionUpdateManyArgs>(args: SelectSubset<T, WalletTransactionUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more WalletTransactions and returns the data updated in the database.
     * @param {WalletTransactionUpdateManyAndReturnArgs} args - Arguments to update many WalletTransactions.
     * @example
     * // Update many WalletTransactions
     * const walletTransaction = await prisma.walletTransaction.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more WalletTransactions and only return the `id`
     * const walletTransactionWithIdOnly = await prisma.walletTransaction.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends WalletTransactionUpdateManyAndReturnArgs>(args: SelectSubset<T, WalletTransactionUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$WalletTransactionPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one WalletTransaction.
     * @param {WalletTransactionUpsertArgs} args - Arguments to update or create a WalletTransaction.
     * @example
     * // Update or create a WalletTransaction
     * const walletTransaction = await prisma.walletTransaction.upsert({
     *   create: {
     *     // ... data to create a WalletTransaction
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the WalletTransaction we want to update
     *   }
     * })
     */
    upsert<T extends WalletTransactionUpsertArgs>(args: SelectSubset<T, WalletTransactionUpsertArgs<ExtArgs>>): Prisma__WalletTransactionClient<$Result.GetResult<Prisma.$WalletTransactionPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of WalletTransactions.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {WalletTransactionCountArgs} args - Arguments to filter WalletTransactions to count.
     * @example
     * // Count the number of WalletTransactions
     * const count = await prisma.walletTransaction.count({
     *   where: {
     *     // ... the filter for the WalletTransactions we want to count
     *   }
     * })
    **/
    count<T extends WalletTransactionCountArgs>(
      args?: Subset<T, WalletTransactionCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], WalletTransactionCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a WalletTransaction.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {WalletTransactionAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends WalletTransactionAggregateArgs>(args: Subset<T, WalletTransactionAggregateArgs>): Prisma.PrismaPromise<GetWalletTransactionAggregateType<T>>

    /**
     * Group by WalletTransaction.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {WalletTransactionGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends WalletTransactionGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: WalletTransactionGroupByArgs['orderBy'] }
        : { orderBy?: WalletTransactionGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, WalletTransactionGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetWalletTransactionGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the WalletTransaction model
   */
  readonly fields: WalletTransactionFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for WalletTransaction.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__WalletTransactionClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    adminWallet<T extends WalletTransaction$adminWalletArgs<ExtArgs> = {}>(args?: Subset<T, WalletTransaction$adminWalletArgs<ExtArgs>>): Prisma__AdminWalletClient<$Result.GetResult<Prisma.$AdminWalletPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    agentWallet<T extends WalletTransaction$agentWalletArgs<ExtArgs> = {}>(args?: Subset<T, WalletTransaction$agentWalletArgs<ExtArgs>>): Prisma__AgentWalletClient<$Result.GetResult<Prisma.$AgentWalletPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    order<T extends WalletTransaction$orderArgs<ExtArgs> = {}>(args?: Subset<T, WalletTransaction$orderArgs<ExtArgs>>): Prisma__OrderClient<$Result.GetResult<Prisma.$OrderPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the WalletTransaction model
   */
  interface WalletTransactionFieldRefs {
    readonly id: FieldRef<"WalletTransaction", 'String'>
    readonly walletType: FieldRef<"WalletTransaction", 'String'>
    readonly adminWalletId: FieldRef<"WalletTransaction", 'String'>
    readonly agentWalletId: FieldRef<"WalletTransaction", 'String'>
    readonly orderId: FieldRef<"WalletTransaction", 'String'>
    readonly amount: FieldRef<"WalletTransaction", 'Float'>
    readonly type: FieldRef<"WalletTransaction", 'String'>
    readonly description: FieldRef<"WalletTransaction", 'String'>
    readonly balanceBefore: FieldRef<"WalletTransaction", 'Float'>
    readonly balanceAfter: FieldRef<"WalletTransaction", 'Float'>
    readonly status: FieldRef<"WalletTransaction", 'String'>
    readonly createdAt: FieldRef<"WalletTransaction", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * WalletTransaction findUnique
   */
  export type WalletTransactionFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WalletTransaction
     */
    select?: WalletTransactionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the WalletTransaction
     */
    omit?: WalletTransactionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WalletTransactionInclude<ExtArgs> | null
    /**
     * Filter, which WalletTransaction to fetch.
     */
    where: WalletTransactionWhereUniqueInput
  }

  /**
   * WalletTransaction findUniqueOrThrow
   */
  export type WalletTransactionFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WalletTransaction
     */
    select?: WalletTransactionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the WalletTransaction
     */
    omit?: WalletTransactionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WalletTransactionInclude<ExtArgs> | null
    /**
     * Filter, which WalletTransaction to fetch.
     */
    where: WalletTransactionWhereUniqueInput
  }

  /**
   * WalletTransaction findFirst
   */
  export type WalletTransactionFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WalletTransaction
     */
    select?: WalletTransactionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the WalletTransaction
     */
    omit?: WalletTransactionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WalletTransactionInclude<ExtArgs> | null
    /**
     * Filter, which WalletTransaction to fetch.
     */
    where?: WalletTransactionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of WalletTransactions to fetch.
     */
    orderBy?: WalletTransactionOrderByWithRelationInput | WalletTransactionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for WalletTransactions.
     */
    cursor?: WalletTransactionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` WalletTransactions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` WalletTransactions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of WalletTransactions.
     */
    distinct?: WalletTransactionScalarFieldEnum | WalletTransactionScalarFieldEnum[]
  }

  /**
   * WalletTransaction findFirstOrThrow
   */
  export type WalletTransactionFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WalletTransaction
     */
    select?: WalletTransactionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the WalletTransaction
     */
    omit?: WalletTransactionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WalletTransactionInclude<ExtArgs> | null
    /**
     * Filter, which WalletTransaction to fetch.
     */
    where?: WalletTransactionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of WalletTransactions to fetch.
     */
    orderBy?: WalletTransactionOrderByWithRelationInput | WalletTransactionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for WalletTransactions.
     */
    cursor?: WalletTransactionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` WalletTransactions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` WalletTransactions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of WalletTransactions.
     */
    distinct?: WalletTransactionScalarFieldEnum | WalletTransactionScalarFieldEnum[]
  }

  /**
   * WalletTransaction findMany
   */
  export type WalletTransactionFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WalletTransaction
     */
    select?: WalletTransactionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the WalletTransaction
     */
    omit?: WalletTransactionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WalletTransactionInclude<ExtArgs> | null
    /**
     * Filter, which WalletTransactions to fetch.
     */
    where?: WalletTransactionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of WalletTransactions to fetch.
     */
    orderBy?: WalletTransactionOrderByWithRelationInput | WalletTransactionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing WalletTransactions.
     */
    cursor?: WalletTransactionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` WalletTransactions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` WalletTransactions.
     */
    skip?: number
    distinct?: WalletTransactionScalarFieldEnum | WalletTransactionScalarFieldEnum[]
  }

  /**
   * WalletTransaction create
   */
  export type WalletTransactionCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WalletTransaction
     */
    select?: WalletTransactionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the WalletTransaction
     */
    omit?: WalletTransactionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WalletTransactionInclude<ExtArgs> | null
    /**
     * The data needed to create a WalletTransaction.
     */
    data: XOR<WalletTransactionCreateInput, WalletTransactionUncheckedCreateInput>
  }

  /**
   * WalletTransaction createMany
   */
  export type WalletTransactionCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many WalletTransactions.
     */
    data: WalletTransactionCreateManyInput | WalletTransactionCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * WalletTransaction createManyAndReturn
   */
  export type WalletTransactionCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WalletTransaction
     */
    select?: WalletTransactionSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the WalletTransaction
     */
    omit?: WalletTransactionOmit<ExtArgs> | null
    /**
     * The data used to create many WalletTransactions.
     */
    data: WalletTransactionCreateManyInput | WalletTransactionCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WalletTransactionIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * WalletTransaction update
   */
  export type WalletTransactionUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WalletTransaction
     */
    select?: WalletTransactionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the WalletTransaction
     */
    omit?: WalletTransactionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WalletTransactionInclude<ExtArgs> | null
    /**
     * The data needed to update a WalletTransaction.
     */
    data: XOR<WalletTransactionUpdateInput, WalletTransactionUncheckedUpdateInput>
    /**
     * Choose, which WalletTransaction to update.
     */
    where: WalletTransactionWhereUniqueInput
  }

  /**
   * WalletTransaction updateMany
   */
  export type WalletTransactionUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update WalletTransactions.
     */
    data: XOR<WalletTransactionUpdateManyMutationInput, WalletTransactionUncheckedUpdateManyInput>
    /**
     * Filter which WalletTransactions to update
     */
    where?: WalletTransactionWhereInput
    /**
     * Limit how many WalletTransactions to update.
     */
    limit?: number
  }

  /**
   * WalletTransaction updateManyAndReturn
   */
  export type WalletTransactionUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WalletTransaction
     */
    select?: WalletTransactionSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the WalletTransaction
     */
    omit?: WalletTransactionOmit<ExtArgs> | null
    /**
     * The data used to update WalletTransactions.
     */
    data: XOR<WalletTransactionUpdateManyMutationInput, WalletTransactionUncheckedUpdateManyInput>
    /**
     * Filter which WalletTransactions to update
     */
    where?: WalletTransactionWhereInput
    /**
     * Limit how many WalletTransactions to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WalletTransactionIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * WalletTransaction upsert
   */
  export type WalletTransactionUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WalletTransaction
     */
    select?: WalletTransactionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the WalletTransaction
     */
    omit?: WalletTransactionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WalletTransactionInclude<ExtArgs> | null
    /**
     * The filter to search for the WalletTransaction to update in case it exists.
     */
    where: WalletTransactionWhereUniqueInput
    /**
     * In case the WalletTransaction found by the `where` argument doesn't exist, create a new WalletTransaction with this data.
     */
    create: XOR<WalletTransactionCreateInput, WalletTransactionUncheckedCreateInput>
    /**
     * In case the WalletTransaction was found with the provided `where` argument, update it with this data.
     */
    update: XOR<WalletTransactionUpdateInput, WalletTransactionUncheckedUpdateInput>
  }

  /**
   * WalletTransaction delete
   */
  export type WalletTransactionDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WalletTransaction
     */
    select?: WalletTransactionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the WalletTransaction
     */
    omit?: WalletTransactionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WalletTransactionInclude<ExtArgs> | null
    /**
     * Filter which WalletTransaction to delete.
     */
    where: WalletTransactionWhereUniqueInput
  }

  /**
   * WalletTransaction deleteMany
   */
  export type WalletTransactionDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which WalletTransactions to delete
     */
    where?: WalletTransactionWhereInput
    /**
     * Limit how many WalletTransactions to delete.
     */
    limit?: number
  }

  /**
   * WalletTransaction.adminWallet
   */
  export type WalletTransaction$adminWalletArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AdminWallet
     */
    select?: AdminWalletSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AdminWallet
     */
    omit?: AdminWalletOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AdminWalletInclude<ExtArgs> | null
    where?: AdminWalletWhereInput
  }

  /**
   * WalletTransaction.agentWallet
   */
  export type WalletTransaction$agentWalletArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AgentWallet
     */
    select?: AgentWalletSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AgentWallet
     */
    omit?: AgentWalletOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AgentWalletInclude<ExtArgs> | null
    where?: AgentWalletWhereInput
  }

  /**
   * WalletTransaction.order
   */
  export type WalletTransaction$orderArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Order
     */
    select?: OrderSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Order
     */
    omit?: OrderOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OrderInclude<ExtArgs> | null
    where?: OrderWhereInput
  }

  /**
   * WalletTransaction without action
   */
  export type WalletTransactionDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WalletTransaction
     */
    select?: WalletTransactionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the WalletTransaction
     */
    omit?: WalletTransactionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WalletTransactionInclude<ExtArgs> | null
  }


  /**
   * Model WalletPayout
   */

  export type AggregateWalletPayout = {
    _count: WalletPayoutCountAggregateOutputType | null
    _avg: WalletPayoutAvgAggregateOutputType | null
    _sum: WalletPayoutSumAggregateOutputType | null
    _min: WalletPayoutMinAggregateOutputType | null
    _max: WalletPayoutMaxAggregateOutputType | null
  }

  export type WalletPayoutAvgAggregateOutputType = {
    amount: number | null
  }

  export type WalletPayoutSumAggregateOutputType = {
    amount: number | null
  }

  export type WalletPayoutMinAggregateOutputType = {
    id: string | null
    agentWalletId: string | null
    agentId: string | null
    amount: number | null
    periodStart: Date | null
    periodEnd: Date | null
    status: string | null
    paymentMethod: string | null
    transactionId: string | null
    bankAccount: string | null
    upiId: string | null
    processedAt: Date | null
    failedAt: Date | null
    failureReason: string | null
    notes: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type WalletPayoutMaxAggregateOutputType = {
    id: string | null
    agentWalletId: string | null
    agentId: string | null
    amount: number | null
    periodStart: Date | null
    periodEnd: Date | null
    status: string | null
    paymentMethod: string | null
    transactionId: string | null
    bankAccount: string | null
    upiId: string | null
    processedAt: Date | null
    failedAt: Date | null
    failureReason: string | null
    notes: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type WalletPayoutCountAggregateOutputType = {
    id: number
    agentWalletId: number
    agentId: number
    amount: number
    periodStart: number
    periodEnd: number
    status: number
    paymentMethod: number
    transactionId: number
    bankAccount: number
    upiId: number
    processedAt: number
    failedAt: number
    failureReason: number
    notes: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type WalletPayoutAvgAggregateInputType = {
    amount?: true
  }

  export type WalletPayoutSumAggregateInputType = {
    amount?: true
  }

  export type WalletPayoutMinAggregateInputType = {
    id?: true
    agentWalletId?: true
    agentId?: true
    amount?: true
    periodStart?: true
    periodEnd?: true
    status?: true
    paymentMethod?: true
    transactionId?: true
    bankAccount?: true
    upiId?: true
    processedAt?: true
    failedAt?: true
    failureReason?: true
    notes?: true
    createdAt?: true
    updatedAt?: true
  }

  export type WalletPayoutMaxAggregateInputType = {
    id?: true
    agentWalletId?: true
    agentId?: true
    amount?: true
    periodStart?: true
    periodEnd?: true
    status?: true
    paymentMethod?: true
    transactionId?: true
    bankAccount?: true
    upiId?: true
    processedAt?: true
    failedAt?: true
    failureReason?: true
    notes?: true
    createdAt?: true
    updatedAt?: true
  }

  export type WalletPayoutCountAggregateInputType = {
    id?: true
    agentWalletId?: true
    agentId?: true
    amount?: true
    periodStart?: true
    periodEnd?: true
    status?: true
    paymentMethod?: true
    transactionId?: true
    bankAccount?: true
    upiId?: true
    processedAt?: true
    failedAt?: true
    failureReason?: true
    notes?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type WalletPayoutAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which WalletPayout to aggregate.
     */
    where?: WalletPayoutWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of WalletPayouts to fetch.
     */
    orderBy?: WalletPayoutOrderByWithRelationInput | WalletPayoutOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: WalletPayoutWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` WalletPayouts from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` WalletPayouts.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned WalletPayouts
    **/
    _count?: true | WalletPayoutCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: WalletPayoutAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: WalletPayoutSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: WalletPayoutMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: WalletPayoutMaxAggregateInputType
  }

  export type GetWalletPayoutAggregateType<T extends WalletPayoutAggregateArgs> = {
        [P in keyof T & keyof AggregateWalletPayout]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateWalletPayout[P]>
      : GetScalarType<T[P], AggregateWalletPayout[P]>
  }




  export type WalletPayoutGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: WalletPayoutWhereInput
    orderBy?: WalletPayoutOrderByWithAggregationInput | WalletPayoutOrderByWithAggregationInput[]
    by: WalletPayoutScalarFieldEnum[] | WalletPayoutScalarFieldEnum
    having?: WalletPayoutScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: WalletPayoutCountAggregateInputType | true
    _avg?: WalletPayoutAvgAggregateInputType
    _sum?: WalletPayoutSumAggregateInputType
    _min?: WalletPayoutMinAggregateInputType
    _max?: WalletPayoutMaxAggregateInputType
  }

  export type WalletPayoutGroupByOutputType = {
    id: string
    agentWalletId: string
    agentId: string
    amount: number
    periodStart: Date
    periodEnd: Date
    status: string
    paymentMethod: string | null
    transactionId: string | null
    bankAccount: string | null
    upiId: string | null
    processedAt: Date | null
    failedAt: Date | null
    failureReason: string | null
    notes: string | null
    createdAt: Date
    updatedAt: Date
    _count: WalletPayoutCountAggregateOutputType | null
    _avg: WalletPayoutAvgAggregateOutputType | null
    _sum: WalletPayoutSumAggregateOutputType | null
    _min: WalletPayoutMinAggregateOutputType | null
    _max: WalletPayoutMaxAggregateOutputType | null
  }

  type GetWalletPayoutGroupByPayload<T extends WalletPayoutGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<WalletPayoutGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof WalletPayoutGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], WalletPayoutGroupByOutputType[P]>
            : GetScalarType<T[P], WalletPayoutGroupByOutputType[P]>
        }
      >
    >


  export type WalletPayoutSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    agentWalletId?: boolean
    agentId?: boolean
    amount?: boolean
    periodStart?: boolean
    periodEnd?: boolean
    status?: boolean
    paymentMethod?: boolean
    transactionId?: boolean
    bankAccount?: boolean
    upiId?: boolean
    processedAt?: boolean
    failedAt?: boolean
    failureReason?: boolean
    notes?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    agentWallet?: boolean | AgentWalletDefaultArgs<ExtArgs>
    agent?: boolean | AgentDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["walletPayout"]>

  export type WalletPayoutSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    agentWalletId?: boolean
    agentId?: boolean
    amount?: boolean
    periodStart?: boolean
    periodEnd?: boolean
    status?: boolean
    paymentMethod?: boolean
    transactionId?: boolean
    bankAccount?: boolean
    upiId?: boolean
    processedAt?: boolean
    failedAt?: boolean
    failureReason?: boolean
    notes?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    agentWallet?: boolean | AgentWalletDefaultArgs<ExtArgs>
    agent?: boolean | AgentDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["walletPayout"]>

  export type WalletPayoutSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    agentWalletId?: boolean
    agentId?: boolean
    amount?: boolean
    periodStart?: boolean
    periodEnd?: boolean
    status?: boolean
    paymentMethod?: boolean
    transactionId?: boolean
    bankAccount?: boolean
    upiId?: boolean
    processedAt?: boolean
    failedAt?: boolean
    failureReason?: boolean
    notes?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    agentWallet?: boolean | AgentWalletDefaultArgs<ExtArgs>
    agent?: boolean | AgentDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["walletPayout"]>

  export type WalletPayoutSelectScalar = {
    id?: boolean
    agentWalletId?: boolean
    agentId?: boolean
    amount?: boolean
    periodStart?: boolean
    periodEnd?: boolean
    status?: boolean
    paymentMethod?: boolean
    transactionId?: boolean
    bankAccount?: boolean
    upiId?: boolean
    processedAt?: boolean
    failedAt?: boolean
    failureReason?: boolean
    notes?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type WalletPayoutOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "agentWalletId" | "agentId" | "amount" | "periodStart" | "periodEnd" | "status" | "paymentMethod" | "transactionId" | "bankAccount" | "upiId" | "processedAt" | "failedAt" | "failureReason" | "notes" | "createdAt" | "updatedAt", ExtArgs["result"]["walletPayout"]>
  export type WalletPayoutInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    agentWallet?: boolean | AgentWalletDefaultArgs<ExtArgs>
    agent?: boolean | AgentDefaultArgs<ExtArgs>
  }
  export type WalletPayoutIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    agentWallet?: boolean | AgentWalletDefaultArgs<ExtArgs>
    agent?: boolean | AgentDefaultArgs<ExtArgs>
  }
  export type WalletPayoutIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    agentWallet?: boolean | AgentWalletDefaultArgs<ExtArgs>
    agent?: boolean | AgentDefaultArgs<ExtArgs>
  }

  export type $WalletPayoutPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "WalletPayout"
    objects: {
      agentWallet: Prisma.$AgentWalletPayload<ExtArgs>
      agent: Prisma.$AgentPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      agentWalletId: string
      agentId: string
      amount: number
      periodStart: Date
      periodEnd: Date
      status: string
      paymentMethod: string | null
      transactionId: string | null
      bankAccount: string | null
      upiId: string | null
      processedAt: Date | null
      failedAt: Date | null
      failureReason: string | null
      notes: string | null
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["walletPayout"]>
    composites: {}
  }

  type WalletPayoutGetPayload<S extends boolean | null | undefined | WalletPayoutDefaultArgs> = $Result.GetResult<Prisma.$WalletPayoutPayload, S>

  type WalletPayoutCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<WalletPayoutFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: WalletPayoutCountAggregateInputType | true
    }

  export interface WalletPayoutDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['WalletPayout'], meta: { name: 'WalletPayout' } }
    /**
     * Find zero or one WalletPayout that matches the filter.
     * @param {WalletPayoutFindUniqueArgs} args - Arguments to find a WalletPayout
     * @example
     * // Get one WalletPayout
     * const walletPayout = await prisma.walletPayout.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends WalletPayoutFindUniqueArgs>(args: SelectSubset<T, WalletPayoutFindUniqueArgs<ExtArgs>>): Prisma__WalletPayoutClient<$Result.GetResult<Prisma.$WalletPayoutPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one WalletPayout that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {WalletPayoutFindUniqueOrThrowArgs} args - Arguments to find a WalletPayout
     * @example
     * // Get one WalletPayout
     * const walletPayout = await prisma.walletPayout.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends WalletPayoutFindUniqueOrThrowArgs>(args: SelectSubset<T, WalletPayoutFindUniqueOrThrowArgs<ExtArgs>>): Prisma__WalletPayoutClient<$Result.GetResult<Prisma.$WalletPayoutPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first WalletPayout that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {WalletPayoutFindFirstArgs} args - Arguments to find a WalletPayout
     * @example
     * // Get one WalletPayout
     * const walletPayout = await prisma.walletPayout.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends WalletPayoutFindFirstArgs>(args?: SelectSubset<T, WalletPayoutFindFirstArgs<ExtArgs>>): Prisma__WalletPayoutClient<$Result.GetResult<Prisma.$WalletPayoutPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first WalletPayout that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {WalletPayoutFindFirstOrThrowArgs} args - Arguments to find a WalletPayout
     * @example
     * // Get one WalletPayout
     * const walletPayout = await prisma.walletPayout.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends WalletPayoutFindFirstOrThrowArgs>(args?: SelectSubset<T, WalletPayoutFindFirstOrThrowArgs<ExtArgs>>): Prisma__WalletPayoutClient<$Result.GetResult<Prisma.$WalletPayoutPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more WalletPayouts that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {WalletPayoutFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all WalletPayouts
     * const walletPayouts = await prisma.walletPayout.findMany()
     * 
     * // Get first 10 WalletPayouts
     * const walletPayouts = await prisma.walletPayout.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const walletPayoutWithIdOnly = await prisma.walletPayout.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends WalletPayoutFindManyArgs>(args?: SelectSubset<T, WalletPayoutFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$WalletPayoutPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a WalletPayout.
     * @param {WalletPayoutCreateArgs} args - Arguments to create a WalletPayout.
     * @example
     * // Create one WalletPayout
     * const WalletPayout = await prisma.walletPayout.create({
     *   data: {
     *     // ... data to create a WalletPayout
     *   }
     * })
     * 
     */
    create<T extends WalletPayoutCreateArgs>(args: SelectSubset<T, WalletPayoutCreateArgs<ExtArgs>>): Prisma__WalletPayoutClient<$Result.GetResult<Prisma.$WalletPayoutPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many WalletPayouts.
     * @param {WalletPayoutCreateManyArgs} args - Arguments to create many WalletPayouts.
     * @example
     * // Create many WalletPayouts
     * const walletPayout = await prisma.walletPayout.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends WalletPayoutCreateManyArgs>(args?: SelectSubset<T, WalletPayoutCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many WalletPayouts and returns the data saved in the database.
     * @param {WalletPayoutCreateManyAndReturnArgs} args - Arguments to create many WalletPayouts.
     * @example
     * // Create many WalletPayouts
     * const walletPayout = await prisma.walletPayout.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many WalletPayouts and only return the `id`
     * const walletPayoutWithIdOnly = await prisma.walletPayout.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends WalletPayoutCreateManyAndReturnArgs>(args?: SelectSubset<T, WalletPayoutCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$WalletPayoutPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a WalletPayout.
     * @param {WalletPayoutDeleteArgs} args - Arguments to delete one WalletPayout.
     * @example
     * // Delete one WalletPayout
     * const WalletPayout = await prisma.walletPayout.delete({
     *   where: {
     *     // ... filter to delete one WalletPayout
     *   }
     * })
     * 
     */
    delete<T extends WalletPayoutDeleteArgs>(args: SelectSubset<T, WalletPayoutDeleteArgs<ExtArgs>>): Prisma__WalletPayoutClient<$Result.GetResult<Prisma.$WalletPayoutPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one WalletPayout.
     * @param {WalletPayoutUpdateArgs} args - Arguments to update one WalletPayout.
     * @example
     * // Update one WalletPayout
     * const walletPayout = await prisma.walletPayout.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends WalletPayoutUpdateArgs>(args: SelectSubset<T, WalletPayoutUpdateArgs<ExtArgs>>): Prisma__WalletPayoutClient<$Result.GetResult<Prisma.$WalletPayoutPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more WalletPayouts.
     * @param {WalletPayoutDeleteManyArgs} args - Arguments to filter WalletPayouts to delete.
     * @example
     * // Delete a few WalletPayouts
     * const { count } = await prisma.walletPayout.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends WalletPayoutDeleteManyArgs>(args?: SelectSubset<T, WalletPayoutDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more WalletPayouts.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {WalletPayoutUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many WalletPayouts
     * const walletPayout = await prisma.walletPayout.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends WalletPayoutUpdateManyArgs>(args: SelectSubset<T, WalletPayoutUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more WalletPayouts and returns the data updated in the database.
     * @param {WalletPayoutUpdateManyAndReturnArgs} args - Arguments to update many WalletPayouts.
     * @example
     * // Update many WalletPayouts
     * const walletPayout = await prisma.walletPayout.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more WalletPayouts and only return the `id`
     * const walletPayoutWithIdOnly = await prisma.walletPayout.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends WalletPayoutUpdateManyAndReturnArgs>(args: SelectSubset<T, WalletPayoutUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$WalletPayoutPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one WalletPayout.
     * @param {WalletPayoutUpsertArgs} args - Arguments to update or create a WalletPayout.
     * @example
     * // Update or create a WalletPayout
     * const walletPayout = await prisma.walletPayout.upsert({
     *   create: {
     *     // ... data to create a WalletPayout
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the WalletPayout we want to update
     *   }
     * })
     */
    upsert<T extends WalletPayoutUpsertArgs>(args: SelectSubset<T, WalletPayoutUpsertArgs<ExtArgs>>): Prisma__WalletPayoutClient<$Result.GetResult<Prisma.$WalletPayoutPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of WalletPayouts.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {WalletPayoutCountArgs} args - Arguments to filter WalletPayouts to count.
     * @example
     * // Count the number of WalletPayouts
     * const count = await prisma.walletPayout.count({
     *   where: {
     *     // ... the filter for the WalletPayouts we want to count
     *   }
     * })
    **/
    count<T extends WalletPayoutCountArgs>(
      args?: Subset<T, WalletPayoutCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], WalletPayoutCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a WalletPayout.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {WalletPayoutAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends WalletPayoutAggregateArgs>(args: Subset<T, WalletPayoutAggregateArgs>): Prisma.PrismaPromise<GetWalletPayoutAggregateType<T>>

    /**
     * Group by WalletPayout.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {WalletPayoutGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends WalletPayoutGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: WalletPayoutGroupByArgs['orderBy'] }
        : { orderBy?: WalletPayoutGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, WalletPayoutGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetWalletPayoutGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the WalletPayout model
   */
  readonly fields: WalletPayoutFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for WalletPayout.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__WalletPayoutClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    agentWallet<T extends AgentWalletDefaultArgs<ExtArgs> = {}>(args?: Subset<T, AgentWalletDefaultArgs<ExtArgs>>): Prisma__AgentWalletClient<$Result.GetResult<Prisma.$AgentWalletPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    agent<T extends AgentDefaultArgs<ExtArgs> = {}>(args?: Subset<T, AgentDefaultArgs<ExtArgs>>): Prisma__AgentClient<$Result.GetResult<Prisma.$AgentPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the WalletPayout model
   */
  interface WalletPayoutFieldRefs {
    readonly id: FieldRef<"WalletPayout", 'String'>
    readonly agentWalletId: FieldRef<"WalletPayout", 'String'>
    readonly agentId: FieldRef<"WalletPayout", 'String'>
    readonly amount: FieldRef<"WalletPayout", 'Float'>
    readonly periodStart: FieldRef<"WalletPayout", 'DateTime'>
    readonly periodEnd: FieldRef<"WalletPayout", 'DateTime'>
    readonly status: FieldRef<"WalletPayout", 'String'>
    readonly paymentMethod: FieldRef<"WalletPayout", 'String'>
    readonly transactionId: FieldRef<"WalletPayout", 'String'>
    readonly bankAccount: FieldRef<"WalletPayout", 'String'>
    readonly upiId: FieldRef<"WalletPayout", 'String'>
    readonly processedAt: FieldRef<"WalletPayout", 'DateTime'>
    readonly failedAt: FieldRef<"WalletPayout", 'DateTime'>
    readonly failureReason: FieldRef<"WalletPayout", 'String'>
    readonly notes: FieldRef<"WalletPayout", 'String'>
    readonly createdAt: FieldRef<"WalletPayout", 'DateTime'>
    readonly updatedAt: FieldRef<"WalletPayout", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * WalletPayout findUnique
   */
  export type WalletPayoutFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WalletPayout
     */
    select?: WalletPayoutSelect<ExtArgs> | null
    /**
     * Omit specific fields from the WalletPayout
     */
    omit?: WalletPayoutOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WalletPayoutInclude<ExtArgs> | null
    /**
     * Filter, which WalletPayout to fetch.
     */
    where: WalletPayoutWhereUniqueInput
  }

  /**
   * WalletPayout findUniqueOrThrow
   */
  export type WalletPayoutFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WalletPayout
     */
    select?: WalletPayoutSelect<ExtArgs> | null
    /**
     * Omit specific fields from the WalletPayout
     */
    omit?: WalletPayoutOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WalletPayoutInclude<ExtArgs> | null
    /**
     * Filter, which WalletPayout to fetch.
     */
    where: WalletPayoutWhereUniqueInput
  }

  /**
   * WalletPayout findFirst
   */
  export type WalletPayoutFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WalletPayout
     */
    select?: WalletPayoutSelect<ExtArgs> | null
    /**
     * Omit specific fields from the WalletPayout
     */
    omit?: WalletPayoutOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WalletPayoutInclude<ExtArgs> | null
    /**
     * Filter, which WalletPayout to fetch.
     */
    where?: WalletPayoutWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of WalletPayouts to fetch.
     */
    orderBy?: WalletPayoutOrderByWithRelationInput | WalletPayoutOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for WalletPayouts.
     */
    cursor?: WalletPayoutWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` WalletPayouts from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` WalletPayouts.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of WalletPayouts.
     */
    distinct?: WalletPayoutScalarFieldEnum | WalletPayoutScalarFieldEnum[]
  }

  /**
   * WalletPayout findFirstOrThrow
   */
  export type WalletPayoutFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WalletPayout
     */
    select?: WalletPayoutSelect<ExtArgs> | null
    /**
     * Omit specific fields from the WalletPayout
     */
    omit?: WalletPayoutOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WalletPayoutInclude<ExtArgs> | null
    /**
     * Filter, which WalletPayout to fetch.
     */
    where?: WalletPayoutWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of WalletPayouts to fetch.
     */
    orderBy?: WalletPayoutOrderByWithRelationInput | WalletPayoutOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for WalletPayouts.
     */
    cursor?: WalletPayoutWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` WalletPayouts from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` WalletPayouts.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of WalletPayouts.
     */
    distinct?: WalletPayoutScalarFieldEnum | WalletPayoutScalarFieldEnum[]
  }

  /**
   * WalletPayout findMany
   */
  export type WalletPayoutFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WalletPayout
     */
    select?: WalletPayoutSelect<ExtArgs> | null
    /**
     * Omit specific fields from the WalletPayout
     */
    omit?: WalletPayoutOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WalletPayoutInclude<ExtArgs> | null
    /**
     * Filter, which WalletPayouts to fetch.
     */
    where?: WalletPayoutWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of WalletPayouts to fetch.
     */
    orderBy?: WalletPayoutOrderByWithRelationInput | WalletPayoutOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing WalletPayouts.
     */
    cursor?: WalletPayoutWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` WalletPayouts from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` WalletPayouts.
     */
    skip?: number
    distinct?: WalletPayoutScalarFieldEnum | WalletPayoutScalarFieldEnum[]
  }

  /**
   * WalletPayout create
   */
  export type WalletPayoutCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WalletPayout
     */
    select?: WalletPayoutSelect<ExtArgs> | null
    /**
     * Omit specific fields from the WalletPayout
     */
    omit?: WalletPayoutOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WalletPayoutInclude<ExtArgs> | null
    /**
     * The data needed to create a WalletPayout.
     */
    data: XOR<WalletPayoutCreateInput, WalletPayoutUncheckedCreateInput>
  }

  /**
   * WalletPayout createMany
   */
  export type WalletPayoutCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many WalletPayouts.
     */
    data: WalletPayoutCreateManyInput | WalletPayoutCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * WalletPayout createManyAndReturn
   */
  export type WalletPayoutCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WalletPayout
     */
    select?: WalletPayoutSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the WalletPayout
     */
    omit?: WalletPayoutOmit<ExtArgs> | null
    /**
     * The data used to create many WalletPayouts.
     */
    data: WalletPayoutCreateManyInput | WalletPayoutCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WalletPayoutIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * WalletPayout update
   */
  export type WalletPayoutUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WalletPayout
     */
    select?: WalletPayoutSelect<ExtArgs> | null
    /**
     * Omit specific fields from the WalletPayout
     */
    omit?: WalletPayoutOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WalletPayoutInclude<ExtArgs> | null
    /**
     * The data needed to update a WalletPayout.
     */
    data: XOR<WalletPayoutUpdateInput, WalletPayoutUncheckedUpdateInput>
    /**
     * Choose, which WalletPayout to update.
     */
    where: WalletPayoutWhereUniqueInput
  }

  /**
   * WalletPayout updateMany
   */
  export type WalletPayoutUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update WalletPayouts.
     */
    data: XOR<WalletPayoutUpdateManyMutationInput, WalletPayoutUncheckedUpdateManyInput>
    /**
     * Filter which WalletPayouts to update
     */
    where?: WalletPayoutWhereInput
    /**
     * Limit how many WalletPayouts to update.
     */
    limit?: number
  }

  /**
   * WalletPayout updateManyAndReturn
   */
  export type WalletPayoutUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WalletPayout
     */
    select?: WalletPayoutSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the WalletPayout
     */
    omit?: WalletPayoutOmit<ExtArgs> | null
    /**
     * The data used to update WalletPayouts.
     */
    data: XOR<WalletPayoutUpdateManyMutationInput, WalletPayoutUncheckedUpdateManyInput>
    /**
     * Filter which WalletPayouts to update
     */
    where?: WalletPayoutWhereInput
    /**
     * Limit how many WalletPayouts to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WalletPayoutIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * WalletPayout upsert
   */
  export type WalletPayoutUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WalletPayout
     */
    select?: WalletPayoutSelect<ExtArgs> | null
    /**
     * Omit specific fields from the WalletPayout
     */
    omit?: WalletPayoutOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WalletPayoutInclude<ExtArgs> | null
    /**
     * The filter to search for the WalletPayout to update in case it exists.
     */
    where: WalletPayoutWhereUniqueInput
    /**
     * In case the WalletPayout found by the `where` argument doesn't exist, create a new WalletPayout with this data.
     */
    create: XOR<WalletPayoutCreateInput, WalletPayoutUncheckedCreateInput>
    /**
     * In case the WalletPayout was found with the provided `where` argument, update it with this data.
     */
    update: XOR<WalletPayoutUpdateInput, WalletPayoutUncheckedUpdateInput>
  }

  /**
   * WalletPayout delete
   */
  export type WalletPayoutDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WalletPayout
     */
    select?: WalletPayoutSelect<ExtArgs> | null
    /**
     * Omit specific fields from the WalletPayout
     */
    omit?: WalletPayoutOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WalletPayoutInclude<ExtArgs> | null
    /**
     * Filter which WalletPayout to delete.
     */
    where: WalletPayoutWhereUniqueInput
  }

  /**
   * WalletPayout deleteMany
   */
  export type WalletPayoutDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which WalletPayouts to delete
     */
    where?: WalletPayoutWhereInput
    /**
     * Limit how many WalletPayouts to delete.
     */
    limit?: number
  }

  /**
   * WalletPayout without action
   */
  export type WalletPayoutDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WalletPayout
     */
    select?: WalletPayoutSelect<ExtArgs> | null
    /**
     * Omit specific fields from the WalletPayout
     */
    omit?: WalletPayoutOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WalletPayoutInclude<ExtArgs> | null
  }


  /**
   * Model Notification
   */

  export type AggregateNotification = {
    _count: NotificationCountAggregateOutputType | null
    _min: NotificationMinAggregateOutputType | null
    _max: NotificationMaxAggregateOutputType | null
  }

  export type NotificationMinAggregateOutputType = {
    id: string | null
    userId: string | null
    title: string | null
    message: string | null
    type: string | null
    isRead: boolean | null
    link: string | null
    createdAt: Date | null
    readAt: Date | null
  }

  export type NotificationMaxAggregateOutputType = {
    id: string | null
    userId: string | null
    title: string | null
    message: string | null
    type: string | null
    isRead: boolean | null
    link: string | null
    createdAt: Date | null
    readAt: Date | null
  }

  export type NotificationCountAggregateOutputType = {
    id: number
    userId: number
    title: number
    message: number
    type: number
    isRead: number
    link: number
    metadata: number
    createdAt: number
    readAt: number
    _all: number
  }


  export type NotificationMinAggregateInputType = {
    id?: true
    userId?: true
    title?: true
    message?: true
    type?: true
    isRead?: true
    link?: true
    createdAt?: true
    readAt?: true
  }

  export type NotificationMaxAggregateInputType = {
    id?: true
    userId?: true
    title?: true
    message?: true
    type?: true
    isRead?: true
    link?: true
    createdAt?: true
    readAt?: true
  }

  export type NotificationCountAggregateInputType = {
    id?: true
    userId?: true
    title?: true
    message?: true
    type?: true
    isRead?: true
    link?: true
    metadata?: true
    createdAt?: true
    readAt?: true
    _all?: true
  }

  export type NotificationAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Notification to aggregate.
     */
    where?: NotificationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Notifications to fetch.
     */
    orderBy?: NotificationOrderByWithRelationInput | NotificationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: NotificationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Notifications from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Notifications.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Notifications
    **/
    _count?: true | NotificationCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: NotificationMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: NotificationMaxAggregateInputType
  }

  export type GetNotificationAggregateType<T extends NotificationAggregateArgs> = {
        [P in keyof T & keyof AggregateNotification]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateNotification[P]>
      : GetScalarType<T[P], AggregateNotification[P]>
  }




  export type NotificationGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: NotificationWhereInput
    orderBy?: NotificationOrderByWithAggregationInput | NotificationOrderByWithAggregationInput[]
    by: NotificationScalarFieldEnum[] | NotificationScalarFieldEnum
    having?: NotificationScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: NotificationCountAggregateInputType | true
    _min?: NotificationMinAggregateInputType
    _max?: NotificationMaxAggregateInputType
  }

  export type NotificationGroupByOutputType = {
    id: string
    userId: string
    title: string
    message: string
    type: string
    isRead: boolean
    link: string | null
    metadata: JsonValue | null
    createdAt: Date
    readAt: Date | null
    _count: NotificationCountAggregateOutputType | null
    _min: NotificationMinAggregateOutputType | null
    _max: NotificationMaxAggregateOutputType | null
  }

  type GetNotificationGroupByPayload<T extends NotificationGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<NotificationGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof NotificationGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], NotificationGroupByOutputType[P]>
            : GetScalarType<T[P], NotificationGroupByOutputType[P]>
        }
      >
    >


  export type NotificationSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    title?: boolean
    message?: boolean
    type?: boolean
    isRead?: boolean
    link?: boolean
    metadata?: boolean
    createdAt?: boolean
    readAt?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["notification"]>

  export type NotificationSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    title?: boolean
    message?: boolean
    type?: boolean
    isRead?: boolean
    link?: boolean
    metadata?: boolean
    createdAt?: boolean
    readAt?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["notification"]>

  export type NotificationSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    title?: boolean
    message?: boolean
    type?: boolean
    isRead?: boolean
    link?: boolean
    metadata?: boolean
    createdAt?: boolean
    readAt?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["notification"]>

  export type NotificationSelectScalar = {
    id?: boolean
    userId?: boolean
    title?: boolean
    message?: boolean
    type?: boolean
    isRead?: boolean
    link?: boolean
    metadata?: boolean
    createdAt?: boolean
    readAt?: boolean
  }

  export type NotificationOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "userId" | "title" | "message" | "type" | "isRead" | "link" | "metadata" | "createdAt" | "readAt", ExtArgs["result"]["notification"]>
  export type NotificationInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
  }
  export type NotificationIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
  }
  export type NotificationIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
  }

  export type $NotificationPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Notification"
    objects: {
      user: Prisma.$UserPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      userId: string
      title: string
      message: string
      type: string
      isRead: boolean
      link: string | null
      metadata: Prisma.JsonValue | null
      createdAt: Date
      readAt: Date | null
    }, ExtArgs["result"]["notification"]>
    composites: {}
  }

  type NotificationGetPayload<S extends boolean | null | undefined | NotificationDefaultArgs> = $Result.GetResult<Prisma.$NotificationPayload, S>

  type NotificationCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<NotificationFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: NotificationCountAggregateInputType | true
    }

  export interface NotificationDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Notification'], meta: { name: 'Notification' } }
    /**
     * Find zero or one Notification that matches the filter.
     * @param {NotificationFindUniqueArgs} args - Arguments to find a Notification
     * @example
     * // Get one Notification
     * const notification = await prisma.notification.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends NotificationFindUniqueArgs>(args: SelectSubset<T, NotificationFindUniqueArgs<ExtArgs>>): Prisma__NotificationClient<$Result.GetResult<Prisma.$NotificationPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Notification that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {NotificationFindUniqueOrThrowArgs} args - Arguments to find a Notification
     * @example
     * // Get one Notification
     * const notification = await prisma.notification.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends NotificationFindUniqueOrThrowArgs>(args: SelectSubset<T, NotificationFindUniqueOrThrowArgs<ExtArgs>>): Prisma__NotificationClient<$Result.GetResult<Prisma.$NotificationPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Notification that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {NotificationFindFirstArgs} args - Arguments to find a Notification
     * @example
     * // Get one Notification
     * const notification = await prisma.notification.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends NotificationFindFirstArgs>(args?: SelectSubset<T, NotificationFindFirstArgs<ExtArgs>>): Prisma__NotificationClient<$Result.GetResult<Prisma.$NotificationPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Notification that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {NotificationFindFirstOrThrowArgs} args - Arguments to find a Notification
     * @example
     * // Get one Notification
     * const notification = await prisma.notification.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends NotificationFindFirstOrThrowArgs>(args?: SelectSubset<T, NotificationFindFirstOrThrowArgs<ExtArgs>>): Prisma__NotificationClient<$Result.GetResult<Prisma.$NotificationPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Notifications that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {NotificationFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Notifications
     * const notifications = await prisma.notification.findMany()
     * 
     * // Get first 10 Notifications
     * const notifications = await prisma.notification.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const notificationWithIdOnly = await prisma.notification.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends NotificationFindManyArgs>(args?: SelectSubset<T, NotificationFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$NotificationPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Notification.
     * @param {NotificationCreateArgs} args - Arguments to create a Notification.
     * @example
     * // Create one Notification
     * const Notification = await prisma.notification.create({
     *   data: {
     *     // ... data to create a Notification
     *   }
     * })
     * 
     */
    create<T extends NotificationCreateArgs>(args: SelectSubset<T, NotificationCreateArgs<ExtArgs>>): Prisma__NotificationClient<$Result.GetResult<Prisma.$NotificationPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Notifications.
     * @param {NotificationCreateManyArgs} args - Arguments to create many Notifications.
     * @example
     * // Create many Notifications
     * const notification = await prisma.notification.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends NotificationCreateManyArgs>(args?: SelectSubset<T, NotificationCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Notifications and returns the data saved in the database.
     * @param {NotificationCreateManyAndReturnArgs} args - Arguments to create many Notifications.
     * @example
     * // Create many Notifications
     * const notification = await prisma.notification.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Notifications and only return the `id`
     * const notificationWithIdOnly = await prisma.notification.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends NotificationCreateManyAndReturnArgs>(args?: SelectSubset<T, NotificationCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$NotificationPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Notification.
     * @param {NotificationDeleteArgs} args - Arguments to delete one Notification.
     * @example
     * // Delete one Notification
     * const Notification = await prisma.notification.delete({
     *   where: {
     *     // ... filter to delete one Notification
     *   }
     * })
     * 
     */
    delete<T extends NotificationDeleteArgs>(args: SelectSubset<T, NotificationDeleteArgs<ExtArgs>>): Prisma__NotificationClient<$Result.GetResult<Prisma.$NotificationPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Notification.
     * @param {NotificationUpdateArgs} args - Arguments to update one Notification.
     * @example
     * // Update one Notification
     * const notification = await prisma.notification.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends NotificationUpdateArgs>(args: SelectSubset<T, NotificationUpdateArgs<ExtArgs>>): Prisma__NotificationClient<$Result.GetResult<Prisma.$NotificationPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Notifications.
     * @param {NotificationDeleteManyArgs} args - Arguments to filter Notifications to delete.
     * @example
     * // Delete a few Notifications
     * const { count } = await prisma.notification.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends NotificationDeleteManyArgs>(args?: SelectSubset<T, NotificationDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Notifications.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {NotificationUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Notifications
     * const notification = await prisma.notification.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends NotificationUpdateManyArgs>(args: SelectSubset<T, NotificationUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Notifications and returns the data updated in the database.
     * @param {NotificationUpdateManyAndReturnArgs} args - Arguments to update many Notifications.
     * @example
     * // Update many Notifications
     * const notification = await prisma.notification.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Notifications and only return the `id`
     * const notificationWithIdOnly = await prisma.notification.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends NotificationUpdateManyAndReturnArgs>(args: SelectSubset<T, NotificationUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$NotificationPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Notification.
     * @param {NotificationUpsertArgs} args - Arguments to update or create a Notification.
     * @example
     * // Update or create a Notification
     * const notification = await prisma.notification.upsert({
     *   create: {
     *     // ... data to create a Notification
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Notification we want to update
     *   }
     * })
     */
    upsert<T extends NotificationUpsertArgs>(args: SelectSubset<T, NotificationUpsertArgs<ExtArgs>>): Prisma__NotificationClient<$Result.GetResult<Prisma.$NotificationPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Notifications.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {NotificationCountArgs} args - Arguments to filter Notifications to count.
     * @example
     * // Count the number of Notifications
     * const count = await prisma.notification.count({
     *   where: {
     *     // ... the filter for the Notifications we want to count
     *   }
     * })
    **/
    count<T extends NotificationCountArgs>(
      args?: Subset<T, NotificationCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], NotificationCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Notification.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {NotificationAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends NotificationAggregateArgs>(args: Subset<T, NotificationAggregateArgs>): Prisma.PrismaPromise<GetNotificationAggregateType<T>>

    /**
     * Group by Notification.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {NotificationGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends NotificationGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: NotificationGroupByArgs['orderBy'] }
        : { orderBy?: NotificationGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, NotificationGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetNotificationGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Notification model
   */
  readonly fields: NotificationFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Notification.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__NotificationClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    user<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Notification model
   */
  interface NotificationFieldRefs {
    readonly id: FieldRef<"Notification", 'String'>
    readonly userId: FieldRef<"Notification", 'String'>
    readonly title: FieldRef<"Notification", 'String'>
    readonly message: FieldRef<"Notification", 'String'>
    readonly type: FieldRef<"Notification", 'String'>
    readonly isRead: FieldRef<"Notification", 'Boolean'>
    readonly link: FieldRef<"Notification", 'String'>
    readonly metadata: FieldRef<"Notification", 'Json'>
    readonly createdAt: FieldRef<"Notification", 'DateTime'>
    readonly readAt: FieldRef<"Notification", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Notification findUnique
   */
  export type NotificationFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Notification
     */
    select?: NotificationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Notification
     */
    omit?: NotificationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NotificationInclude<ExtArgs> | null
    /**
     * Filter, which Notification to fetch.
     */
    where: NotificationWhereUniqueInput
  }

  /**
   * Notification findUniqueOrThrow
   */
  export type NotificationFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Notification
     */
    select?: NotificationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Notification
     */
    omit?: NotificationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NotificationInclude<ExtArgs> | null
    /**
     * Filter, which Notification to fetch.
     */
    where: NotificationWhereUniqueInput
  }

  /**
   * Notification findFirst
   */
  export type NotificationFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Notification
     */
    select?: NotificationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Notification
     */
    omit?: NotificationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NotificationInclude<ExtArgs> | null
    /**
     * Filter, which Notification to fetch.
     */
    where?: NotificationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Notifications to fetch.
     */
    orderBy?: NotificationOrderByWithRelationInput | NotificationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Notifications.
     */
    cursor?: NotificationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Notifications from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Notifications.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Notifications.
     */
    distinct?: NotificationScalarFieldEnum | NotificationScalarFieldEnum[]
  }

  /**
   * Notification findFirstOrThrow
   */
  export type NotificationFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Notification
     */
    select?: NotificationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Notification
     */
    omit?: NotificationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NotificationInclude<ExtArgs> | null
    /**
     * Filter, which Notification to fetch.
     */
    where?: NotificationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Notifications to fetch.
     */
    orderBy?: NotificationOrderByWithRelationInput | NotificationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Notifications.
     */
    cursor?: NotificationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Notifications from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Notifications.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Notifications.
     */
    distinct?: NotificationScalarFieldEnum | NotificationScalarFieldEnum[]
  }

  /**
   * Notification findMany
   */
  export type NotificationFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Notification
     */
    select?: NotificationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Notification
     */
    omit?: NotificationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NotificationInclude<ExtArgs> | null
    /**
     * Filter, which Notifications to fetch.
     */
    where?: NotificationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Notifications to fetch.
     */
    orderBy?: NotificationOrderByWithRelationInput | NotificationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Notifications.
     */
    cursor?: NotificationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Notifications from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Notifications.
     */
    skip?: number
    distinct?: NotificationScalarFieldEnum | NotificationScalarFieldEnum[]
  }

  /**
   * Notification create
   */
  export type NotificationCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Notification
     */
    select?: NotificationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Notification
     */
    omit?: NotificationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NotificationInclude<ExtArgs> | null
    /**
     * The data needed to create a Notification.
     */
    data: XOR<NotificationCreateInput, NotificationUncheckedCreateInput>
  }

  /**
   * Notification createMany
   */
  export type NotificationCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Notifications.
     */
    data: NotificationCreateManyInput | NotificationCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Notification createManyAndReturn
   */
  export type NotificationCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Notification
     */
    select?: NotificationSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Notification
     */
    omit?: NotificationOmit<ExtArgs> | null
    /**
     * The data used to create many Notifications.
     */
    data: NotificationCreateManyInput | NotificationCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NotificationIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Notification update
   */
  export type NotificationUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Notification
     */
    select?: NotificationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Notification
     */
    omit?: NotificationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NotificationInclude<ExtArgs> | null
    /**
     * The data needed to update a Notification.
     */
    data: XOR<NotificationUpdateInput, NotificationUncheckedUpdateInput>
    /**
     * Choose, which Notification to update.
     */
    where: NotificationWhereUniqueInput
  }

  /**
   * Notification updateMany
   */
  export type NotificationUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Notifications.
     */
    data: XOR<NotificationUpdateManyMutationInput, NotificationUncheckedUpdateManyInput>
    /**
     * Filter which Notifications to update
     */
    where?: NotificationWhereInput
    /**
     * Limit how many Notifications to update.
     */
    limit?: number
  }

  /**
   * Notification updateManyAndReturn
   */
  export type NotificationUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Notification
     */
    select?: NotificationSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Notification
     */
    omit?: NotificationOmit<ExtArgs> | null
    /**
     * The data used to update Notifications.
     */
    data: XOR<NotificationUpdateManyMutationInput, NotificationUncheckedUpdateManyInput>
    /**
     * Filter which Notifications to update
     */
    where?: NotificationWhereInput
    /**
     * Limit how many Notifications to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NotificationIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * Notification upsert
   */
  export type NotificationUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Notification
     */
    select?: NotificationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Notification
     */
    omit?: NotificationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NotificationInclude<ExtArgs> | null
    /**
     * The filter to search for the Notification to update in case it exists.
     */
    where: NotificationWhereUniqueInput
    /**
     * In case the Notification found by the `where` argument doesn't exist, create a new Notification with this data.
     */
    create: XOR<NotificationCreateInput, NotificationUncheckedCreateInput>
    /**
     * In case the Notification was found with the provided `where` argument, update it with this data.
     */
    update: XOR<NotificationUpdateInput, NotificationUncheckedUpdateInput>
  }

  /**
   * Notification delete
   */
  export type NotificationDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Notification
     */
    select?: NotificationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Notification
     */
    omit?: NotificationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NotificationInclude<ExtArgs> | null
    /**
     * Filter which Notification to delete.
     */
    where: NotificationWhereUniqueInput
  }

  /**
   * Notification deleteMany
   */
  export type NotificationDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Notifications to delete
     */
    where?: NotificationWhereInput
    /**
     * Limit how many Notifications to delete.
     */
    limit?: number
  }

  /**
   * Notification without action
   */
  export type NotificationDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Notification
     */
    select?: NotificationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Notification
     */
    omit?: NotificationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NotificationInclude<ExtArgs> | null
  }


  /**
   * Model AgentRating
   */

  export type AggregateAgentRating = {
    _count: AgentRatingCountAggregateOutputType | null
    _avg: AgentRatingAvgAggregateOutputType | null
    _sum: AgentRatingSumAggregateOutputType | null
    _min: AgentRatingMinAggregateOutputType | null
    _max: AgentRatingMaxAggregateOutputType | null
  }

  export type AgentRatingAvgAggregateOutputType = {
    rating: number | null
  }

  export type AgentRatingSumAggregateOutputType = {
    rating: number | null
  }

  export type AgentRatingMinAggregateOutputType = {
    id: string | null
    orderId: string | null
    agentId: string | null
    partnerId: string | null
    rating: number | null
    comment: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type AgentRatingMaxAggregateOutputType = {
    id: string | null
    orderId: string | null
    agentId: string | null
    partnerId: string | null
    rating: number | null
    comment: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type AgentRatingCountAggregateOutputType = {
    id: number
    orderId: number
    agentId: number
    partnerId: number
    rating: number
    comment: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type AgentRatingAvgAggregateInputType = {
    rating?: true
  }

  export type AgentRatingSumAggregateInputType = {
    rating?: true
  }

  export type AgentRatingMinAggregateInputType = {
    id?: true
    orderId?: true
    agentId?: true
    partnerId?: true
    rating?: true
    comment?: true
    createdAt?: true
    updatedAt?: true
  }

  export type AgentRatingMaxAggregateInputType = {
    id?: true
    orderId?: true
    agentId?: true
    partnerId?: true
    rating?: true
    comment?: true
    createdAt?: true
    updatedAt?: true
  }

  export type AgentRatingCountAggregateInputType = {
    id?: true
    orderId?: true
    agentId?: true
    partnerId?: true
    rating?: true
    comment?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type AgentRatingAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which AgentRating to aggregate.
     */
    where?: AgentRatingWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of AgentRatings to fetch.
     */
    orderBy?: AgentRatingOrderByWithRelationInput | AgentRatingOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: AgentRatingWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` AgentRatings from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` AgentRatings.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned AgentRatings
    **/
    _count?: true | AgentRatingCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: AgentRatingAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: AgentRatingSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: AgentRatingMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: AgentRatingMaxAggregateInputType
  }

  export type GetAgentRatingAggregateType<T extends AgentRatingAggregateArgs> = {
        [P in keyof T & keyof AggregateAgentRating]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateAgentRating[P]>
      : GetScalarType<T[P], AggregateAgentRating[P]>
  }




  export type AgentRatingGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: AgentRatingWhereInput
    orderBy?: AgentRatingOrderByWithAggregationInput | AgentRatingOrderByWithAggregationInput[]
    by: AgentRatingScalarFieldEnum[] | AgentRatingScalarFieldEnum
    having?: AgentRatingScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: AgentRatingCountAggregateInputType | true
    _avg?: AgentRatingAvgAggregateInputType
    _sum?: AgentRatingSumAggregateInputType
    _min?: AgentRatingMinAggregateInputType
    _max?: AgentRatingMaxAggregateInputType
  }

  export type AgentRatingGroupByOutputType = {
    id: string
    orderId: string
    agentId: string
    partnerId: string
    rating: number
    comment: string | null
    createdAt: Date
    updatedAt: Date
    _count: AgentRatingCountAggregateOutputType | null
    _avg: AgentRatingAvgAggregateOutputType | null
    _sum: AgentRatingSumAggregateOutputType | null
    _min: AgentRatingMinAggregateOutputType | null
    _max: AgentRatingMaxAggregateOutputType | null
  }

  type GetAgentRatingGroupByPayload<T extends AgentRatingGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<AgentRatingGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof AgentRatingGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], AgentRatingGroupByOutputType[P]>
            : GetScalarType<T[P], AgentRatingGroupByOutputType[P]>
        }
      >
    >


  export type AgentRatingSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    orderId?: boolean
    agentId?: boolean
    partnerId?: boolean
    rating?: boolean
    comment?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    order?: boolean | OrderDefaultArgs<ExtArgs>
    agent?: boolean | AgentDefaultArgs<ExtArgs>
    partner?: boolean | PartnerDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["agentRating"]>

  export type AgentRatingSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    orderId?: boolean
    agentId?: boolean
    partnerId?: boolean
    rating?: boolean
    comment?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    order?: boolean | OrderDefaultArgs<ExtArgs>
    agent?: boolean | AgentDefaultArgs<ExtArgs>
    partner?: boolean | PartnerDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["agentRating"]>

  export type AgentRatingSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    orderId?: boolean
    agentId?: boolean
    partnerId?: boolean
    rating?: boolean
    comment?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    order?: boolean | OrderDefaultArgs<ExtArgs>
    agent?: boolean | AgentDefaultArgs<ExtArgs>
    partner?: boolean | PartnerDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["agentRating"]>

  export type AgentRatingSelectScalar = {
    id?: boolean
    orderId?: boolean
    agentId?: boolean
    partnerId?: boolean
    rating?: boolean
    comment?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type AgentRatingOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "orderId" | "agentId" | "partnerId" | "rating" | "comment" | "createdAt" | "updatedAt", ExtArgs["result"]["agentRating"]>
  export type AgentRatingInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    order?: boolean | OrderDefaultArgs<ExtArgs>
    agent?: boolean | AgentDefaultArgs<ExtArgs>
    partner?: boolean | PartnerDefaultArgs<ExtArgs>
  }
  export type AgentRatingIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    order?: boolean | OrderDefaultArgs<ExtArgs>
    agent?: boolean | AgentDefaultArgs<ExtArgs>
    partner?: boolean | PartnerDefaultArgs<ExtArgs>
  }
  export type AgentRatingIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    order?: boolean | OrderDefaultArgs<ExtArgs>
    agent?: boolean | AgentDefaultArgs<ExtArgs>
    partner?: boolean | PartnerDefaultArgs<ExtArgs>
  }

  export type $AgentRatingPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "AgentRating"
    objects: {
      order: Prisma.$OrderPayload<ExtArgs>
      agent: Prisma.$AgentPayload<ExtArgs>
      partner: Prisma.$PartnerPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      orderId: string
      agentId: string
      partnerId: string
      rating: number
      comment: string | null
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["agentRating"]>
    composites: {}
  }

  type AgentRatingGetPayload<S extends boolean | null | undefined | AgentRatingDefaultArgs> = $Result.GetResult<Prisma.$AgentRatingPayload, S>

  type AgentRatingCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<AgentRatingFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: AgentRatingCountAggregateInputType | true
    }

  export interface AgentRatingDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['AgentRating'], meta: { name: 'AgentRating' } }
    /**
     * Find zero or one AgentRating that matches the filter.
     * @param {AgentRatingFindUniqueArgs} args - Arguments to find a AgentRating
     * @example
     * // Get one AgentRating
     * const agentRating = await prisma.agentRating.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends AgentRatingFindUniqueArgs>(args: SelectSubset<T, AgentRatingFindUniqueArgs<ExtArgs>>): Prisma__AgentRatingClient<$Result.GetResult<Prisma.$AgentRatingPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one AgentRating that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {AgentRatingFindUniqueOrThrowArgs} args - Arguments to find a AgentRating
     * @example
     * // Get one AgentRating
     * const agentRating = await prisma.agentRating.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends AgentRatingFindUniqueOrThrowArgs>(args: SelectSubset<T, AgentRatingFindUniqueOrThrowArgs<ExtArgs>>): Prisma__AgentRatingClient<$Result.GetResult<Prisma.$AgentRatingPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first AgentRating that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AgentRatingFindFirstArgs} args - Arguments to find a AgentRating
     * @example
     * // Get one AgentRating
     * const agentRating = await prisma.agentRating.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends AgentRatingFindFirstArgs>(args?: SelectSubset<T, AgentRatingFindFirstArgs<ExtArgs>>): Prisma__AgentRatingClient<$Result.GetResult<Prisma.$AgentRatingPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first AgentRating that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AgentRatingFindFirstOrThrowArgs} args - Arguments to find a AgentRating
     * @example
     * // Get one AgentRating
     * const agentRating = await prisma.agentRating.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends AgentRatingFindFirstOrThrowArgs>(args?: SelectSubset<T, AgentRatingFindFirstOrThrowArgs<ExtArgs>>): Prisma__AgentRatingClient<$Result.GetResult<Prisma.$AgentRatingPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more AgentRatings that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AgentRatingFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all AgentRatings
     * const agentRatings = await prisma.agentRating.findMany()
     * 
     * // Get first 10 AgentRatings
     * const agentRatings = await prisma.agentRating.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const agentRatingWithIdOnly = await prisma.agentRating.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends AgentRatingFindManyArgs>(args?: SelectSubset<T, AgentRatingFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AgentRatingPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a AgentRating.
     * @param {AgentRatingCreateArgs} args - Arguments to create a AgentRating.
     * @example
     * // Create one AgentRating
     * const AgentRating = await prisma.agentRating.create({
     *   data: {
     *     // ... data to create a AgentRating
     *   }
     * })
     * 
     */
    create<T extends AgentRatingCreateArgs>(args: SelectSubset<T, AgentRatingCreateArgs<ExtArgs>>): Prisma__AgentRatingClient<$Result.GetResult<Prisma.$AgentRatingPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many AgentRatings.
     * @param {AgentRatingCreateManyArgs} args - Arguments to create many AgentRatings.
     * @example
     * // Create many AgentRatings
     * const agentRating = await prisma.agentRating.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends AgentRatingCreateManyArgs>(args?: SelectSubset<T, AgentRatingCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many AgentRatings and returns the data saved in the database.
     * @param {AgentRatingCreateManyAndReturnArgs} args - Arguments to create many AgentRatings.
     * @example
     * // Create many AgentRatings
     * const agentRating = await prisma.agentRating.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many AgentRatings and only return the `id`
     * const agentRatingWithIdOnly = await prisma.agentRating.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends AgentRatingCreateManyAndReturnArgs>(args?: SelectSubset<T, AgentRatingCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AgentRatingPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a AgentRating.
     * @param {AgentRatingDeleteArgs} args - Arguments to delete one AgentRating.
     * @example
     * // Delete one AgentRating
     * const AgentRating = await prisma.agentRating.delete({
     *   where: {
     *     // ... filter to delete one AgentRating
     *   }
     * })
     * 
     */
    delete<T extends AgentRatingDeleteArgs>(args: SelectSubset<T, AgentRatingDeleteArgs<ExtArgs>>): Prisma__AgentRatingClient<$Result.GetResult<Prisma.$AgentRatingPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one AgentRating.
     * @param {AgentRatingUpdateArgs} args - Arguments to update one AgentRating.
     * @example
     * // Update one AgentRating
     * const agentRating = await prisma.agentRating.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends AgentRatingUpdateArgs>(args: SelectSubset<T, AgentRatingUpdateArgs<ExtArgs>>): Prisma__AgentRatingClient<$Result.GetResult<Prisma.$AgentRatingPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more AgentRatings.
     * @param {AgentRatingDeleteManyArgs} args - Arguments to filter AgentRatings to delete.
     * @example
     * // Delete a few AgentRatings
     * const { count } = await prisma.agentRating.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends AgentRatingDeleteManyArgs>(args?: SelectSubset<T, AgentRatingDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more AgentRatings.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AgentRatingUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many AgentRatings
     * const agentRating = await prisma.agentRating.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends AgentRatingUpdateManyArgs>(args: SelectSubset<T, AgentRatingUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more AgentRatings and returns the data updated in the database.
     * @param {AgentRatingUpdateManyAndReturnArgs} args - Arguments to update many AgentRatings.
     * @example
     * // Update many AgentRatings
     * const agentRating = await prisma.agentRating.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more AgentRatings and only return the `id`
     * const agentRatingWithIdOnly = await prisma.agentRating.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends AgentRatingUpdateManyAndReturnArgs>(args: SelectSubset<T, AgentRatingUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AgentRatingPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one AgentRating.
     * @param {AgentRatingUpsertArgs} args - Arguments to update or create a AgentRating.
     * @example
     * // Update or create a AgentRating
     * const agentRating = await prisma.agentRating.upsert({
     *   create: {
     *     // ... data to create a AgentRating
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the AgentRating we want to update
     *   }
     * })
     */
    upsert<T extends AgentRatingUpsertArgs>(args: SelectSubset<T, AgentRatingUpsertArgs<ExtArgs>>): Prisma__AgentRatingClient<$Result.GetResult<Prisma.$AgentRatingPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of AgentRatings.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AgentRatingCountArgs} args - Arguments to filter AgentRatings to count.
     * @example
     * // Count the number of AgentRatings
     * const count = await prisma.agentRating.count({
     *   where: {
     *     // ... the filter for the AgentRatings we want to count
     *   }
     * })
    **/
    count<T extends AgentRatingCountArgs>(
      args?: Subset<T, AgentRatingCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], AgentRatingCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a AgentRating.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AgentRatingAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends AgentRatingAggregateArgs>(args: Subset<T, AgentRatingAggregateArgs>): Prisma.PrismaPromise<GetAgentRatingAggregateType<T>>

    /**
     * Group by AgentRating.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AgentRatingGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends AgentRatingGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: AgentRatingGroupByArgs['orderBy'] }
        : { orderBy?: AgentRatingGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, AgentRatingGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetAgentRatingGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the AgentRating model
   */
  readonly fields: AgentRatingFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for AgentRating.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__AgentRatingClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    order<T extends OrderDefaultArgs<ExtArgs> = {}>(args?: Subset<T, OrderDefaultArgs<ExtArgs>>): Prisma__OrderClient<$Result.GetResult<Prisma.$OrderPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    agent<T extends AgentDefaultArgs<ExtArgs> = {}>(args?: Subset<T, AgentDefaultArgs<ExtArgs>>): Prisma__AgentClient<$Result.GetResult<Prisma.$AgentPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    partner<T extends PartnerDefaultArgs<ExtArgs> = {}>(args?: Subset<T, PartnerDefaultArgs<ExtArgs>>): Prisma__PartnerClient<$Result.GetResult<Prisma.$PartnerPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the AgentRating model
   */
  interface AgentRatingFieldRefs {
    readonly id: FieldRef<"AgentRating", 'String'>
    readonly orderId: FieldRef<"AgentRating", 'String'>
    readonly agentId: FieldRef<"AgentRating", 'String'>
    readonly partnerId: FieldRef<"AgentRating", 'String'>
    readonly rating: FieldRef<"AgentRating", 'Int'>
    readonly comment: FieldRef<"AgentRating", 'String'>
    readonly createdAt: FieldRef<"AgentRating", 'DateTime'>
    readonly updatedAt: FieldRef<"AgentRating", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * AgentRating findUnique
   */
  export type AgentRatingFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AgentRating
     */
    select?: AgentRatingSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AgentRating
     */
    omit?: AgentRatingOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AgentRatingInclude<ExtArgs> | null
    /**
     * Filter, which AgentRating to fetch.
     */
    where: AgentRatingWhereUniqueInput
  }

  /**
   * AgentRating findUniqueOrThrow
   */
  export type AgentRatingFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AgentRating
     */
    select?: AgentRatingSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AgentRating
     */
    omit?: AgentRatingOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AgentRatingInclude<ExtArgs> | null
    /**
     * Filter, which AgentRating to fetch.
     */
    where: AgentRatingWhereUniqueInput
  }

  /**
   * AgentRating findFirst
   */
  export type AgentRatingFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AgentRating
     */
    select?: AgentRatingSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AgentRating
     */
    omit?: AgentRatingOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AgentRatingInclude<ExtArgs> | null
    /**
     * Filter, which AgentRating to fetch.
     */
    where?: AgentRatingWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of AgentRatings to fetch.
     */
    orderBy?: AgentRatingOrderByWithRelationInput | AgentRatingOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for AgentRatings.
     */
    cursor?: AgentRatingWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` AgentRatings from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` AgentRatings.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of AgentRatings.
     */
    distinct?: AgentRatingScalarFieldEnum | AgentRatingScalarFieldEnum[]
  }

  /**
   * AgentRating findFirstOrThrow
   */
  export type AgentRatingFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AgentRating
     */
    select?: AgentRatingSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AgentRating
     */
    omit?: AgentRatingOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AgentRatingInclude<ExtArgs> | null
    /**
     * Filter, which AgentRating to fetch.
     */
    where?: AgentRatingWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of AgentRatings to fetch.
     */
    orderBy?: AgentRatingOrderByWithRelationInput | AgentRatingOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for AgentRatings.
     */
    cursor?: AgentRatingWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` AgentRatings from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` AgentRatings.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of AgentRatings.
     */
    distinct?: AgentRatingScalarFieldEnum | AgentRatingScalarFieldEnum[]
  }

  /**
   * AgentRating findMany
   */
  export type AgentRatingFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AgentRating
     */
    select?: AgentRatingSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AgentRating
     */
    omit?: AgentRatingOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AgentRatingInclude<ExtArgs> | null
    /**
     * Filter, which AgentRatings to fetch.
     */
    where?: AgentRatingWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of AgentRatings to fetch.
     */
    orderBy?: AgentRatingOrderByWithRelationInput | AgentRatingOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing AgentRatings.
     */
    cursor?: AgentRatingWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` AgentRatings from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` AgentRatings.
     */
    skip?: number
    distinct?: AgentRatingScalarFieldEnum | AgentRatingScalarFieldEnum[]
  }

  /**
   * AgentRating create
   */
  export type AgentRatingCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AgentRating
     */
    select?: AgentRatingSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AgentRating
     */
    omit?: AgentRatingOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AgentRatingInclude<ExtArgs> | null
    /**
     * The data needed to create a AgentRating.
     */
    data: XOR<AgentRatingCreateInput, AgentRatingUncheckedCreateInput>
  }

  /**
   * AgentRating createMany
   */
  export type AgentRatingCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many AgentRatings.
     */
    data: AgentRatingCreateManyInput | AgentRatingCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * AgentRating createManyAndReturn
   */
  export type AgentRatingCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AgentRating
     */
    select?: AgentRatingSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the AgentRating
     */
    omit?: AgentRatingOmit<ExtArgs> | null
    /**
     * The data used to create many AgentRatings.
     */
    data: AgentRatingCreateManyInput | AgentRatingCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AgentRatingIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * AgentRating update
   */
  export type AgentRatingUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AgentRating
     */
    select?: AgentRatingSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AgentRating
     */
    omit?: AgentRatingOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AgentRatingInclude<ExtArgs> | null
    /**
     * The data needed to update a AgentRating.
     */
    data: XOR<AgentRatingUpdateInput, AgentRatingUncheckedUpdateInput>
    /**
     * Choose, which AgentRating to update.
     */
    where: AgentRatingWhereUniqueInput
  }

  /**
   * AgentRating updateMany
   */
  export type AgentRatingUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update AgentRatings.
     */
    data: XOR<AgentRatingUpdateManyMutationInput, AgentRatingUncheckedUpdateManyInput>
    /**
     * Filter which AgentRatings to update
     */
    where?: AgentRatingWhereInput
    /**
     * Limit how many AgentRatings to update.
     */
    limit?: number
  }

  /**
   * AgentRating updateManyAndReturn
   */
  export type AgentRatingUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AgentRating
     */
    select?: AgentRatingSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the AgentRating
     */
    omit?: AgentRatingOmit<ExtArgs> | null
    /**
     * The data used to update AgentRatings.
     */
    data: XOR<AgentRatingUpdateManyMutationInput, AgentRatingUncheckedUpdateManyInput>
    /**
     * Filter which AgentRatings to update
     */
    where?: AgentRatingWhereInput
    /**
     * Limit how many AgentRatings to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AgentRatingIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * AgentRating upsert
   */
  export type AgentRatingUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AgentRating
     */
    select?: AgentRatingSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AgentRating
     */
    omit?: AgentRatingOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AgentRatingInclude<ExtArgs> | null
    /**
     * The filter to search for the AgentRating to update in case it exists.
     */
    where: AgentRatingWhereUniqueInput
    /**
     * In case the AgentRating found by the `where` argument doesn't exist, create a new AgentRating with this data.
     */
    create: XOR<AgentRatingCreateInput, AgentRatingUncheckedCreateInput>
    /**
     * In case the AgentRating was found with the provided `where` argument, update it with this data.
     */
    update: XOR<AgentRatingUpdateInput, AgentRatingUncheckedUpdateInput>
  }

  /**
   * AgentRating delete
   */
  export type AgentRatingDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AgentRating
     */
    select?: AgentRatingSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AgentRating
     */
    omit?: AgentRatingOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AgentRatingInclude<ExtArgs> | null
    /**
     * Filter which AgentRating to delete.
     */
    where: AgentRatingWhereUniqueInput
  }

  /**
   * AgentRating deleteMany
   */
  export type AgentRatingDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which AgentRatings to delete
     */
    where?: AgentRatingWhereInput
    /**
     * Limit how many AgentRatings to delete.
     */
    limit?: number
  }

  /**
   * AgentRating without action
   */
  export type AgentRatingDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AgentRating
     */
    select?: AgentRatingSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AgentRating
     */
    omit?: AgentRatingOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AgentRatingInclude<ExtArgs> | null
  }


  /**
   * Model Payment
   */

  export type AggregatePayment = {
    _count: PaymentCountAggregateOutputType | null
    _avg: PaymentAvgAggregateOutputType | null
    _sum: PaymentSumAggregateOutputType | null
    _min: PaymentMinAggregateOutputType | null
    _max: PaymentMaxAggregateOutputType | null
  }

  export type PaymentAvgAggregateOutputType = {
    amount: number | null
  }

  export type PaymentSumAggregateOutputType = {
    amount: number | null
  }

  export type PaymentMinAggregateOutputType = {
    id: string | null
    agentId: string | null
    orderId: string | null
    amount: number | null
    paymentType: string | null
    status: string | null
    processedAt: Date | null
    paymentMethod: string | null
    transactionId: string | null
    notes: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type PaymentMaxAggregateOutputType = {
    id: string | null
    agentId: string | null
    orderId: string | null
    amount: number | null
    paymentType: string | null
    status: string | null
    processedAt: Date | null
    paymentMethod: string | null
    transactionId: string | null
    notes: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type PaymentCountAggregateOutputType = {
    id: number
    agentId: number
    orderId: number
    amount: number
    paymentType: number
    status: number
    processedAt: number
    paymentMethod: number
    transactionId: number
    notes: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type PaymentAvgAggregateInputType = {
    amount?: true
  }

  export type PaymentSumAggregateInputType = {
    amount?: true
  }

  export type PaymentMinAggregateInputType = {
    id?: true
    agentId?: true
    orderId?: true
    amount?: true
    paymentType?: true
    status?: true
    processedAt?: true
    paymentMethod?: true
    transactionId?: true
    notes?: true
    createdAt?: true
    updatedAt?: true
  }

  export type PaymentMaxAggregateInputType = {
    id?: true
    agentId?: true
    orderId?: true
    amount?: true
    paymentType?: true
    status?: true
    processedAt?: true
    paymentMethod?: true
    transactionId?: true
    notes?: true
    createdAt?: true
    updatedAt?: true
  }

  export type PaymentCountAggregateInputType = {
    id?: true
    agentId?: true
    orderId?: true
    amount?: true
    paymentType?: true
    status?: true
    processedAt?: true
    paymentMethod?: true
    transactionId?: true
    notes?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type PaymentAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Payment to aggregate.
     */
    where?: PaymentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Payments to fetch.
     */
    orderBy?: PaymentOrderByWithRelationInput | PaymentOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: PaymentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Payments from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Payments.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Payments
    **/
    _count?: true | PaymentCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: PaymentAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: PaymentSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: PaymentMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: PaymentMaxAggregateInputType
  }

  export type GetPaymentAggregateType<T extends PaymentAggregateArgs> = {
        [P in keyof T & keyof AggregatePayment]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregatePayment[P]>
      : GetScalarType<T[P], AggregatePayment[P]>
  }




  export type PaymentGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: PaymentWhereInput
    orderBy?: PaymentOrderByWithAggregationInput | PaymentOrderByWithAggregationInput[]
    by: PaymentScalarFieldEnum[] | PaymentScalarFieldEnum
    having?: PaymentScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: PaymentCountAggregateInputType | true
    _avg?: PaymentAvgAggregateInputType
    _sum?: PaymentSumAggregateInputType
    _min?: PaymentMinAggregateInputType
    _max?: PaymentMaxAggregateInputType
  }

  export type PaymentGroupByOutputType = {
    id: string
    agentId: string
    orderId: string
    amount: number
    paymentType: string
    status: string
    processedAt: Date | null
    paymentMethod: string | null
    transactionId: string | null
    notes: string | null
    createdAt: Date
    updatedAt: Date
    _count: PaymentCountAggregateOutputType | null
    _avg: PaymentAvgAggregateOutputType | null
    _sum: PaymentSumAggregateOutputType | null
    _min: PaymentMinAggregateOutputType | null
    _max: PaymentMaxAggregateOutputType | null
  }

  type GetPaymentGroupByPayload<T extends PaymentGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<PaymentGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof PaymentGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], PaymentGroupByOutputType[P]>
            : GetScalarType<T[P], PaymentGroupByOutputType[P]>
        }
      >
    >


  export type PaymentSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    agentId?: boolean
    orderId?: boolean
    amount?: boolean
    paymentType?: boolean
    status?: boolean
    processedAt?: boolean
    paymentMethod?: boolean
    transactionId?: boolean
    notes?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    agent?: boolean | AgentDefaultArgs<ExtArgs>
    order?: boolean | OrderDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["payment"]>

  export type PaymentSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    agentId?: boolean
    orderId?: boolean
    amount?: boolean
    paymentType?: boolean
    status?: boolean
    processedAt?: boolean
    paymentMethod?: boolean
    transactionId?: boolean
    notes?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    agent?: boolean | AgentDefaultArgs<ExtArgs>
    order?: boolean | OrderDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["payment"]>

  export type PaymentSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    agentId?: boolean
    orderId?: boolean
    amount?: boolean
    paymentType?: boolean
    status?: boolean
    processedAt?: boolean
    paymentMethod?: boolean
    transactionId?: boolean
    notes?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    agent?: boolean | AgentDefaultArgs<ExtArgs>
    order?: boolean | OrderDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["payment"]>

  export type PaymentSelectScalar = {
    id?: boolean
    agentId?: boolean
    orderId?: boolean
    amount?: boolean
    paymentType?: boolean
    status?: boolean
    processedAt?: boolean
    paymentMethod?: boolean
    transactionId?: boolean
    notes?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type PaymentOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "agentId" | "orderId" | "amount" | "paymentType" | "status" | "processedAt" | "paymentMethod" | "transactionId" | "notes" | "createdAt" | "updatedAt", ExtArgs["result"]["payment"]>
  export type PaymentInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    agent?: boolean | AgentDefaultArgs<ExtArgs>
    order?: boolean | OrderDefaultArgs<ExtArgs>
  }
  export type PaymentIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    agent?: boolean | AgentDefaultArgs<ExtArgs>
    order?: boolean | OrderDefaultArgs<ExtArgs>
  }
  export type PaymentIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    agent?: boolean | AgentDefaultArgs<ExtArgs>
    order?: boolean | OrderDefaultArgs<ExtArgs>
  }

  export type $PaymentPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Payment"
    objects: {
      agent: Prisma.$AgentPayload<ExtArgs>
      order: Prisma.$OrderPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      agentId: string
      orderId: string
      amount: number
      paymentType: string
      status: string
      processedAt: Date | null
      paymentMethod: string | null
      transactionId: string | null
      notes: string | null
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["payment"]>
    composites: {}
  }

  type PaymentGetPayload<S extends boolean | null | undefined | PaymentDefaultArgs> = $Result.GetResult<Prisma.$PaymentPayload, S>

  type PaymentCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<PaymentFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: PaymentCountAggregateInputType | true
    }

  export interface PaymentDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Payment'], meta: { name: 'Payment' } }
    /**
     * Find zero or one Payment that matches the filter.
     * @param {PaymentFindUniqueArgs} args - Arguments to find a Payment
     * @example
     * // Get one Payment
     * const payment = await prisma.payment.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends PaymentFindUniqueArgs>(args: SelectSubset<T, PaymentFindUniqueArgs<ExtArgs>>): Prisma__PaymentClient<$Result.GetResult<Prisma.$PaymentPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Payment that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {PaymentFindUniqueOrThrowArgs} args - Arguments to find a Payment
     * @example
     * // Get one Payment
     * const payment = await prisma.payment.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends PaymentFindUniqueOrThrowArgs>(args: SelectSubset<T, PaymentFindUniqueOrThrowArgs<ExtArgs>>): Prisma__PaymentClient<$Result.GetResult<Prisma.$PaymentPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Payment that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PaymentFindFirstArgs} args - Arguments to find a Payment
     * @example
     * // Get one Payment
     * const payment = await prisma.payment.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends PaymentFindFirstArgs>(args?: SelectSubset<T, PaymentFindFirstArgs<ExtArgs>>): Prisma__PaymentClient<$Result.GetResult<Prisma.$PaymentPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Payment that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PaymentFindFirstOrThrowArgs} args - Arguments to find a Payment
     * @example
     * // Get one Payment
     * const payment = await prisma.payment.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends PaymentFindFirstOrThrowArgs>(args?: SelectSubset<T, PaymentFindFirstOrThrowArgs<ExtArgs>>): Prisma__PaymentClient<$Result.GetResult<Prisma.$PaymentPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Payments that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PaymentFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Payments
     * const payments = await prisma.payment.findMany()
     * 
     * // Get first 10 Payments
     * const payments = await prisma.payment.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const paymentWithIdOnly = await prisma.payment.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends PaymentFindManyArgs>(args?: SelectSubset<T, PaymentFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PaymentPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Payment.
     * @param {PaymentCreateArgs} args - Arguments to create a Payment.
     * @example
     * // Create one Payment
     * const Payment = await prisma.payment.create({
     *   data: {
     *     // ... data to create a Payment
     *   }
     * })
     * 
     */
    create<T extends PaymentCreateArgs>(args: SelectSubset<T, PaymentCreateArgs<ExtArgs>>): Prisma__PaymentClient<$Result.GetResult<Prisma.$PaymentPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Payments.
     * @param {PaymentCreateManyArgs} args - Arguments to create many Payments.
     * @example
     * // Create many Payments
     * const payment = await prisma.payment.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends PaymentCreateManyArgs>(args?: SelectSubset<T, PaymentCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Payments and returns the data saved in the database.
     * @param {PaymentCreateManyAndReturnArgs} args - Arguments to create many Payments.
     * @example
     * // Create many Payments
     * const payment = await prisma.payment.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Payments and only return the `id`
     * const paymentWithIdOnly = await prisma.payment.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends PaymentCreateManyAndReturnArgs>(args?: SelectSubset<T, PaymentCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PaymentPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Payment.
     * @param {PaymentDeleteArgs} args - Arguments to delete one Payment.
     * @example
     * // Delete one Payment
     * const Payment = await prisma.payment.delete({
     *   where: {
     *     // ... filter to delete one Payment
     *   }
     * })
     * 
     */
    delete<T extends PaymentDeleteArgs>(args: SelectSubset<T, PaymentDeleteArgs<ExtArgs>>): Prisma__PaymentClient<$Result.GetResult<Prisma.$PaymentPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Payment.
     * @param {PaymentUpdateArgs} args - Arguments to update one Payment.
     * @example
     * // Update one Payment
     * const payment = await prisma.payment.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends PaymentUpdateArgs>(args: SelectSubset<T, PaymentUpdateArgs<ExtArgs>>): Prisma__PaymentClient<$Result.GetResult<Prisma.$PaymentPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Payments.
     * @param {PaymentDeleteManyArgs} args - Arguments to filter Payments to delete.
     * @example
     * // Delete a few Payments
     * const { count } = await prisma.payment.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends PaymentDeleteManyArgs>(args?: SelectSubset<T, PaymentDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Payments.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PaymentUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Payments
     * const payment = await prisma.payment.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends PaymentUpdateManyArgs>(args: SelectSubset<T, PaymentUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Payments and returns the data updated in the database.
     * @param {PaymentUpdateManyAndReturnArgs} args - Arguments to update many Payments.
     * @example
     * // Update many Payments
     * const payment = await prisma.payment.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Payments and only return the `id`
     * const paymentWithIdOnly = await prisma.payment.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends PaymentUpdateManyAndReturnArgs>(args: SelectSubset<T, PaymentUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PaymentPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Payment.
     * @param {PaymentUpsertArgs} args - Arguments to update or create a Payment.
     * @example
     * // Update or create a Payment
     * const payment = await prisma.payment.upsert({
     *   create: {
     *     // ... data to create a Payment
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Payment we want to update
     *   }
     * })
     */
    upsert<T extends PaymentUpsertArgs>(args: SelectSubset<T, PaymentUpsertArgs<ExtArgs>>): Prisma__PaymentClient<$Result.GetResult<Prisma.$PaymentPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Payments.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PaymentCountArgs} args - Arguments to filter Payments to count.
     * @example
     * // Count the number of Payments
     * const count = await prisma.payment.count({
     *   where: {
     *     // ... the filter for the Payments we want to count
     *   }
     * })
    **/
    count<T extends PaymentCountArgs>(
      args?: Subset<T, PaymentCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], PaymentCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Payment.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PaymentAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends PaymentAggregateArgs>(args: Subset<T, PaymentAggregateArgs>): Prisma.PrismaPromise<GetPaymentAggregateType<T>>

    /**
     * Group by Payment.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PaymentGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends PaymentGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: PaymentGroupByArgs['orderBy'] }
        : { orderBy?: PaymentGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, PaymentGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetPaymentGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Payment model
   */
  readonly fields: PaymentFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Payment.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__PaymentClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    agent<T extends AgentDefaultArgs<ExtArgs> = {}>(args?: Subset<T, AgentDefaultArgs<ExtArgs>>): Prisma__AgentClient<$Result.GetResult<Prisma.$AgentPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    order<T extends OrderDefaultArgs<ExtArgs> = {}>(args?: Subset<T, OrderDefaultArgs<ExtArgs>>): Prisma__OrderClient<$Result.GetResult<Prisma.$OrderPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Payment model
   */
  interface PaymentFieldRefs {
    readonly id: FieldRef<"Payment", 'String'>
    readonly agentId: FieldRef<"Payment", 'String'>
    readonly orderId: FieldRef<"Payment", 'String'>
    readonly amount: FieldRef<"Payment", 'Float'>
    readonly paymentType: FieldRef<"Payment", 'String'>
    readonly status: FieldRef<"Payment", 'String'>
    readonly processedAt: FieldRef<"Payment", 'DateTime'>
    readonly paymentMethod: FieldRef<"Payment", 'String'>
    readonly transactionId: FieldRef<"Payment", 'String'>
    readonly notes: FieldRef<"Payment", 'String'>
    readonly createdAt: FieldRef<"Payment", 'DateTime'>
    readonly updatedAt: FieldRef<"Payment", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Payment findUnique
   */
  export type PaymentFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Payment
     */
    select?: PaymentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Payment
     */
    omit?: PaymentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PaymentInclude<ExtArgs> | null
    /**
     * Filter, which Payment to fetch.
     */
    where: PaymentWhereUniqueInput
  }

  /**
   * Payment findUniqueOrThrow
   */
  export type PaymentFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Payment
     */
    select?: PaymentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Payment
     */
    omit?: PaymentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PaymentInclude<ExtArgs> | null
    /**
     * Filter, which Payment to fetch.
     */
    where: PaymentWhereUniqueInput
  }

  /**
   * Payment findFirst
   */
  export type PaymentFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Payment
     */
    select?: PaymentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Payment
     */
    omit?: PaymentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PaymentInclude<ExtArgs> | null
    /**
     * Filter, which Payment to fetch.
     */
    where?: PaymentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Payments to fetch.
     */
    orderBy?: PaymentOrderByWithRelationInput | PaymentOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Payments.
     */
    cursor?: PaymentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Payments from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Payments.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Payments.
     */
    distinct?: PaymentScalarFieldEnum | PaymentScalarFieldEnum[]
  }

  /**
   * Payment findFirstOrThrow
   */
  export type PaymentFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Payment
     */
    select?: PaymentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Payment
     */
    omit?: PaymentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PaymentInclude<ExtArgs> | null
    /**
     * Filter, which Payment to fetch.
     */
    where?: PaymentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Payments to fetch.
     */
    orderBy?: PaymentOrderByWithRelationInput | PaymentOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Payments.
     */
    cursor?: PaymentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Payments from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Payments.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Payments.
     */
    distinct?: PaymentScalarFieldEnum | PaymentScalarFieldEnum[]
  }

  /**
   * Payment findMany
   */
  export type PaymentFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Payment
     */
    select?: PaymentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Payment
     */
    omit?: PaymentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PaymentInclude<ExtArgs> | null
    /**
     * Filter, which Payments to fetch.
     */
    where?: PaymentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Payments to fetch.
     */
    orderBy?: PaymentOrderByWithRelationInput | PaymentOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Payments.
     */
    cursor?: PaymentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Payments from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Payments.
     */
    skip?: number
    distinct?: PaymentScalarFieldEnum | PaymentScalarFieldEnum[]
  }

  /**
   * Payment create
   */
  export type PaymentCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Payment
     */
    select?: PaymentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Payment
     */
    omit?: PaymentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PaymentInclude<ExtArgs> | null
    /**
     * The data needed to create a Payment.
     */
    data: XOR<PaymentCreateInput, PaymentUncheckedCreateInput>
  }

  /**
   * Payment createMany
   */
  export type PaymentCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Payments.
     */
    data: PaymentCreateManyInput | PaymentCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Payment createManyAndReturn
   */
  export type PaymentCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Payment
     */
    select?: PaymentSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Payment
     */
    omit?: PaymentOmit<ExtArgs> | null
    /**
     * The data used to create many Payments.
     */
    data: PaymentCreateManyInput | PaymentCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PaymentIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Payment update
   */
  export type PaymentUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Payment
     */
    select?: PaymentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Payment
     */
    omit?: PaymentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PaymentInclude<ExtArgs> | null
    /**
     * The data needed to update a Payment.
     */
    data: XOR<PaymentUpdateInput, PaymentUncheckedUpdateInput>
    /**
     * Choose, which Payment to update.
     */
    where: PaymentWhereUniqueInput
  }

  /**
   * Payment updateMany
   */
  export type PaymentUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Payments.
     */
    data: XOR<PaymentUpdateManyMutationInput, PaymentUncheckedUpdateManyInput>
    /**
     * Filter which Payments to update
     */
    where?: PaymentWhereInput
    /**
     * Limit how many Payments to update.
     */
    limit?: number
  }

  /**
   * Payment updateManyAndReturn
   */
  export type PaymentUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Payment
     */
    select?: PaymentSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Payment
     */
    omit?: PaymentOmit<ExtArgs> | null
    /**
     * The data used to update Payments.
     */
    data: XOR<PaymentUpdateManyMutationInput, PaymentUncheckedUpdateManyInput>
    /**
     * Filter which Payments to update
     */
    where?: PaymentWhereInput
    /**
     * Limit how many Payments to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PaymentIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * Payment upsert
   */
  export type PaymentUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Payment
     */
    select?: PaymentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Payment
     */
    omit?: PaymentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PaymentInclude<ExtArgs> | null
    /**
     * The filter to search for the Payment to update in case it exists.
     */
    where: PaymentWhereUniqueInput
    /**
     * In case the Payment found by the `where` argument doesn't exist, create a new Payment with this data.
     */
    create: XOR<PaymentCreateInput, PaymentUncheckedCreateInput>
    /**
     * In case the Payment was found with the provided `where` argument, update it with this data.
     */
    update: XOR<PaymentUpdateInput, PaymentUncheckedUpdateInput>
  }

  /**
   * Payment delete
   */
  export type PaymentDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Payment
     */
    select?: PaymentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Payment
     */
    omit?: PaymentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PaymentInclude<ExtArgs> | null
    /**
     * Filter which Payment to delete.
     */
    where: PaymentWhereUniqueInput
  }

  /**
   * Payment deleteMany
   */
  export type PaymentDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Payments to delete
     */
    where?: PaymentWhereInput
    /**
     * Limit how many Payments to delete.
     */
    limit?: number
  }

  /**
   * Payment without action
   */
  export type PaymentDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Payment
     */
    select?: PaymentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Payment
     */
    omit?: PaymentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PaymentInclude<ExtArgs> | null
  }


  /**
   * Model Payroll
   */

  export type AggregatePayroll = {
    _count: PayrollCountAggregateOutputType | null
    _avg: PayrollAvgAggregateOutputType | null
    _sum: PayrollSumAggregateOutputType | null
    _min: PayrollMinAggregateOutputType | null
    _max: PayrollMaxAggregateOutputType | null
  }

  export type PayrollAvgAggregateOutputType = {
    totalEarnings: number | null
    totalOrders: number | null
    basePay: number | null
    bonuses: number | null
    deductions: number | null
    netPay: number | null
  }

  export type PayrollSumAggregateOutputType = {
    totalEarnings: number | null
    totalOrders: number | null
    basePay: number | null
    bonuses: number | null
    deductions: number | null
    netPay: number | null
  }

  export type PayrollMinAggregateOutputType = {
    id: string | null
    agentId: string | null
    periodStart: Date | null
    periodEnd: Date | null
    periodType: string | null
    totalEarnings: number | null
    totalOrders: number | null
    basePay: number | null
    bonuses: number | null
    deductions: number | null
    netPay: number | null
    status: string | null
    processedAt: Date | null
    paidAt: Date | null
    paymentMethod: string | null
    transactionId: string | null
    notes: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type PayrollMaxAggregateOutputType = {
    id: string | null
    agentId: string | null
    periodStart: Date | null
    periodEnd: Date | null
    periodType: string | null
    totalEarnings: number | null
    totalOrders: number | null
    basePay: number | null
    bonuses: number | null
    deductions: number | null
    netPay: number | null
    status: string | null
    processedAt: Date | null
    paidAt: Date | null
    paymentMethod: string | null
    transactionId: string | null
    notes: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type PayrollCountAggregateOutputType = {
    id: number
    agentId: number
    periodStart: number
    periodEnd: number
    periodType: number
    totalEarnings: number
    totalOrders: number
    basePay: number
    bonuses: number
    deductions: number
    netPay: number
    status: number
    processedAt: number
    paidAt: number
    paymentMethod: number
    transactionId: number
    notes: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type PayrollAvgAggregateInputType = {
    totalEarnings?: true
    totalOrders?: true
    basePay?: true
    bonuses?: true
    deductions?: true
    netPay?: true
  }

  export type PayrollSumAggregateInputType = {
    totalEarnings?: true
    totalOrders?: true
    basePay?: true
    bonuses?: true
    deductions?: true
    netPay?: true
  }

  export type PayrollMinAggregateInputType = {
    id?: true
    agentId?: true
    periodStart?: true
    periodEnd?: true
    periodType?: true
    totalEarnings?: true
    totalOrders?: true
    basePay?: true
    bonuses?: true
    deductions?: true
    netPay?: true
    status?: true
    processedAt?: true
    paidAt?: true
    paymentMethod?: true
    transactionId?: true
    notes?: true
    createdAt?: true
    updatedAt?: true
  }

  export type PayrollMaxAggregateInputType = {
    id?: true
    agentId?: true
    periodStart?: true
    periodEnd?: true
    periodType?: true
    totalEarnings?: true
    totalOrders?: true
    basePay?: true
    bonuses?: true
    deductions?: true
    netPay?: true
    status?: true
    processedAt?: true
    paidAt?: true
    paymentMethod?: true
    transactionId?: true
    notes?: true
    createdAt?: true
    updatedAt?: true
  }

  export type PayrollCountAggregateInputType = {
    id?: true
    agentId?: true
    periodStart?: true
    periodEnd?: true
    periodType?: true
    totalEarnings?: true
    totalOrders?: true
    basePay?: true
    bonuses?: true
    deductions?: true
    netPay?: true
    status?: true
    processedAt?: true
    paidAt?: true
    paymentMethod?: true
    transactionId?: true
    notes?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type PayrollAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Payroll to aggregate.
     */
    where?: PayrollWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Payrolls to fetch.
     */
    orderBy?: PayrollOrderByWithRelationInput | PayrollOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: PayrollWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Payrolls from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Payrolls.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Payrolls
    **/
    _count?: true | PayrollCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: PayrollAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: PayrollSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: PayrollMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: PayrollMaxAggregateInputType
  }

  export type GetPayrollAggregateType<T extends PayrollAggregateArgs> = {
        [P in keyof T & keyof AggregatePayroll]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregatePayroll[P]>
      : GetScalarType<T[P], AggregatePayroll[P]>
  }




  export type PayrollGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: PayrollWhereInput
    orderBy?: PayrollOrderByWithAggregationInput | PayrollOrderByWithAggregationInput[]
    by: PayrollScalarFieldEnum[] | PayrollScalarFieldEnum
    having?: PayrollScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: PayrollCountAggregateInputType | true
    _avg?: PayrollAvgAggregateInputType
    _sum?: PayrollSumAggregateInputType
    _min?: PayrollMinAggregateInputType
    _max?: PayrollMaxAggregateInputType
  }

  export type PayrollGroupByOutputType = {
    id: string
    agentId: string
    periodStart: Date
    periodEnd: Date
    periodType: string
    totalEarnings: number
    totalOrders: number
    basePay: number
    bonuses: number
    deductions: number
    netPay: number
    status: string
    processedAt: Date | null
    paidAt: Date | null
    paymentMethod: string | null
    transactionId: string | null
    notes: string | null
    createdAt: Date
    updatedAt: Date
    _count: PayrollCountAggregateOutputType | null
    _avg: PayrollAvgAggregateOutputType | null
    _sum: PayrollSumAggregateOutputType | null
    _min: PayrollMinAggregateOutputType | null
    _max: PayrollMaxAggregateOutputType | null
  }

  type GetPayrollGroupByPayload<T extends PayrollGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<PayrollGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof PayrollGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], PayrollGroupByOutputType[P]>
            : GetScalarType<T[P], PayrollGroupByOutputType[P]>
        }
      >
    >


  export type PayrollSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    agentId?: boolean
    periodStart?: boolean
    periodEnd?: boolean
    periodType?: boolean
    totalEarnings?: boolean
    totalOrders?: boolean
    basePay?: boolean
    bonuses?: boolean
    deductions?: boolean
    netPay?: boolean
    status?: boolean
    processedAt?: boolean
    paidAt?: boolean
    paymentMethod?: boolean
    transactionId?: boolean
    notes?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    agent?: boolean | AgentDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["payroll"]>

  export type PayrollSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    agentId?: boolean
    periodStart?: boolean
    periodEnd?: boolean
    periodType?: boolean
    totalEarnings?: boolean
    totalOrders?: boolean
    basePay?: boolean
    bonuses?: boolean
    deductions?: boolean
    netPay?: boolean
    status?: boolean
    processedAt?: boolean
    paidAt?: boolean
    paymentMethod?: boolean
    transactionId?: boolean
    notes?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    agent?: boolean | AgentDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["payroll"]>

  export type PayrollSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    agentId?: boolean
    periodStart?: boolean
    periodEnd?: boolean
    periodType?: boolean
    totalEarnings?: boolean
    totalOrders?: boolean
    basePay?: boolean
    bonuses?: boolean
    deductions?: boolean
    netPay?: boolean
    status?: boolean
    processedAt?: boolean
    paidAt?: boolean
    paymentMethod?: boolean
    transactionId?: boolean
    notes?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    agent?: boolean | AgentDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["payroll"]>

  export type PayrollSelectScalar = {
    id?: boolean
    agentId?: boolean
    periodStart?: boolean
    periodEnd?: boolean
    periodType?: boolean
    totalEarnings?: boolean
    totalOrders?: boolean
    basePay?: boolean
    bonuses?: boolean
    deductions?: boolean
    netPay?: boolean
    status?: boolean
    processedAt?: boolean
    paidAt?: boolean
    paymentMethod?: boolean
    transactionId?: boolean
    notes?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type PayrollOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "agentId" | "periodStart" | "periodEnd" | "periodType" | "totalEarnings" | "totalOrders" | "basePay" | "bonuses" | "deductions" | "netPay" | "status" | "processedAt" | "paidAt" | "paymentMethod" | "transactionId" | "notes" | "createdAt" | "updatedAt", ExtArgs["result"]["payroll"]>
  export type PayrollInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    agent?: boolean | AgentDefaultArgs<ExtArgs>
  }
  export type PayrollIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    agent?: boolean | AgentDefaultArgs<ExtArgs>
  }
  export type PayrollIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    agent?: boolean | AgentDefaultArgs<ExtArgs>
  }

  export type $PayrollPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Payroll"
    objects: {
      agent: Prisma.$AgentPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      agentId: string
      periodStart: Date
      periodEnd: Date
      periodType: string
      totalEarnings: number
      totalOrders: number
      basePay: number
      bonuses: number
      deductions: number
      netPay: number
      status: string
      processedAt: Date | null
      paidAt: Date | null
      paymentMethod: string | null
      transactionId: string | null
      notes: string | null
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["payroll"]>
    composites: {}
  }

  type PayrollGetPayload<S extends boolean | null | undefined | PayrollDefaultArgs> = $Result.GetResult<Prisma.$PayrollPayload, S>

  type PayrollCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<PayrollFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: PayrollCountAggregateInputType | true
    }

  export interface PayrollDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Payroll'], meta: { name: 'Payroll' } }
    /**
     * Find zero or one Payroll that matches the filter.
     * @param {PayrollFindUniqueArgs} args - Arguments to find a Payroll
     * @example
     * // Get one Payroll
     * const payroll = await prisma.payroll.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends PayrollFindUniqueArgs>(args: SelectSubset<T, PayrollFindUniqueArgs<ExtArgs>>): Prisma__PayrollClient<$Result.GetResult<Prisma.$PayrollPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Payroll that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {PayrollFindUniqueOrThrowArgs} args - Arguments to find a Payroll
     * @example
     * // Get one Payroll
     * const payroll = await prisma.payroll.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends PayrollFindUniqueOrThrowArgs>(args: SelectSubset<T, PayrollFindUniqueOrThrowArgs<ExtArgs>>): Prisma__PayrollClient<$Result.GetResult<Prisma.$PayrollPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Payroll that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PayrollFindFirstArgs} args - Arguments to find a Payroll
     * @example
     * // Get one Payroll
     * const payroll = await prisma.payroll.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends PayrollFindFirstArgs>(args?: SelectSubset<T, PayrollFindFirstArgs<ExtArgs>>): Prisma__PayrollClient<$Result.GetResult<Prisma.$PayrollPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Payroll that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PayrollFindFirstOrThrowArgs} args - Arguments to find a Payroll
     * @example
     * // Get one Payroll
     * const payroll = await prisma.payroll.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends PayrollFindFirstOrThrowArgs>(args?: SelectSubset<T, PayrollFindFirstOrThrowArgs<ExtArgs>>): Prisma__PayrollClient<$Result.GetResult<Prisma.$PayrollPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Payrolls that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PayrollFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Payrolls
     * const payrolls = await prisma.payroll.findMany()
     * 
     * // Get first 10 Payrolls
     * const payrolls = await prisma.payroll.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const payrollWithIdOnly = await prisma.payroll.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends PayrollFindManyArgs>(args?: SelectSubset<T, PayrollFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PayrollPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Payroll.
     * @param {PayrollCreateArgs} args - Arguments to create a Payroll.
     * @example
     * // Create one Payroll
     * const Payroll = await prisma.payroll.create({
     *   data: {
     *     // ... data to create a Payroll
     *   }
     * })
     * 
     */
    create<T extends PayrollCreateArgs>(args: SelectSubset<T, PayrollCreateArgs<ExtArgs>>): Prisma__PayrollClient<$Result.GetResult<Prisma.$PayrollPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Payrolls.
     * @param {PayrollCreateManyArgs} args - Arguments to create many Payrolls.
     * @example
     * // Create many Payrolls
     * const payroll = await prisma.payroll.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends PayrollCreateManyArgs>(args?: SelectSubset<T, PayrollCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Payrolls and returns the data saved in the database.
     * @param {PayrollCreateManyAndReturnArgs} args - Arguments to create many Payrolls.
     * @example
     * // Create many Payrolls
     * const payroll = await prisma.payroll.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Payrolls and only return the `id`
     * const payrollWithIdOnly = await prisma.payroll.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends PayrollCreateManyAndReturnArgs>(args?: SelectSubset<T, PayrollCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PayrollPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Payroll.
     * @param {PayrollDeleteArgs} args - Arguments to delete one Payroll.
     * @example
     * // Delete one Payroll
     * const Payroll = await prisma.payroll.delete({
     *   where: {
     *     // ... filter to delete one Payroll
     *   }
     * })
     * 
     */
    delete<T extends PayrollDeleteArgs>(args: SelectSubset<T, PayrollDeleteArgs<ExtArgs>>): Prisma__PayrollClient<$Result.GetResult<Prisma.$PayrollPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Payroll.
     * @param {PayrollUpdateArgs} args - Arguments to update one Payroll.
     * @example
     * // Update one Payroll
     * const payroll = await prisma.payroll.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends PayrollUpdateArgs>(args: SelectSubset<T, PayrollUpdateArgs<ExtArgs>>): Prisma__PayrollClient<$Result.GetResult<Prisma.$PayrollPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Payrolls.
     * @param {PayrollDeleteManyArgs} args - Arguments to filter Payrolls to delete.
     * @example
     * // Delete a few Payrolls
     * const { count } = await prisma.payroll.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends PayrollDeleteManyArgs>(args?: SelectSubset<T, PayrollDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Payrolls.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PayrollUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Payrolls
     * const payroll = await prisma.payroll.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends PayrollUpdateManyArgs>(args: SelectSubset<T, PayrollUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Payrolls and returns the data updated in the database.
     * @param {PayrollUpdateManyAndReturnArgs} args - Arguments to update many Payrolls.
     * @example
     * // Update many Payrolls
     * const payroll = await prisma.payroll.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Payrolls and only return the `id`
     * const payrollWithIdOnly = await prisma.payroll.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends PayrollUpdateManyAndReturnArgs>(args: SelectSubset<T, PayrollUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PayrollPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Payroll.
     * @param {PayrollUpsertArgs} args - Arguments to update or create a Payroll.
     * @example
     * // Update or create a Payroll
     * const payroll = await prisma.payroll.upsert({
     *   create: {
     *     // ... data to create a Payroll
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Payroll we want to update
     *   }
     * })
     */
    upsert<T extends PayrollUpsertArgs>(args: SelectSubset<T, PayrollUpsertArgs<ExtArgs>>): Prisma__PayrollClient<$Result.GetResult<Prisma.$PayrollPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Payrolls.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PayrollCountArgs} args - Arguments to filter Payrolls to count.
     * @example
     * // Count the number of Payrolls
     * const count = await prisma.payroll.count({
     *   where: {
     *     // ... the filter for the Payrolls we want to count
     *   }
     * })
    **/
    count<T extends PayrollCountArgs>(
      args?: Subset<T, PayrollCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], PayrollCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Payroll.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PayrollAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends PayrollAggregateArgs>(args: Subset<T, PayrollAggregateArgs>): Prisma.PrismaPromise<GetPayrollAggregateType<T>>

    /**
     * Group by Payroll.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PayrollGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends PayrollGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: PayrollGroupByArgs['orderBy'] }
        : { orderBy?: PayrollGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, PayrollGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetPayrollGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Payroll model
   */
  readonly fields: PayrollFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Payroll.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__PayrollClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    agent<T extends AgentDefaultArgs<ExtArgs> = {}>(args?: Subset<T, AgentDefaultArgs<ExtArgs>>): Prisma__AgentClient<$Result.GetResult<Prisma.$AgentPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Payroll model
   */
  interface PayrollFieldRefs {
    readonly id: FieldRef<"Payroll", 'String'>
    readonly agentId: FieldRef<"Payroll", 'String'>
    readonly periodStart: FieldRef<"Payroll", 'DateTime'>
    readonly periodEnd: FieldRef<"Payroll", 'DateTime'>
    readonly periodType: FieldRef<"Payroll", 'String'>
    readonly totalEarnings: FieldRef<"Payroll", 'Float'>
    readonly totalOrders: FieldRef<"Payroll", 'Int'>
    readonly basePay: FieldRef<"Payroll", 'Float'>
    readonly bonuses: FieldRef<"Payroll", 'Float'>
    readonly deductions: FieldRef<"Payroll", 'Float'>
    readonly netPay: FieldRef<"Payroll", 'Float'>
    readonly status: FieldRef<"Payroll", 'String'>
    readonly processedAt: FieldRef<"Payroll", 'DateTime'>
    readonly paidAt: FieldRef<"Payroll", 'DateTime'>
    readonly paymentMethod: FieldRef<"Payroll", 'String'>
    readonly transactionId: FieldRef<"Payroll", 'String'>
    readonly notes: FieldRef<"Payroll", 'String'>
    readonly createdAt: FieldRef<"Payroll", 'DateTime'>
    readonly updatedAt: FieldRef<"Payroll", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Payroll findUnique
   */
  export type PayrollFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Payroll
     */
    select?: PayrollSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Payroll
     */
    omit?: PayrollOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PayrollInclude<ExtArgs> | null
    /**
     * Filter, which Payroll to fetch.
     */
    where: PayrollWhereUniqueInput
  }

  /**
   * Payroll findUniqueOrThrow
   */
  export type PayrollFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Payroll
     */
    select?: PayrollSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Payroll
     */
    omit?: PayrollOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PayrollInclude<ExtArgs> | null
    /**
     * Filter, which Payroll to fetch.
     */
    where: PayrollWhereUniqueInput
  }

  /**
   * Payroll findFirst
   */
  export type PayrollFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Payroll
     */
    select?: PayrollSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Payroll
     */
    omit?: PayrollOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PayrollInclude<ExtArgs> | null
    /**
     * Filter, which Payroll to fetch.
     */
    where?: PayrollWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Payrolls to fetch.
     */
    orderBy?: PayrollOrderByWithRelationInput | PayrollOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Payrolls.
     */
    cursor?: PayrollWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Payrolls from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Payrolls.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Payrolls.
     */
    distinct?: PayrollScalarFieldEnum | PayrollScalarFieldEnum[]
  }

  /**
   * Payroll findFirstOrThrow
   */
  export type PayrollFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Payroll
     */
    select?: PayrollSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Payroll
     */
    omit?: PayrollOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PayrollInclude<ExtArgs> | null
    /**
     * Filter, which Payroll to fetch.
     */
    where?: PayrollWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Payrolls to fetch.
     */
    orderBy?: PayrollOrderByWithRelationInput | PayrollOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Payrolls.
     */
    cursor?: PayrollWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Payrolls from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Payrolls.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Payrolls.
     */
    distinct?: PayrollScalarFieldEnum | PayrollScalarFieldEnum[]
  }

  /**
   * Payroll findMany
   */
  export type PayrollFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Payroll
     */
    select?: PayrollSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Payroll
     */
    omit?: PayrollOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PayrollInclude<ExtArgs> | null
    /**
     * Filter, which Payrolls to fetch.
     */
    where?: PayrollWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Payrolls to fetch.
     */
    orderBy?: PayrollOrderByWithRelationInput | PayrollOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Payrolls.
     */
    cursor?: PayrollWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Payrolls from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Payrolls.
     */
    skip?: number
    distinct?: PayrollScalarFieldEnum | PayrollScalarFieldEnum[]
  }

  /**
   * Payroll create
   */
  export type PayrollCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Payroll
     */
    select?: PayrollSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Payroll
     */
    omit?: PayrollOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PayrollInclude<ExtArgs> | null
    /**
     * The data needed to create a Payroll.
     */
    data: XOR<PayrollCreateInput, PayrollUncheckedCreateInput>
  }

  /**
   * Payroll createMany
   */
  export type PayrollCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Payrolls.
     */
    data: PayrollCreateManyInput | PayrollCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Payroll createManyAndReturn
   */
  export type PayrollCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Payroll
     */
    select?: PayrollSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Payroll
     */
    omit?: PayrollOmit<ExtArgs> | null
    /**
     * The data used to create many Payrolls.
     */
    data: PayrollCreateManyInput | PayrollCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PayrollIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Payroll update
   */
  export type PayrollUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Payroll
     */
    select?: PayrollSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Payroll
     */
    omit?: PayrollOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PayrollInclude<ExtArgs> | null
    /**
     * The data needed to update a Payroll.
     */
    data: XOR<PayrollUpdateInput, PayrollUncheckedUpdateInput>
    /**
     * Choose, which Payroll to update.
     */
    where: PayrollWhereUniqueInput
  }

  /**
   * Payroll updateMany
   */
  export type PayrollUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Payrolls.
     */
    data: XOR<PayrollUpdateManyMutationInput, PayrollUncheckedUpdateManyInput>
    /**
     * Filter which Payrolls to update
     */
    where?: PayrollWhereInput
    /**
     * Limit how many Payrolls to update.
     */
    limit?: number
  }

  /**
   * Payroll updateManyAndReturn
   */
  export type PayrollUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Payroll
     */
    select?: PayrollSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Payroll
     */
    omit?: PayrollOmit<ExtArgs> | null
    /**
     * The data used to update Payrolls.
     */
    data: XOR<PayrollUpdateManyMutationInput, PayrollUncheckedUpdateManyInput>
    /**
     * Filter which Payrolls to update
     */
    where?: PayrollWhereInput
    /**
     * Limit how many Payrolls to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PayrollIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * Payroll upsert
   */
  export type PayrollUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Payroll
     */
    select?: PayrollSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Payroll
     */
    omit?: PayrollOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PayrollInclude<ExtArgs> | null
    /**
     * The filter to search for the Payroll to update in case it exists.
     */
    where: PayrollWhereUniqueInput
    /**
     * In case the Payroll found by the `where` argument doesn't exist, create a new Payroll with this data.
     */
    create: XOR<PayrollCreateInput, PayrollUncheckedCreateInput>
    /**
     * In case the Payroll was found with the provided `where` argument, update it with this data.
     */
    update: XOR<PayrollUpdateInput, PayrollUncheckedUpdateInput>
  }

  /**
   * Payroll delete
   */
  export type PayrollDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Payroll
     */
    select?: PayrollSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Payroll
     */
    omit?: PayrollOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PayrollInclude<ExtArgs> | null
    /**
     * Filter which Payroll to delete.
     */
    where: PayrollWhereUniqueInput
  }

  /**
   * Payroll deleteMany
   */
  export type PayrollDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Payrolls to delete
     */
    where?: PayrollWhereInput
    /**
     * Limit how many Payrolls to delete.
     */
    limit?: number
  }

  /**
   * Payroll without action
   */
  export type PayrollDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Payroll
     */
    select?: PayrollSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Payroll
     */
    omit?: PayrollOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PayrollInclude<ExtArgs> | null
  }


  /**
   * Model AgentSchedule
   */

  export type AggregateAgentSchedule = {
    _count: AgentScheduleCountAggregateOutputType | null
    _min: AgentScheduleMinAggregateOutputType | null
    _max: AgentScheduleMaxAggregateOutputType | null
  }

  export type AgentScheduleMinAggregateOutputType = {
    id: string | null
    agentId: string | null
    date: Date | null
    startTime: string | null
    endTime: string | null
    isAvailable: boolean | null
    notes: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type AgentScheduleMaxAggregateOutputType = {
    id: string | null
    agentId: string | null
    date: Date | null
    startTime: string | null
    endTime: string | null
    isAvailable: boolean | null
    notes: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type AgentScheduleCountAggregateOutputType = {
    id: number
    agentId: number
    date: number
    startTime: number
    endTime: number
    isAvailable: number
    notes: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type AgentScheduleMinAggregateInputType = {
    id?: true
    agentId?: true
    date?: true
    startTime?: true
    endTime?: true
    isAvailable?: true
    notes?: true
    createdAt?: true
    updatedAt?: true
  }

  export type AgentScheduleMaxAggregateInputType = {
    id?: true
    agentId?: true
    date?: true
    startTime?: true
    endTime?: true
    isAvailable?: true
    notes?: true
    createdAt?: true
    updatedAt?: true
  }

  export type AgentScheduleCountAggregateInputType = {
    id?: true
    agentId?: true
    date?: true
    startTime?: true
    endTime?: true
    isAvailable?: true
    notes?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type AgentScheduleAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which AgentSchedule to aggregate.
     */
    where?: AgentScheduleWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of AgentSchedules to fetch.
     */
    orderBy?: AgentScheduleOrderByWithRelationInput | AgentScheduleOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: AgentScheduleWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` AgentSchedules from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` AgentSchedules.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned AgentSchedules
    **/
    _count?: true | AgentScheduleCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: AgentScheduleMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: AgentScheduleMaxAggregateInputType
  }

  export type GetAgentScheduleAggregateType<T extends AgentScheduleAggregateArgs> = {
        [P in keyof T & keyof AggregateAgentSchedule]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateAgentSchedule[P]>
      : GetScalarType<T[P], AggregateAgentSchedule[P]>
  }




  export type AgentScheduleGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: AgentScheduleWhereInput
    orderBy?: AgentScheduleOrderByWithAggregationInput | AgentScheduleOrderByWithAggregationInput[]
    by: AgentScheduleScalarFieldEnum[] | AgentScheduleScalarFieldEnum
    having?: AgentScheduleScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: AgentScheduleCountAggregateInputType | true
    _min?: AgentScheduleMinAggregateInputType
    _max?: AgentScheduleMaxAggregateInputType
  }

  export type AgentScheduleGroupByOutputType = {
    id: string
    agentId: string
    date: Date
    startTime: string | null
    endTime: string | null
    isAvailable: boolean
    notes: string | null
    createdAt: Date
    updatedAt: Date
    _count: AgentScheduleCountAggregateOutputType | null
    _min: AgentScheduleMinAggregateOutputType | null
    _max: AgentScheduleMaxAggregateOutputType | null
  }

  type GetAgentScheduleGroupByPayload<T extends AgentScheduleGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<AgentScheduleGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof AgentScheduleGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], AgentScheduleGroupByOutputType[P]>
            : GetScalarType<T[P], AgentScheduleGroupByOutputType[P]>
        }
      >
    >


  export type AgentScheduleSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    agentId?: boolean
    date?: boolean
    startTime?: boolean
    endTime?: boolean
    isAvailable?: boolean
    notes?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    agent?: boolean | AgentDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["agentSchedule"]>

  export type AgentScheduleSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    agentId?: boolean
    date?: boolean
    startTime?: boolean
    endTime?: boolean
    isAvailable?: boolean
    notes?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    agent?: boolean | AgentDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["agentSchedule"]>

  export type AgentScheduleSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    agentId?: boolean
    date?: boolean
    startTime?: boolean
    endTime?: boolean
    isAvailable?: boolean
    notes?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    agent?: boolean | AgentDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["agentSchedule"]>

  export type AgentScheduleSelectScalar = {
    id?: boolean
    agentId?: boolean
    date?: boolean
    startTime?: boolean
    endTime?: boolean
    isAvailable?: boolean
    notes?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type AgentScheduleOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "agentId" | "date" | "startTime" | "endTime" | "isAvailable" | "notes" | "createdAt" | "updatedAt", ExtArgs["result"]["agentSchedule"]>
  export type AgentScheduleInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    agent?: boolean | AgentDefaultArgs<ExtArgs>
  }
  export type AgentScheduleIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    agent?: boolean | AgentDefaultArgs<ExtArgs>
  }
  export type AgentScheduleIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    agent?: boolean | AgentDefaultArgs<ExtArgs>
  }

  export type $AgentSchedulePayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "AgentSchedule"
    objects: {
      agent: Prisma.$AgentPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      agentId: string
      date: Date
      startTime: string | null
      endTime: string | null
      isAvailable: boolean
      notes: string | null
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["agentSchedule"]>
    composites: {}
  }

  type AgentScheduleGetPayload<S extends boolean | null | undefined | AgentScheduleDefaultArgs> = $Result.GetResult<Prisma.$AgentSchedulePayload, S>

  type AgentScheduleCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<AgentScheduleFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: AgentScheduleCountAggregateInputType | true
    }

  export interface AgentScheduleDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['AgentSchedule'], meta: { name: 'AgentSchedule' } }
    /**
     * Find zero or one AgentSchedule that matches the filter.
     * @param {AgentScheduleFindUniqueArgs} args - Arguments to find a AgentSchedule
     * @example
     * // Get one AgentSchedule
     * const agentSchedule = await prisma.agentSchedule.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends AgentScheduleFindUniqueArgs>(args: SelectSubset<T, AgentScheduleFindUniqueArgs<ExtArgs>>): Prisma__AgentScheduleClient<$Result.GetResult<Prisma.$AgentSchedulePayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one AgentSchedule that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {AgentScheduleFindUniqueOrThrowArgs} args - Arguments to find a AgentSchedule
     * @example
     * // Get one AgentSchedule
     * const agentSchedule = await prisma.agentSchedule.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends AgentScheduleFindUniqueOrThrowArgs>(args: SelectSubset<T, AgentScheduleFindUniqueOrThrowArgs<ExtArgs>>): Prisma__AgentScheduleClient<$Result.GetResult<Prisma.$AgentSchedulePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first AgentSchedule that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AgentScheduleFindFirstArgs} args - Arguments to find a AgentSchedule
     * @example
     * // Get one AgentSchedule
     * const agentSchedule = await prisma.agentSchedule.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends AgentScheduleFindFirstArgs>(args?: SelectSubset<T, AgentScheduleFindFirstArgs<ExtArgs>>): Prisma__AgentScheduleClient<$Result.GetResult<Prisma.$AgentSchedulePayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first AgentSchedule that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AgentScheduleFindFirstOrThrowArgs} args - Arguments to find a AgentSchedule
     * @example
     * // Get one AgentSchedule
     * const agentSchedule = await prisma.agentSchedule.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends AgentScheduleFindFirstOrThrowArgs>(args?: SelectSubset<T, AgentScheduleFindFirstOrThrowArgs<ExtArgs>>): Prisma__AgentScheduleClient<$Result.GetResult<Prisma.$AgentSchedulePayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more AgentSchedules that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AgentScheduleFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all AgentSchedules
     * const agentSchedules = await prisma.agentSchedule.findMany()
     * 
     * // Get first 10 AgentSchedules
     * const agentSchedules = await prisma.agentSchedule.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const agentScheduleWithIdOnly = await prisma.agentSchedule.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends AgentScheduleFindManyArgs>(args?: SelectSubset<T, AgentScheduleFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AgentSchedulePayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a AgentSchedule.
     * @param {AgentScheduleCreateArgs} args - Arguments to create a AgentSchedule.
     * @example
     * // Create one AgentSchedule
     * const AgentSchedule = await prisma.agentSchedule.create({
     *   data: {
     *     // ... data to create a AgentSchedule
     *   }
     * })
     * 
     */
    create<T extends AgentScheduleCreateArgs>(args: SelectSubset<T, AgentScheduleCreateArgs<ExtArgs>>): Prisma__AgentScheduleClient<$Result.GetResult<Prisma.$AgentSchedulePayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many AgentSchedules.
     * @param {AgentScheduleCreateManyArgs} args - Arguments to create many AgentSchedules.
     * @example
     * // Create many AgentSchedules
     * const agentSchedule = await prisma.agentSchedule.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends AgentScheduleCreateManyArgs>(args?: SelectSubset<T, AgentScheduleCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many AgentSchedules and returns the data saved in the database.
     * @param {AgentScheduleCreateManyAndReturnArgs} args - Arguments to create many AgentSchedules.
     * @example
     * // Create many AgentSchedules
     * const agentSchedule = await prisma.agentSchedule.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many AgentSchedules and only return the `id`
     * const agentScheduleWithIdOnly = await prisma.agentSchedule.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends AgentScheduleCreateManyAndReturnArgs>(args?: SelectSubset<T, AgentScheduleCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AgentSchedulePayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a AgentSchedule.
     * @param {AgentScheduleDeleteArgs} args - Arguments to delete one AgentSchedule.
     * @example
     * // Delete one AgentSchedule
     * const AgentSchedule = await prisma.agentSchedule.delete({
     *   where: {
     *     // ... filter to delete one AgentSchedule
     *   }
     * })
     * 
     */
    delete<T extends AgentScheduleDeleteArgs>(args: SelectSubset<T, AgentScheduleDeleteArgs<ExtArgs>>): Prisma__AgentScheduleClient<$Result.GetResult<Prisma.$AgentSchedulePayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one AgentSchedule.
     * @param {AgentScheduleUpdateArgs} args - Arguments to update one AgentSchedule.
     * @example
     * // Update one AgentSchedule
     * const agentSchedule = await prisma.agentSchedule.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends AgentScheduleUpdateArgs>(args: SelectSubset<T, AgentScheduleUpdateArgs<ExtArgs>>): Prisma__AgentScheduleClient<$Result.GetResult<Prisma.$AgentSchedulePayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more AgentSchedules.
     * @param {AgentScheduleDeleteManyArgs} args - Arguments to filter AgentSchedules to delete.
     * @example
     * // Delete a few AgentSchedules
     * const { count } = await prisma.agentSchedule.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends AgentScheduleDeleteManyArgs>(args?: SelectSubset<T, AgentScheduleDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more AgentSchedules.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AgentScheduleUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many AgentSchedules
     * const agentSchedule = await prisma.agentSchedule.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends AgentScheduleUpdateManyArgs>(args: SelectSubset<T, AgentScheduleUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more AgentSchedules and returns the data updated in the database.
     * @param {AgentScheduleUpdateManyAndReturnArgs} args - Arguments to update many AgentSchedules.
     * @example
     * // Update many AgentSchedules
     * const agentSchedule = await prisma.agentSchedule.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more AgentSchedules and only return the `id`
     * const agentScheduleWithIdOnly = await prisma.agentSchedule.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends AgentScheduleUpdateManyAndReturnArgs>(args: SelectSubset<T, AgentScheduleUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AgentSchedulePayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one AgentSchedule.
     * @param {AgentScheduleUpsertArgs} args - Arguments to update or create a AgentSchedule.
     * @example
     * // Update or create a AgentSchedule
     * const agentSchedule = await prisma.agentSchedule.upsert({
     *   create: {
     *     // ... data to create a AgentSchedule
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the AgentSchedule we want to update
     *   }
     * })
     */
    upsert<T extends AgentScheduleUpsertArgs>(args: SelectSubset<T, AgentScheduleUpsertArgs<ExtArgs>>): Prisma__AgentScheduleClient<$Result.GetResult<Prisma.$AgentSchedulePayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of AgentSchedules.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AgentScheduleCountArgs} args - Arguments to filter AgentSchedules to count.
     * @example
     * // Count the number of AgentSchedules
     * const count = await prisma.agentSchedule.count({
     *   where: {
     *     // ... the filter for the AgentSchedules we want to count
     *   }
     * })
    **/
    count<T extends AgentScheduleCountArgs>(
      args?: Subset<T, AgentScheduleCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], AgentScheduleCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a AgentSchedule.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AgentScheduleAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends AgentScheduleAggregateArgs>(args: Subset<T, AgentScheduleAggregateArgs>): Prisma.PrismaPromise<GetAgentScheduleAggregateType<T>>

    /**
     * Group by AgentSchedule.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AgentScheduleGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends AgentScheduleGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: AgentScheduleGroupByArgs['orderBy'] }
        : { orderBy?: AgentScheduleGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, AgentScheduleGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetAgentScheduleGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the AgentSchedule model
   */
  readonly fields: AgentScheduleFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for AgentSchedule.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__AgentScheduleClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    agent<T extends AgentDefaultArgs<ExtArgs> = {}>(args?: Subset<T, AgentDefaultArgs<ExtArgs>>): Prisma__AgentClient<$Result.GetResult<Prisma.$AgentPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the AgentSchedule model
   */
  interface AgentScheduleFieldRefs {
    readonly id: FieldRef<"AgentSchedule", 'String'>
    readonly agentId: FieldRef<"AgentSchedule", 'String'>
    readonly date: FieldRef<"AgentSchedule", 'DateTime'>
    readonly startTime: FieldRef<"AgentSchedule", 'String'>
    readonly endTime: FieldRef<"AgentSchedule", 'String'>
    readonly isAvailable: FieldRef<"AgentSchedule", 'Boolean'>
    readonly notes: FieldRef<"AgentSchedule", 'String'>
    readonly createdAt: FieldRef<"AgentSchedule", 'DateTime'>
    readonly updatedAt: FieldRef<"AgentSchedule", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * AgentSchedule findUnique
   */
  export type AgentScheduleFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AgentSchedule
     */
    select?: AgentScheduleSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AgentSchedule
     */
    omit?: AgentScheduleOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AgentScheduleInclude<ExtArgs> | null
    /**
     * Filter, which AgentSchedule to fetch.
     */
    where: AgentScheduleWhereUniqueInput
  }

  /**
   * AgentSchedule findUniqueOrThrow
   */
  export type AgentScheduleFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AgentSchedule
     */
    select?: AgentScheduleSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AgentSchedule
     */
    omit?: AgentScheduleOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AgentScheduleInclude<ExtArgs> | null
    /**
     * Filter, which AgentSchedule to fetch.
     */
    where: AgentScheduleWhereUniqueInput
  }

  /**
   * AgentSchedule findFirst
   */
  export type AgentScheduleFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AgentSchedule
     */
    select?: AgentScheduleSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AgentSchedule
     */
    omit?: AgentScheduleOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AgentScheduleInclude<ExtArgs> | null
    /**
     * Filter, which AgentSchedule to fetch.
     */
    where?: AgentScheduleWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of AgentSchedules to fetch.
     */
    orderBy?: AgentScheduleOrderByWithRelationInput | AgentScheduleOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for AgentSchedules.
     */
    cursor?: AgentScheduleWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` AgentSchedules from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` AgentSchedules.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of AgentSchedules.
     */
    distinct?: AgentScheduleScalarFieldEnum | AgentScheduleScalarFieldEnum[]
  }

  /**
   * AgentSchedule findFirstOrThrow
   */
  export type AgentScheduleFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AgentSchedule
     */
    select?: AgentScheduleSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AgentSchedule
     */
    omit?: AgentScheduleOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AgentScheduleInclude<ExtArgs> | null
    /**
     * Filter, which AgentSchedule to fetch.
     */
    where?: AgentScheduleWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of AgentSchedules to fetch.
     */
    orderBy?: AgentScheduleOrderByWithRelationInput | AgentScheduleOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for AgentSchedules.
     */
    cursor?: AgentScheduleWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` AgentSchedules from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` AgentSchedules.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of AgentSchedules.
     */
    distinct?: AgentScheduleScalarFieldEnum | AgentScheduleScalarFieldEnum[]
  }

  /**
   * AgentSchedule findMany
   */
  export type AgentScheduleFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AgentSchedule
     */
    select?: AgentScheduleSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AgentSchedule
     */
    omit?: AgentScheduleOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AgentScheduleInclude<ExtArgs> | null
    /**
     * Filter, which AgentSchedules to fetch.
     */
    where?: AgentScheduleWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of AgentSchedules to fetch.
     */
    orderBy?: AgentScheduleOrderByWithRelationInput | AgentScheduleOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing AgentSchedules.
     */
    cursor?: AgentScheduleWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` AgentSchedules from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` AgentSchedules.
     */
    skip?: number
    distinct?: AgentScheduleScalarFieldEnum | AgentScheduleScalarFieldEnum[]
  }

  /**
   * AgentSchedule create
   */
  export type AgentScheduleCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AgentSchedule
     */
    select?: AgentScheduleSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AgentSchedule
     */
    omit?: AgentScheduleOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AgentScheduleInclude<ExtArgs> | null
    /**
     * The data needed to create a AgentSchedule.
     */
    data: XOR<AgentScheduleCreateInput, AgentScheduleUncheckedCreateInput>
  }

  /**
   * AgentSchedule createMany
   */
  export type AgentScheduleCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many AgentSchedules.
     */
    data: AgentScheduleCreateManyInput | AgentScheduleCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * AgentSchedule createManyAndReturn
   */
  export type AgentScheduleCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AgentSchedule
     */
    select?: AgentScheduleSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the AgentSchedule
     */
    omit?: AgentScheduleOmit<ExtArgs> | null
    /**
     * The data used to create many AgentSchedules.
     */
    data: AgentScheduleCreateManyInput | AgentScheduleCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AgentScheduleIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * AgentSchedule update
   */
  export type AgentScheduleUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AgentSchedule
     */
    select?: AgentScheduleSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AgentSchedule
     */
    omit?: AgentScheduleOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AgentScheduleInclude<ExtArgs> | null
    /**
     * The data needed to update a AgentSchedule.
     */
    data: XOR<AgentScheduleUpdateInput, AgentScheduleUncheckedUpdateInput>
    /**
     * Choose, which AgentSchedule to update.
     */
    where: AgentScheduleWhereUniqueInput
  }

  /**
   * AgentSchedule updateMany
   */
  export type AgentScheduleUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update AgentSchedules.
     */
    data: XOR<AgentScheduleUpdateManyMutationInput, AgentScheduleUncheckedUpdateManyInput>
    /**
     * Filter which AgentSchedules to update
     */
    where?: AgentScheduleWhereInput
    /**
     * Limit how many AgentSchedules to update.
     */
    limit?: number
  }

  /**
   * AgentSchedule updateManyAndReturn
   */
  export type AgentScheduleUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AgentSchedule
     */
    select?: AgentScheduleSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the AgentSchedule
     */
    omit?: AgentScheduleOmit<ExtArgs> | null
    /**
     * The data used to update AgentSchedules.
     */
    data: XOR<AgentScheduleUpdateManyMutationInput, AgentScheduleUncheckedUpdateManyInput>
    /**
     * Filter which AgentSchedules to update
     */
    where?: AgentScheduleWhereInput
    /**
     * Limit how many AgentSchedules to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AgentScheduleIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * AgentSchedule upsert
   */
  export type AgentScheduleUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AgentSchedule
     */
    select?: AgentScheduleSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AgentSchedule
     */
    omit?: AgentScheduleOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AgentScheduleInclude<ExtArgs> | null
    /**
     * The filter to search for the AgentSchedule to update in case it exists.
     */
    where: AgentScheduleWhereUniqueInput
    /**
     * In case the AgentSchedule found by the `where` argument doesn't exist, create a new AgentSchedule with this data.
     */
    create: XOR<AgentScheduleCreateInput, AgentScheduleUncheckedCreateInput>
    /**
     * In case the AgentSchedule was found with the provided `where` argument, update it with this data.
     */
    update: XOR<AgentScheduleUpdateInput, AgentScheduleUncheckedUpdateInput>
  }

  /**
   * AgentSchedule delete
   */
  export type AgentScheduleDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AgentSchedule
     */
    select?: AgentScheduleSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AgentSchedule
     */
    omit?: AgentScheduleOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AgentScheduleInclude<ExtArgs> | null
    /**
     * Filter which AgentSchedule to delete.
     */
    where: AgentScheduleWhereUniqueInput
  }

  /**
   * AgentSchedule deleteMany
   */
  export type AgentScheduleDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which AgentSchedules to delete
     */
    where?: AgentScheduleWhereInput
    /**
     * Limit how many AgentSchedules to delete.
     */
    limit?: number
  }

  /**
   * AgentSchedule without action
   */
  export type AgentScheduleDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AgentSchedule
     */
    select?: AgentScheduleSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AgentSchedule
     */
    omit?: AgentScheduleOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AgentScheduleInclude<ExtArgs> | null
  }


  /**
   * Model PayStructure
   */

  export type AggregatePayStructure = {
    _count: PayStructureCountAggregateOutputType | null
    _avg: PayStructureAvgAggregateOutputType | null
    _sum: PayStructureSumAggregateOutputType | null
    _min: PayStructureMinAggregateOutputType | null
    _max: PayStructureMaxAggregateOutputType | null
  }

  export type PayStructureAvgAggregateOutputType = {
    baseRate: number | null
    commissionRate: number | null
    minGuarantee: number | null
    maxLimit: number | null
  }

  export type PayStructureSumAggregateOutputType = {
    baseRate: number | null
    commissionRate: number | null
    minGuarantee: number | null
    maxLimit: number | null
  }

  export type PayStructureMinAggregateOutputType = {
    id: string | null
    name: string | null
    payType: string | null
    baseRate: number | null
    commissionRate: number | null
    minGuarantee: number | null
    maxLimit: number | null
    isActive: boolean | null
    effectiveFrom: Date | null
    effectiveTo: Date | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type PayStructureMaxAggregateOutputType = {
    id: string | null
    name: string | null
    payType: string | null
    baseRate: number | null
    commissionRate: number | null
    minGuarantee: number | null
    maxLimit: number | null
    isActive: boolean | null
    effectiveFrom: Date | null
    effectiveTo: Date | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type PayStructureCountAggregateOutputType = {
    id: number
    name: number
    payType: number
    baseRate: number
    commissionRate: number
    minGuarantee: number
    maxLimit: number
    bonusRules: number
    deductionRules: number
    isActive: number
    effectiveFrom: number
    effectiveTo: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type PayStructureAvgAggregateInputType = {
    baseRate?: true
    commissionRate?: true
    minGuarantee?: true
    maxLimit?: true
  }

  export type PayStructureSumAggregateInputType = {
    baseRate?: true
    commissionRate?: true
    minGuarantee?: true
    maxLimit?: true
  }

  export type PayStructureMinAggregateInputType = {
    id?: true
    name?: true
    payType?: true
    baseRate?: true
    commissionRate?: true
    minGuarantee?: true
    maxLimit?: true
    isActive?: true
    effectiveFrom?: true
    effectiveTo?: true
    createdAt?: true
    updatedAt?: true
  }

  export type PayStructureMaxAggregateInputType = {
    id?: true
    name?: true
    payType?: true
    baseRate?: true
    commissionRate?: true
    minGuarantee?: true
    maxLimit?: true
    isActive?: true
    effectiveFrom?: true
    effectiveTo?: true
    createdAt?: true
    updatedAt?: true
  }

  export type PayStructureCountAggregateInputType = {
    id?: true
    name?: true
    payType?: true
    baseRate?: true
    commissionRate?: true
    minGuarantee?: true
    maxLimit?: true
    bonusRules?: true
    deductionRules?: true
    isActive?: true
    effectiveFrom?: true
    effectiveTo?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type PayStructureAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which PayStructure to aggregate.
     */
    where?: PayStructureWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of PayStructures to fetch.
     */
    orderBy?: PayStructureOrderByWithRelationInput | PayStructureOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: PayStructureWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` PayStructures from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` PayStructures.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned PayStructures
    **/
    _count?: true | PayStructureCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: PayStructureAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: PayStructureSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: PayStructureMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: PayStructureMaxAggregateInputType
  }

  export type GetPayStructureAggregateType<T extends PayStructureAggregateArgs> = {
        [P in keyof T & keyof AggregatePayStructure]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregatePayStructure[P]>
      : GetScalarType<T[P], AggregatePayStructure[P]>
  }




  export type PayStructureGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: PayStructureWhereInput
    orderBy?: PayStructureOrderByWithAggregationInput | PayStructureOrderByWithAggregationInput[]
    by: PayStructureScalarFieldEnum[] | PayStructureScalarFieldEnum
    having?: PayStructureScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: PayStructureCountAggregateInputType | true
    _avg?: PayStructureAvgAggregateInputType
    _sum?: PayStructureSumAggregateInputType
    _min?: PayStructureMinAggregateInputType
    _max?: PayStructureMaxAggregateInputType
  }

  export type PayStructureGroupByOutputType = {
    id: string
    name: string
    payType: string
    baseRate: number | null
    commissionRate: number | null
    minGuarantee: number | null
    maxLimit: number | null
    bonusRules: JsonValue | null
    deductionRules: JsonValue | null
    isActive: boolean
    effectiveFrom: Date
    effectiveTo: Date | null
    createdAt: Date
    updatedAt: Date
    _count: PayStructureCountAggregateOutputType | null
    _avg: PayStructureAvgAggregateOutputType | null
    _sum: PayStructureSumAggregateOutputType | null
    _min: PayStructureMinAggregateOutputType | null
    _max: PayStructureMaxAggregateOutputType | null
  }

  type GetPayStructureGroupByPayload<T extends PayStructureGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<PayStructureGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof PayStructureGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], PayStructureGroupByOutputType[P]>
            : GetScalarType<T[P], PayStructureGroupByOutputType[P]>
        }
      >
    >


  export type PayStructureSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    payType?: boolean
    baseRate?: boolean
    commissionRate?: boolean
    minGuarantee?: boolean
    maxLimit?: boolean
    bonusRules?: boolean
    deductionRules?: boolean
    isActive?: boolean
    effectiveFrom?: boolean
    effectiveTo?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }, ExtArgs["result"]["payStructure"]>

  export type PayStructureSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    payType?: boolean
    baseRate?: boolean
    commissionRate?: boolean
    minGuarantee?: boolean
    maxLimit?: boolean
    bonusRules?: boolean
    deductionRules?: boolean
    isActive?: boolean
    effectiveFrom?: boolean
    effectiveTo?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }, ExtArgs["result"]["payStructure"]>

  export type PayStructureSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    payType?: boolean
    baseRate?: boolean
    commissionRate?: boolean
    minGuarantee?: boolean
    maxLimit?: boolean
    bonusRules?: boolean
    deductionRules?: boolean
    isActive?: boolean
    effectiveFrom?: boolean
    effectiveTo?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }, ExtArgs["result"]["payStructure"]>

  export type PayStructureSelectScalar = {
    id?: boolean
    name?: boolean
    payType?: boolean
    baseRate?: boolean
    commissionRate?: boolean
    minGuarantee?: boolean
    maxLimit?: boolean
    bonusRules?: boolean
    deductionRules?: boolean
    isActive?: boolean
    effectiveFrom?: boolean
    effectiveTo?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type PayStructureOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "name" | "payType" | "baseRate" | "commissionRate" | "minGuarantee" | "maxLimit" | "bonusRules" | "deductionRules" | "isActive" | "effectiveFrom" | "effectiveTo" | "createdAt" | "updatedAt", ExtArgs["result"]["payStructure"]>

  export type $PayStructurePayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "PayStructure"
    objects: {}
    scalars: $Extensions.GetPayloadResult<{
      id: string
      name: string
      payType: string
      baseRate: number | null
      commissionRate: number | null
      minGuarantee: number | null
      maxLimit: number | null
      bonusRules: Prisma.JsonValue | null
      deductionRules: Prisma.JsonValue | null
      isActive: boolean
      effectiveFrom: Date
      effectiveTo: Date | null
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["payStructure"]>
    composites: {}
  }

  type PayStructureGetPayload<S extends boolean | null | undefined | PayStructureDefaultArgs> = $Result.GetResult<Prisma.$PayStructurePayload, S>

  type PayStructureCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<PayStructureFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: PayStructureCountAggregateInputType | true
    }

  export interface PayStructureDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['PayStructure'], meta: { name: 'PayStructure' } }
    /**
     * Find zero or one PayStructure that matches the filter.
     * @param {PayStructureFindUniqueArgs} args - Arguments to find a PayStructure
     * @example
     * // Get one PayStructure
     * const payStructure = await prisma.payStructure.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends PayStructureFindUniqueArgs>(args: SelectSubset<T, PayStructureFindUniqueArgs<ExtArgs>>): Prisma__PayStructureClient<$Result.GetResult<Prisma.$PayStructurePayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one PayStructure that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {PayStructureFindUniqueOrThrowArgs} args - Arguments to find a PayStructure
     * @example
     * // Get one PayStructure
     * const payStructure = await prisma.payStructure.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends PayStructureFindUniqueOrThrowArgs>(args: SelectSubset<T, PayStructureFindUniqueOrThrowArgs<ExtArgs>>): Prisma__PayStructureClient<$Result.GetResult<Prisma.$PayStructurePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first PayStructure that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PayStructureFindFirstArgs} args - Arguments to find a PayStructure
     * @example
     * // Get one PayStructure
     * const payStructure = await prisma.payStructure.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends PayStructureFindFirstArgs>(args?: SelectSubset<T, PayStructureFindFirstArgs<ExtArgs>>): Prisma__PayStructureClient<$Result.GetResult<Prisma.$PayStructurePayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first PayStructure that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PayStructureFindFirstOrThrowArgs} args - Arguments to find a PayStructure
     * @example
     * // Get one PayStructure
     * const payStructure = await prisma.payStructure.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends PayStructureFindFirstOrThrowArgs>(args?: SelectSubset<T, PayStructureFindFirstOrThrowArgs<ExtArgs>>): Prisma__PayStructureClient<$Result.GetResult<Prisma.$PayStructurePayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more PayStructures that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PayStructureFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all PayStructures
     * const payStructures = await prisma.payStructure.findMany()
     * 
     * // Get first 10 PayStructures
     * const payStructures = await prisma.payStructure.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const payStructureWithIdOnly = await prisma.payStructure.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends PayStructureFindManyArgs>(args?: SelectSubset<T, PayStructureFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PayStructurePayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a PayStructure.
     * @param {PayStructureCreateArgs} args - Arguments to create a PayStructure.
     * @example
     * // Create one PayStructure
     * const PayStructure = await prisma.payStructure.create({
     *   data: {
     *     // ... data to create a PayStructure
     *   }
     * })
     * 
     */
    create<T extends PayStructureCreateArgs>(args: SelectSubset<T, PayStructureCreateArgs<ExtArgs>>): Prisma__PayStructureClient<$Result.GetResult<Prisma.$PayStructurePayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many PayStructures.
     * @param {PayStructureCreateManyArgs} args - Arguments to create many PayStructures.
     * @example
     * // Create many PayStructures
     * const payStructure = await prisma.payStructure.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends PayStructureCreateManyArgs>(args?: SelectSubset<T, PayStructureCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many PayStructures and returns the data saved in the database.
     * @param {PayStructureCreateManyAndReturnArgs} args - Arguments to create many PayStructures.
     * @example
     * // Create many PayStructures
     * const payStructure = await prisma.payStructure.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many PayStructures and only return the `id`
     * const payStructureWithIdOnly = await prisma.payStructure.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends PayStructureCreateManyAndReturnArgs>(args?: SelectSubset<T, PayStructureCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PayStructurePayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a PayStructure.
     * @param {PayStructureDeleteArgs} args - Arguments to delete one PayStructure.
     * @example
     * // Delete one PayStructure
     * const PayStructure = await prisma.payStructure.delete({
     *   where: {
     *     // ... filter to delete one PayStructure
     *   }
     * })
     * 
     */
    delete<T extends PayStructureDeleteArgs>(args: SelectSubset<T, PayStructureDeleteArgs<ExtArgs>>): Prisma__PayStructureClient<$Result.GetResult<Prisma.$PayStructurePayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one PayStructure.
     * @param {PayStructureUpdateArgs} args - Arguments to update one PayStructure.
     * @example
     * // Update one PayStructure
     * const payStructure = await prisma.payStructure.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends PayStructureUpdateArgs>(args: SelectSubset<T, PayStructureUpdateArgs<ExtArgs>>): Prisma__PayStructureClient<$Result.GetResult<Prisma.$PayStructurePayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more PayStructures.
     * @param {PayStructureDeleteManyArgs} args - Arguments to filter PayStructures to delete.
     * @example
     * // Delete a few PayStructures
     * const { count } = await prisma.payStructure.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends PayStructureDeleteManyArgs>(args?: SelectSubset<T, PayStructureDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more PayStructures.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PayStructureUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many PayStructures
     * const payStructure = await prisma.payStructure.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends PayStructureUpdateManyArgs>(args: SelectSubset<T, PayStructureUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more PayStructures and returns the data updated in the database.
     * @param {PayStructureUpdateManyAndReturnArgs} args - Arguments to update many PayStructures.
     * @example
     * // Update many PayStructures
     * const payStructure = await prisma.payStructure.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more PayStructures and only return the `id`
     * const payStructureWithIdOnly = await prisma.payStructure.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends PayStructureUpdateManyAndReturnArgs>(args: SelectSubset<T, PayStructureUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PayStructurePayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one PayStructure.
     * @param {PayStructureUpsertArgs} args - Arguments to update or create a PayStructure.
     * @example
     * // Update or create a PayStructure
     * const payStructure = await prisma.payStructure.upsert({
     *   create: {
     *     // ... data to create a PayStructure
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the PayStructure we want to update
     *   }
     * })
     */
    upsert<T extends PayStructureUpsertArgs>(args: SelectSubset<T, PayStructureUpsertArgs<ExtArgs>>): Prisma__PayStructureClient<$Result.GetResult<Prisma.$PayStructurePayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of PayStructures.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PayStructureCountArgs} args - Arguments to filter PayStructures to count.
     * @example
     * // Count the number of PayStructures
     * const count = await prisma.payStructure.count({
     *   where: {
     *     // ... the filter for the PayStructures we want to count
     *   }
     * })
    **/
    count<T extends PayStructureCountArgs>(
      args?: Subset<T, PayStructureCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], PayStructureCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a PayStructure.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PayStructureAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends PayStructureAggregateArgs>(args: Subset<T, PayStructureAggregateArgs>): Prisma.PrismaPromise<GetPayStructureAggregateType<T>>

    /**
     * Group by PayStructure.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PayStructureGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends PayStructureGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: PayStructureGroupByArgs['orderBy'] }
        : { orderBy?: PayStructureGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, PayStructureGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetPayStructureGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the PayStructure model
   */
  readonly fields: PayStructureFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for PayStructure.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__PayStructureClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the PayStructure model
   */
  interface PayStructureFieldRefs {
    readonly id: FieldRef<"PayStructure", 'String'>
    readonly name: FieldRef<"PayStructure", 'String'>
    readonly payType: FieldRef<"PayStructure", 'String'>
    readonly baseRate: FieldRef<"PayStructure", 'Float'>
    readonly commissionRate: FieldRef<"PayStructure", 'Float'>
    readonly minGuarantee: FieldRef<"PayStructure", 'Float'>
    readonly maxLimit: FieldRef<"PayStructure", 'Float'>
    readonly bonusRules: FieldRef<"PayStructure", 'Json'>
    readonly deductionRules: FieldRef<"PayStructure", 'Json'>
    readonly isActive: FieldRef<"PayStructure", 'Boolean'>
    readonly effectiveFrom: FieldRef<"PayStructure", 'DateTime'>
    readonly effectiveTo: FieldRef<"PayStructure", 'DateTime'>
    readonly createdAt: FieldRef<"PayStructure", 'DateTime'>
    readonly updatedAt: FieldRef<"PayStructure", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * PayStructure findUnique
   */
  export type PayStructureFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PayStructure
     */
    select?: PayStructureSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PayStructure
     */
    omit?: PayStructureOmit<ExtArgs> | null
    /**
     * Filter, which PayStructure to fetch.
     */
    where: PayStructureWhereUniqueInput
  }

  /**
   * PayStructure findUniqueOrThrow
   */
  export type PayStructureFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PayStructure
     */
    select?: PayStructureSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PayStructure
     */
    omit?: PayStructureOmit<ExtArgs> | null
    /**
     * Filter, which PayStructure to fetch.
     */
    where: PayStructureWhereUniqueInput
  }

  /**
   * PayStructure findFirst
   */
  export type PayStructureFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PayStructure
     */
    select?: PayStructureSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PayStructure
     */
    omit?: PayStructureOmit<ExtArgs> | null
    /**
     * Filter, which PayStructure to fetch.
     */
    where?: PayStructureWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of PayStructures to fetch.
     */
    orderBy?: PayStructureOrderByWithRelationInput | PayStructureOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for PayStructures.
     */
    cursor?: PayStructureWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` PayStructures from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` PayStructures.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of PayStructures.
     */
    distinct?: PayStructureScalarFieldEnum | PayStructureScalarFieldEnum[]
  }

  /**
   * PayStructure findFirstOrThrow
   */
  export type PayStructureFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PayStructure
     */
    select?: PayStructureSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PayStructure
     */
    omit?: PayStructureOmit<ExtArgs> | null
    /**
     * Filter, which PayStructure to fetch.
     */
    where?: PayStructureWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of PayStructures to fetch.
     */
    orderBy?: PayStructureOrderByWithRelationInput | PayStructureOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for PayStructures.
     */
    cursor?: PayStructureWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` PayStructures from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` PayStructures.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of PayStructures.
     */
    distinct?: PayStructureScalarFieldEnum | PayStructureScalarFieldEnum[]
  }

  /**
   * PayStructure findMany
   */
  export type PayStructureFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PayStructure
     */
    select?: PayStructureSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PayStructure
     */
    omit?: PayStructureOmit<ExtArgs> | null
    /**
     * Filter, which PayStructures to fetch.
     */
    where?: PayStructureWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of PayStructures to fetch.
     */
    orderBy?: PayStructureOrderByWithRelationInput | PayStructureOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing PayStructures.
     */
    cursor?: PayStructureWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` PayStructures from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` PayStructures.
     */
    skip?: number
    distinct?: PayStructureScalarFieldEnum | PayStructureScalarFieldEnum[]
  }

  /**
   * PayStructure create
   */
  export type PayStructureCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PayStructure
     */
    select?: PayStructureSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PayStructure
     */
    omit?: PayStructureOmit<ExtArgs> | null
    /**
     * The data needed to create a PayStructure.
     */
    data: XOR<PayStructureCreateInput, PayStructureUncheckedCreateInput>
  }

  /**
   * PayStructure createMany
   */
  export type PayStructureCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many PayStructures.
     */
    data: PayStructureCreateManyInput | PayStructureCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * PayStructure createManyAndReturn
   */
  export type PayStructureCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PayStructure
     */
    select?: PayStructureSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the PayStructure
     */
    omit?: PayStructureOmit<ExtArgs> | null
    /**
     * The data used to create many PayStructures.
     */
    data: PayStructureCreateManyInput | PayStructureCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * PayStructure update
   */
  export type PayStructureUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PayStructure
     */
    select?: PayStructureSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PayStructure
     */
    omit?: PayStructureOmit<ExtArgs> | null
    /**
     * The data needed to update a PayStructure.
     */
    data: XOR<PayStructureUpdateInput, PayStructureUncheckedUpdateInput>
    /**
     * Choose, which PayStructure to update.
     */
    where: PayStructureWhereUniqueInput
  }

  /**
   * PayStructure updateMany
   */
  export type PayStructureUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update PayStructures.
     */
    data: XOR<PayStructureUpdateManyMutationInput, PayStructureUncheckedUpdateManyInput>
    /**
     * Filter which PayStructures to update
     */
    where?: PayStructureWhereInput
    /**
     * Limit how many PayStructures to update.
     */
    limit?: number
  }

  /**
   * PayStructure updateManyAndReturn
   */
  export type PayStructureUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PayStructure
     */
    select?: PayStructureSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the PayStructure
     */
    omit?: PayStructureOmit<ExtArgs> | null
    /**
     * The data used to update PayStructures.
     */
    data: XOR<PayStructureUpdateManyMutationInput, PayStructureUncheckedUpdateManyInput>
    /**
     * Filter which PayStructures to update
     */
    where?: PayStructureWhereInput
    /**
     * Limit how many PayStructures to update.
     */
    limit?: number
  }

  /**
   * PayStructure upsert
   */
  export type PayStructureUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PayStructure
     */
    select?: PayStructureSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PayStructure
     */
    omit?: PayStructureOmit<ExtArgs> | null
    /**
     * The filter to search for the PayStructure to update in case it exists.
     */
    where: PayStructureWhereUniqueInput
    /**
     * In case the PayStructure found by the `where` argument doesn't exist, create a new PayStructure with this data.
     */
    create: XOR<PayStructureCreateInput, PayStructureUncheckedCreateInput>
    /**
     * In case the PayStructure was found with the provided `where` argument, update it with this data.
     */
    update: XOR<PayStructureUpdateInput, PayStructureUncheckedUpdateInput>
  }

  /**
   * PayStructure delete
   */
  export type PayStructureDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PayStructure
     */
    select?: PayStructureSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PayStructure
     */
    omit?: PayStructureOmit<ExtArgs> | null
    /**
     * Filter which PayStructure to delete.
     */
    where: PayStructureWhereUniqueInput
  }

  /**
   * PayStructure deleteMany
   */
  export type PayStructureDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which PayStructures to delete
     */
    where?: PayStructureWhereInput
    /**
     * Limit how many PayStructures to delete.
     */
    limit?: number
  }

  /**
   * PayStructure without action
   */
  export type PayStructureDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PayStructure
     */
    select?: PayStructureSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PayStructure
     */
    omit?: PayStructureOmit<ExtArgs> | null
  }


  /**
   * Enums
   */

  export const TransactionIsolationLevel: {
    ReadUncommitted: 'ReadUncommitted',
    ReadCommitted: 'ReadCommitted',
    RepeatableRead: 'RepeatableRead',
    Serializable: 'Serializable'
  };

  export type TransactionIsolationLevel = (typeof TransactionIsolationLevel)[keyof typeof TransactionIsolationLevel]


  export const UserScalarFieldEnum: {
    id: 'id',
    name: 'name',
    email: 'email',
    phone: 'phone',
    passwordHash: 'passwordHash',
    role: 'role',
    emailVerified: 'emailVerified',
    phoneVerified: 'phoneVerified',
    profilePicture: 'profilePicture',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type UserScalarFieldEnum = (typeof UserScalarFieldEnum)[keyof typeof UserScalarFieldEnum]


  export const AgentScalarFieldEnum: {
    id: 'id',
    userId: 'userId',
    vehicleType: 'vehicleType',
    status: 'status',
    rating: 'rating',
    totalOrders: 'totalOrders',
    completedOrders: 'completedOrders',
    cancelledOrders: 'cancelledOrders',
    acceptanceRate: 'acceptanceRate',
    currentOrderId: 'currentOrderId',
    isApproved: 'isApproved',
    isBlocked: 'isBlocked',
    blockedReason: 'blockedReason',
    city: 'city',
    state: 'state',
    pincode: 'pincode',
    lastOnlineAt: 'lastOnlineAt',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type AgentScalarFieldEnum = (typeof AgentScalarFieldEnum)[keyof typeof AgentScalarFieldEnum]


  export const AgentDocumentScalarFieldEnum: {
    id: 'id',
    agentId: 'agentId',
    documentType: 'documentType',
    fileName: 'fileName',
    fileUrl: 'fileUrl',
    verified: 'verified',
    uploadedAt: 'uploadedAt'
  };

  export type AgentDocumentScalarFieldEnum = (typeof AgentDocumentScalarFieldEnum)[keyof typeof AgentDocumentScalarFieldEnum]


  export const AgentLocationScalarFieldEnum: {
    id: 'id',
    agentId: 'agentId',
    latitude: 'latitude',
    longitude: 'longitude',
    timestamp: 'timestamp'
  };

  export type AgentLocationScalarFieldEnum = (typeof AgentLocationScalarFieldEnum)[keyof typeof AgentLocationScalarFieldEnum]


  export const PartnerScalarFieldEnum: {
    id: 'id',
    userId: 'userId',
    companyName: 'companyName',
    apiKey: 'apiKey',
    webhookUrl: 'webhookUrl',
    isActive: 'isActive',
    city: 'city',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type PartnerScalarFieldEnum = (typeof PartnerScalarFieldEnum)[keyof typeof PartnerScalarFieldEnum]


  export const OrderScalarFieldEnum: {
    id: 'id',
    partnerId: 'partnerId',
    agentId: 'agentId',
    pickupLat: 'pickupLat',
    pickupLng: 'pickupLng',
    dropLat: 'dropLat',
    dropLng: 'dropLng',
    payoutAmount: 'payoutAmount',
    orderAmount: 'orderAmount',
    platformFee: 'platformFee',
    orderType: 'orderType',
    commissionRate: 'commissionRate',
    priority: 'priority',
    status: 'status',
    assignedAt: 'assignedAt',
    pickedUpAt: 'pickedUpAt',
    deliveredAt: 'deliveredAt',
    cancelledAt: 'cancelledAt',
    cancellationReason: 'cancellationReason',
    estimatedDuration: 'estimatedDuration',
    actualDuration: 'actualDuration',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt',
    barcode: 'barcode',
    qrCode: 'qrCode',
    deliveryOtp: 'deliveryOtp',
    deliveryQrCode: 'deliveryQrCode',
    otpExpiresAt: 'otpExpiresAt',
    verifiedAt: 'verifiedAt',
    verificationMethod: 'verificationMethod'
  };

  export type OrderScalarFieldEnum = (typeof OrderScalarFieldEnum)[keyof typeof OrderScalarFieldEnum]


  export const NotificationTokenScalarFieldEnum: {
    id: 'id',
    userId: 'userId',
    fcmToken: 'fcmToken',
    deviceType: 'deviceType',
    isActive: 'isActive',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type NotificationTokenScalarFieldEnum = (typeof NotificationTokenScalarFieldEnum)[keyof typeof NotificationTokenScalarFieldEnum]


  export const SupportTicketScalarFieldEnum: {
    id: 'id',
    orderId: 'orderId',
    agentId: 'agentId',
    partnerId: 'partnerId',
    userId: 'userId',
    issueType: 'issueType',
    description: 'description',
    status: 'status',
    resolvedAt: 'resolvedAt',
    adminNotes: 'adminNotes',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type SupportTicketScalarFieldEnum = (typeof SupportTicketScalarFieldEnum)[keyof typeof SupportTicketScalarFieldEnum]


  export const AppEventScalarFieldEnum: {
    id: 'id',
    userId: 'userId',
    actorType: 'actorType',
    eventType: 'eventType',
    entityType: 'entityType',
    entityId: 'entityId',
    metadata: 'metadata',
    createdAt: 'createdAt'
  };

  export type AppEventScalarFieldEnum = (typeof AppEventScalarFieldEnum)[keyof typeof AppEventScalarFieldEnum]


  export const DailyStatsScalarFieldEnum: {
    id: 'id',
    date: 'date',
    totalOrders: 'totalOrders',
    completedOrders: 'completedOrders',
    cancelledOrders: 'cancelledOrders',
    activeAgents: 'activeAgents',
    avgAssignmentTime: 'avgAssignmentTime',
    totalPayout: 'totalPayout',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type DailyStatsScalarFieldEnum = (typeof DailyStatsScalarFieldEnum)[keyof typeof DailyStatsScalarFieldEnum]


  export const PartnerDailyStatsScalarFieldEnum: {
    id: 'id',
    partnerId: 'partnerId',
    date: 'date',
    totalOrders: 'totalOrders',
    completedOrders: 'completedOrders',
    cancelledOrders: 'cancelledOrders',
    avgAssignmentTime: 'avgAssignmentTime',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type PartnerDailyStatsScalarFieldEnum = (typeof PartnerDailyStatsScalarFieldEnum)[keyof typeof PartnerDailyStatsScalarFieldEnum]


  export const PartnerRevenueScalarFieldEnum: {
    id: 'id',
    partnerId: 'partnerId',
    orderId: 'orderId',
    orderAmount: 'orderAmount',
    deliveryFee: 'deliveryFee',
    platformFee: 'platformFee',
    netRevenue: 'netRevenue',
    status: 'status',
    processedAt: 'processedAt',
    periodStart: 'periodStart',
    periodEnd: 'periodEnd',
    periodType: 'periodType',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type PartnerRevenueScalarFieldEnum = (typeof PartnerRevenueScalarFieldEnum)[keyof typeof PartnerRevenueScalarFieldEnum]


  export const PlatformRevenueScalarFieldEnum: {
    id: 'id',
    orderId: 'orderId',
    partnerId: 'partnerId',
    agentId: 'agentId',
    orderAmount: 'orderAmount',
    platformFee: 'platformFee',
    agentPayout: 'agentPayout',
    netRevenue: 'netRevenue',
    revenueType: 'revenueType',
    status: 'status',
    processedAt: 'processedAt',
    periodStart: 'periodStart',
    periodEnd: 'periodEnd',
    periodType: 'periodType',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type PlatformRevenueScalarFieldEnum = (typeof PlatformRevenueScalarFieldEnum)[keyof typeof PlatformRevenueScalarFieldEnum]


  export const AdminWalletScalarFieldEnum: {
    id: 'id',
    balance: 'balance',
    totalDeposited: 'totalDeposited',
    totalPaidOut: 'totalPaidOut',
    lastUpdated: 'lastUpdated',
    createdAt: 'createdAt'
  };

  export type AdminWalletScalarFieldEnum = (typeof AdminWalletScalarFieldEnum)[keyof typeof AdminWalletScalarFieldEnum]


  export const AgentWalletScalarFieldEnum: {
    id: 'id',
    agentId: 'agentId',
    balance: 'balance',
    totalEarned: 'totalEarned',
    totalPaidOut: 'totalPaidOut',
    lastPayoutDate: 'lastPayoutDate',
    nextPayoutDate: 'nextPayoutDate',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type AgentWalletScalarFieldEnum = (typeof AgentWalletScalarFieldEnum)[keyof typeof AgentWalletScalarFieldEnum]


  export const WalletTransactionScalarFieldEnum: {
    id: 'id',
    walletType: 'walletType',
    adminWalletId: 'adminWalletId',
    agentWalletId: 'agentWalletId',
    orderId: 'orderId',
    amount: 'amount',
    type: 'type',
    description: 'description',
    balanceBefore: 'balanceBefore',
    balanceAfter: 'balanceAfter',
    status: 'status',
    createdAt: 'createdAt'
  };

  export type WalletTransactionScalarFieldEnum = (typeof WalletTransactionScalarFieldEnum)[keyof typeof WalletTransactionScalarFieldEnum]


  export const WalletPayoutScalarFieldEnum: {
    id: 'id',
    agentWalletId: 'agentWalletId',
    agentId: 'agentId',
    amount: 'amount',
    periodStart: 'periodStart',
    periodEnd: 'periodEnd',
    status: 'status',
    paymentMethod: 'paymentMethod',
    transactionId: 'transactionId',
    bankAccount: 'bankAccount',
    upiId: 'upiId',
    processedAt: 'processedAt',
    failedAt: 'failedAt',
    failureReason: 'failureReason',
    notes: 'notes',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type WalletPayoutScalarFieldEnum = (typeof WalletPayoutScalarFieldEnum)[keyof typeof WalletPayoutScalarFieldEnum]


  export const NotificationScalarFieldEnum: {
    id: 'id',
    userId: 'userId',
    title: 'title',
    message: 'message',
    type: 'type',
    isRead: 'isRead',
    link: 'link',
    metadata: 'metadata',
    createdAt: 'createdAt',
    readAt: 'readAt'
  };

  export type NotificationScalarFieldEnum = (typeof NotificationScalarFieldEnum)[keyof typeof NotificationScalarFieldEnum]


  export const AgentRatingScalarFieldEnum: {
    id: 'id',
    orderId: 'orderId',
    agentId: 'agentId',
    partnerId: 'partnerId',
    rating: 'rating',
    comment: 'comment',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type AgentRatingScalarFieldEnum = (typeof AgentRatingScalarFieldEnum)[keyof typeof AgentRatingScalarFieldEnum]


  export const PaymentScalarFieldEnum: {
    id: 'id',
    agentId: 'agentId',
    orderId: 'orderId',
    amount: 'amount',
    paymentType: 'paymentType',
    status: 'status',
    processedAt: 'processedAt',
    paymentMethod: 'paymentMethod',
    transactionId: 'transactionId',
    notes: 'notes',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type PaymentScalarFieldEnum = (typeof PaymentScalarFieldEnum)[keyof typeof PaymentScalarFieldEnum]


  export const PayrollScalarFieldEnum: {
    id: 'id',
    agentId: 'agentId',
    periodStart: 'periodStart',
    periodEnd: 'periodEnd',
    periodType: 'periodType',
    totalEarnings: 'totalEarnings',
    totalOrders: 'totalOrders',
    basePay: 'basePay',
    bonuses: 'bonuses',
    deductions: 'deductions',
    netPay: 'netPay',
    status: 'status',
    processedAt: 'processedAt',
    paidAt: 'paidAt',
    paymentMethod: 'paymentMethod',
    transactionId: 'transactionId',
    notes: 'notes',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type PayrollScalarFieldEnum = (typeof PayrollScalarFieldEnum)[keyof typeof PayrollScalarFieldEnum]


  export const AgentScheduleScalarFieldEnum: {
    id: 'id',
    agentId: 'agentId',
    date: 'date',
    startTime: 'startTime',
    endTime: 'endTime',
    isAvailable: 'isAvailable',
    notes: 'notes',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type AgentScheduleScalarFieldEnum = (typeof AgentScheduleScalarFieldEnum)[keyof typeof AgentScheduleScalarFieldEnum]


  export const PayStructureScalarFieldEnum: {
    id: 'id',
    name: 'name',
    payType: 'payType',
    baseRate: 'baseRate',
    commissionRate: 'commissionRate',
    minGuarantee: 'minGuarantee',
    maxLimit: 'maxLimit',
    bonusRules: 'bonusRules',
    deductionRules: 'deductionRules',
    isActive: 'isActive',
    effectiveFrom: 'effectiveFrom',
    effectiveTo: 'effectiveTo',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type PayStructureScalarFieldEnum = (typeof PayStructureScalarFieldEnum)[keyof typeof PayStructureScalarFieldEnum]


  export const SortOrder: {
    asc: 'asc',
    desc: 'desc'
  };

  export type SortOrder = (typeof SortOrder)[keyof typeof SortOrder]


  export const NullableJsonNullValueInput: {
    DbNull: typeof DbNull,
    JsonNull: typeof JsonNull
  };

  export type NullableJsonNullValueInput = (typeof NullableJsonNullValueInput)[keyof typeof NullableJsonNullValueInput]


  export const QueryMode: {
    default: 'default',
    insensitive: 'insensitive'
  };

  export type QueryMode = (typeof QueryMode)[keyof typeof QueryMode]


  export const NullsOrder: {
    first: 'first',
    last: 'last'
  };

  export type NullsOrder = (typeof NullsOrder)[keyof typeof NullsOrder]


  export const JsonNullValueFilter: {
    DbNull: typeof DbNull,
    JsonNull: typeof JsonNull,
    AnyNull: typeof AnyNull
  };

  export type JsonNullValueFilter = (typeof JsonNullValueFilter)[keyof typeof JsonNullValueFilter]


  /**
   * Field references
   */


  /**
   * Reference to a field of type 'String'
   */
  export type StringFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'String'>
    


  /**
   * Reference to a field of type 'String[]'
   */
  export type ListStringFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'String[]'>
    


  /**
   * Reference to a field of type 'UserRole'
   */
  export type EnumUserRoleFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'UserRole'>
    


  /**
   * Reference to a field of type 'UserRole[]'
   */
  export type ListEnumUserRoleFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'UserRole[]'>
    


  /**
   * Reference to a field of type 'DateTime'
   */
  export type DateTimeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'DateTime'>
    


  /**
   * Reference to a field of type 'DateTime[]'
   */
  export type ListDateTimeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'DateTime[]'>
    


  /**
   * Reference to a field of type 'Boolean'
   */
  export type BooleanFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Boolean'>
    


  /**
   * Reference to a field of type 'VehicleType'
   */
  export type EnumVehicleTypeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'VehicleType'>
    


  /**
   * Reference to a field of type 'VehicleType[]'
   */
  export type ListEnumVehicleTypeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'VehicleType[]'>
    


  /**
   * Reference to a field of type 'AgentStatus'
   */
  export type EnumAgentStatusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'AgentStatus'>
    


  /**
   * Reference to a field of type 'AgentStatus[]'
   */
  export type ListEnumAgentStatusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'AgentStatus[]'>
    


  /**
   * Reference to a field of type 'Float'
   */
  export type FloatFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Float'>
    


  /**
   * Reference to a field of type 'Float[]'
   */
  export type ListFloatFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Float[]'>
    


  /**
   * Reference to a field of type 'Int'
   */
  export type IntFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Int'>
    


  /**
   * Reference to a field of type 'Int[]'
   */
  export type ListIntFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Int[]'>
    


  /**
   * Reference to a field of type 'OrderStatus'
   */
  export type EnumOrderStatusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'OrderStatus'>
    


  /**
   * Reference to a field of type 'OrderStatus[]'
   */
  export type ListEnumOrderStatusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'OrderStatus[]'>
    


  /**
   * Reference to a field of type 'TicketStatus'
   */
  export type EnumTicketStatusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'TicketStatus'>
    


  /**
   * Reference to a field of type 'TicketStatus[]'
   */
  export type ListEnumTicketStatusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'TicketStatus[]'>
    


  /**
   * Reference to a field of type 'ActorType'
   */
  export type EnumActorTypeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'ActorType'>
    


  /**
   * Reference to a field of type 'ActorType[]'
   */
  export type ListEnumActorTypeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'ActorType[]'>
    


  /**
   * Reference to a field of type 'EventType'
   */
  export type EnumEventTypeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'EventType'>
    


  /**
   * Reference to a field of type 'EventType[]'
   */
  export type ListEnumEventTypeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'EventType[]'>
    


  /**
   * Reference to a field of type 'Json'
   */
  export type JsonFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Json'>
    


  /**
   * Reference to a field of type 'QueryMode'
   */
  export type EnumQueryModeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'QueryMode'>
    
  /**
   * Deep Input Types
   */


  export type UserWhereInput = {
    AND?: UserWhereInput | UserWhereInput[]
    OR?: UserWhereInput[]
    NOT?: UserWhereInput | UserWhereInput[]
    id?: StringFilter<"User"> | string
    name?: StringFilter<"User"> | string
    email?: StringFilter<"User"> | string
    phone?: StringFilter<"User"> | string
    passwordHash?: StringFilter<"User"> | string
    role?: EnumUserRoleFilter<"User"> | $Enums.UserRole
    emailVerified?: DateTimeNullableFilter<"User"> | Date | string | null
    phoneVerified?: BoolFilter<"User"> | boolean
    profilePicture?: StringNullableFilter<"User"> | string | null
    createdAt?: DateTimeFilter<"User"> | Date | string
    updatedAt?: DateTimeFilter<"User"> | Date | string
    agent?: XOR<AgentNullableScalarRelationFilter, AgentWhereInput> | null
    partner?: XOR<PartnerNullableScalarRelationFilter, PartnerWhereInput> | null
    notifications?: NotificationTokenListRelationFilter
    userNotifications?: NotificationListRelationFilter
    tickets?: SupportTicketListRelationFilter
  }

  export type UserOrderByWithRelationInput = {
    id?: SortOrder
    name?: SortOrder
    email?: SortOrder
    phone?: SortOrder
    passwordHash?: SortOrder
    role?: SortOrder
    emailVerified?: SortOrderInput | SortOrder
    phoneVerified?: SortOrder
    profilePicture?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    agent?: AgentOrderByWithRelationInput
    partner?: PartnerOrderByWithRelationInput
    notifications?: NotificationTokenOrderByRelationAggregateInput
    userNotifications?: NotificationOrderByRelationAggregateInput
    tickets?: SupportTicketOrderByRelationAggregateInput
  }

  export type UserWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    email?: string
    phone?: string
    AND?: UserWhereInput | UserWhereInput[]
    OR?: UserWhereInput[]
    NOT?: UserWhereInput | UserWhereInput[]
    name?: StringFilter<"User"> | string
    passwordHash?: StringFilter<"User"> | string
    role?: EnumUserRoleFilter<"User"> | $Enums.UserRole
    emailVerified?: DateTimeNullableFilter<"User"> | Date | string | null
    phoneVerified?: BoolFilter<"User"> | boolean
    profilePicture?: StringNullableFilter<"User"> | string | null
    createdAt?: DateTimeFilter<"User"> | Date | string
    updatedAt?: DateTimeFilter<"User"> | Date | string
    agent?: XOR<AgentNullableScalarRelationFilter, AgentWhereInput> | null
    partner?: XOR<PartnerNullableScalarRelationFilter, PartnerWhereInput> | null
    notifications?: NotificationTokenListRelationFilter
    userNotifications?: NotificationListRelationFilter
    tickets?: SupportTicketListRelationFilter
  }, "id" | "email" | "phone">

  export type UserOrderByWithAggregationInput = {
    id?: SortOrder
    name?: SortOrder
    email?: SortOrder
    phone?: SortOrder
    passwordHash?: SortOrder
    role?: SortOrder
    emailVerified?: SortOrderInput | SortOrder
    phoneVerified?: SortOrder
    profilePicture?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: UserCountOrderByAggregateInput
    _max?: UserMaxOrderByAggregateInput
    _min?: UserMinOrderByAggregateInput
  }

  export type UserScalarWhereWithAggregatesInput = {
    AND?: UserScalarWhereWithAggregatesInput | UserScalarWhereWithAggregatesInput[]
    OR?: UserScalarWhereWithAggregatesInput[]
    NOT?: UserScalarWhereWithAggregatesInput | UserScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"User"> | string
    name?: StringWithAggregatesFilter<"User"> | string
    email?: StringWithAggregatesFilter<"User"> | string
    phone?: StringWithAggregatesFilter<"User"> | string
    passwordHash?: StringWithAggregatesFilter<"User"> | string
    role?: EnumUserRoleWithAggregatesFilter<"User"> | $Enums.UserRole
    emailVerified?: DateTimeNullableWithAggregatesFilter<"User"> | Date | string | null
    phoneVerified?: BoolWithAggregatesFilter<"User"> | boolean
    profilePicture?: StringNullableWithAggregatesFilter<"User"> | string | null
    createdAt?: DateTimeWithAggregatesFilter<"User"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"User"> | Date | string
  }

  export type AgentWhereInput = {
    AND?: AgentWhereInput | AgentWhereInput[]
    OR?: AgentWhereInput[]
    NOT?: AgentWhereInput | AgentWhereInput[]
    id?: StringFilter<"Agent"> | string
    userId?: StringFilter<"Agent"> | string
    vehicleType?: EnumVehicleTypeFilter<"Agent"> | $Enums.VehicleType
    status?: EnumAgentStatusFilter<"Agent"> | $Enums.AgentStatus
    rating?: FloatNullableFilter<"Agent"> | number | null
    totalOrders?: IntFilter<"Agent"> | number
    completedOrders?: IntFilter<"Agent"> | number
    cancelledOrders?: IntFilter<"Agent"> | number
    acceptanceRate?: FloatFilter<"Agent"> | number
    currentOrderId?: StringNullableFilter<"Agent"> | string | null
    isApproved?: BoolFilter<"Agent"> | boolean
    isBlocked?: BoolFilter<"Agent"> | boolean
    blockedReason?: StringNullableFilter<"Agent"> | string | null
    city?: StringNullableFilter<"Agent"> | string | null
    state?: StringNullableFilter<"Agent"> | string | null
    pincode?: StringNullableFilter<"Agent"> | string | null
    lastOnlineAt?: DateTimeNullableFilter<"Agent"> | Date | string | null
    createdAt?: DateTimeFilter<"Agent"> | Date | string
    updatedAt?: DateTimeFilter<"Agent"> | Date | string
    user?: XOR<UserScalarRelationFilter, UserWhereInput>
    orders?: OrderListRelationFilter
    currentOrder?: XOR<OrderNullableScalarRelationFilter, OrderWhereInput> | null
    documents?: AgentDocumentListRelationFilter
    locationHistory?: AgentLocationListRelationFilter
    tickets?: SupportTicketListRelationFilter
    ratings?: AgentRatingListRelationFilter
    wallet?: XOR<AgentWalletNullableScalarRelationFilter, AgentWalletWhereInput> | null
    walletPayouts?: WalletPayoutListRelationFilter
    payments?: PaymentListRelationFilter
    payrolls?: PayrollListRelationFilter
    schedules?: AgentScheduleListRelationFilter
  }

  export type AgentOrderByWithRelationInput = {
    id?: SortOrder
    userId?: SortOrder
    vehicleType?: SortOrder
    status?: SortOrder
    rating?: SortOrderInput | SortOrder
    totalOrders?: SortOrder
    completedOrders?: SortOrder
    cancelledOrders?: SortOrder
    acceptanceRate?: SortOrder
    currentOrderId?: SortOrderInput | SortOrder
    isApproved?: SortOrder
    isBlocked?: SortOrder
    blockedReason?: SortOrderInput | SortOrder
    city?: SortOrderInput | SortOrder
    state?: SortOrderInput | SortOrder
    pincode?: SortOrderInput | SortOrder
    lastOnlineAt?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    user?: UserOrderByWithRelationInput
    orders?: OrderOrderByRelationAggregateInput
    currentOrder?: OrderOrderByWithRelationInput
    documents?: AgentDocumentOrderByRelationAggregateInput
    locationHistory?: AgentLocationOrderByRelationAggregateInput
    tickets?: SupportTicketOrderByRelationAggregateInput
    ratings?: AgentRatingOrderByRelationAggregateInput
    wallet?: AgentWalletOrderByWithRelationInput
    walletPayouts?: WalletPayoutOrderByRelationAggregateInput
    payments?: PaymentOrderByRelationAggregateInput
    payrolls?: PayrollOrderByRelationAggregateInput
    schedules?: AgentScheduleOrderByRelationAggregateInput
  }

  export type AgentWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    userId?: string
    currentOrderId?: string
    AND?: AgentWhereInput | AgentWhereInput[]
    OR?: AgentWhereInput[]
    NOT?: AgentWhereInput | AgentWhereInput[]
    vehicleType?: EnumVehicleTypeFilter<"Agent"> | $Enums.VehicleType
    status?: EnumAgentStatusFilter<"Agent"> | $Enums.AgentStatus
    rating?: FloatNullableFilter<"Agent"> | number | null
    totalOrders?: IntFilter<"Agent"> | number
    completedOrders?: IntFilter<"Agent"> | number
    cancelledOrders?: IntFilter<"Agent"> | number
    acceptanceRate?: FloatFilter<"Agent"> | number
    isApproved?: BoolFilter<"Agent"> | boolean
    isBlocked?: BoolFilter<"Agent"> | boolean
    blockedReason?: StringNullableFilter<"Agent"> | string | null
    city?: StringNullableFilter<"Agent"> | string | null
    state?: StringNullableFilter<"Agent"> | string | null
    pincode?: StringNullableFilter<"Agent"> | string | null
    lastOnlineAt?: DateTimeNullableFilter<"Agent"> | Date | string | null
    createdAt?: DateTimeFilter<"Agent"> | Date | string
    updatedAt?: DateTimeFilter<"Agent"> | Date | string
    user?: XOR<UserScalarRelationFilter, UserWhereInput>
    orders?: OrderListRelationFilter
    currentOrder?: XOR<OrderNullableScalarRelationFilter, OrderWhereInput> | null
    documents?: AgentDocumentListRelationFilter
    locationHistory?: AgentLocationListRelationFilter
    tickets?: SupportTicketListRelationFilter
    ratings?: AgentRatingListRelationFilter
    wallet?: XOR<AgentWalletNullableScalarRelationFilter, AgentWalletWhereInput> | null
    walletPayouts?: WalletPayoutListRelationFilter
    payments?: PaymentListRelationFilter
    payrolls?: PayrollListRelationFilter
    schedules?: AgentScheduleListRelationFilter
  }, "id" | "userId" | "currentOrderId">

  export type AgentOrderByWithAggregationInput = {
    id?: SortOrder
    userId?: SortOrder
    vehicleType?: SortOrder
    status?: SortOrder
    rating?: SortOrderInput | SortOrder
    totalOrders?: SortOrder
    completedOrders?: SortOrder
    cancelledOrders?: SortOrder
    acceptanceRate?: SortOrder
    currentOrderId?: SortOrderInput | SortOrder
    isApproved?: SortOrder
    isBlocked?: SortOrder
    blockedReason?: SortOrderInput | SortOrder
    city?: SortOrderInput | SortOrder
    state?: SortOrderInput | SortOrder
    pincode?: SortOrderInput | SortOrder
    lastOnlineAt?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: AgentCountOrderByAggregateInput
    _avg?: AgentAvgOrderByAggregateInput
    _max?: AgentMaxOrderByAggregateInput
    _min?: AgentMinOrderByAggregateInput
    _sum?: AgentSumOrderByAggregateInput
  }

  export type AgentScalarWhereWithAggregatesInput = {
    AND?: AgentScalarWhereWithAggregatesInput | AgentScalarWhereWithAggregatesInput[]
    OR?: AgentScalarWhereWithAggregatesInput[]
    NOT?: AgentScalarWhereWithAggregatesInput | AgentScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Agent"> | string
    userId?: StringWithAggregatesFilter<"Agent"> | string
    vehicleType?: EnumVehicleTypeWithAggregatesFilter<"Agent"> | $Enums.VehicleType
    status?: EnumAgentStatusWithAggregatesFilter<"Agent"> | $Enums.AgentStatus
    rating?: FloatNullableWithAggregatesFilter<"Agent"> | number | null
    totalOrders?: IntWithAggregatesFilter<"Agent"> | number
    completedOrders?: IntWithAggregatesFilter<"Agent"> | number
    cancelledOrders?: IntWithAggregatesFilter<"Agent"> | number
    acceptanceRate?: FloatWithAggregatesFilter<"Agent"> | number
    currentOrderId?: StringNullableWithAggregatesFilter<"Agent"> | string | null
    isApproved?: BoolWithAggregatesFilter<"Agent"> | boolean
    isBlocked?: BoolWithAggregatesFilter<"Agent"> | boolean
    blockedReason?: StringNullableWithAggregatesFilter<"Agent"> | string | null
    city?: StringNullableWithAggregatesFilter<"Agent"> | string | null
    state?: StringNullableWithAggregatesFilter<"Agent"> | string | null
    pincode?: StringNullableWithAggregatesFilter<"Agent"> | string | null
    lastOnlineAt?: DateTimeNullableWithAggregatesFilter<"Agent"> | Date | string | null
    createdAt?: DateTimeWithAggregatesFilter<"Agent"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"Agent"> | Date | string
  }

  export type AgentDocumentWhereInput = {
    AND?: AgentDocumentWhereInput | AgentDocumentWhereInput[]
    OR?: AgentDocumentWhereInput[]
    NOT?: AgentDocumentWhereInput | AgentDocumentWhereInput[]
    id?: StringFilter<"AgentDocument"> | string
    agentId?: StringFilter<"AgentDocument"> | string
    documentType?: StringFilter<"AgentDocument"> | string
    fileName?: StringFilter<"AgentDocument"> | string
    fileUrl?: StringFilter<"AgentDocument"> | string
    verified?: BoolFilter<"AgentDocument"> | boolean
    uploadedAt?: DateTimeFilter<"AgentDocument"> | Date | string
    agent?: XOR<AgentScalarRelationFilter, AgentWhereInput>
  }

  export type AgentDocumentOrderByWithRelationInput = {
    id?: SortOrder
    agentId?: SortOrder
    documentType?: SortOrder
    fileName?: SortOrder
    fileUrl?: SortOrder
    verified?: SortOrder
    uploadedAt?: SortOrder
    agent?: AgentOrderByWithRelationInput
  }

  export type AgentDocumentWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: AgentDocumentWhereInput | AgentDocumentWhereInput[]
    OR?: AgentDocumentWhereInput[]
    NOT?: AgentDocumentWhereInput | AgentDocumentWhereInput[]
    agentId?: StringFilter<"AgentDocument"> | string
    documentType?: StringFilter<"AgentDocument"> | string
    fileName?: StringFilter<"AgentDocument"> | string
    fileUrl?: StringFilter<"AgentDocument"> | string
    verified?: BoolFilter<"AgentDocument"> | boolean
    uploadedAt?: DateTimeFilter<"AgentDocument"> | Date | string
    agent?: XOR<AgentScalarRelationFilter, AgentWhereInput>
  }, "id">

  export type AgentDocumentOrderByWithAggregationInput = {
    id?: SortOrder
    agentId?: SortOrder
    documentType?: SortOrder
    fileName?: SortOrder
    fileUrl?: SortOrder
    verified?: SortOrder
    uploadedAt?: SortOrder
    _count?: AgentDocumentCountOrderByAggregateInput
    _max?: AgentDocumentMaxOrderByAggregateInput
    _min?: AgentDocumentMinOrderByAggregateInput
  }

  export type AgentDocumentScalarWhereWithAggregatesInput = {
    AND?: AgentDocumentScalarWhereWithAggregatesInput | AgentDocumentScalarWhereWithAggregatesInput[]
    OR?: AgentDocumentScalarWhereWithAggregatesInput[]
    NOT?: AgentDocumentScalarWhereWithAggregatesInput | AgentDocumentScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"AgentDocument"> | string
    agentId?: StringWithAggregatesFilter<"AgentDocument"> | string
    documentType?: StringWithAggregatesFilter<"AgentDocument"> | string
    fileName?: StringWithAggregatesFilter<"AgentDocument"> | string
    fileUrl?: StringWithAggregatesFilter<"AgentDocument"> | string
    verified?: BoolWithAggregatesFilter<"AgentDocument"> | boolean
    uploadedAt?: DateTimeWithAggregatesFilter<"AgentDocument"> | Date | string
  }

  export type AgentLocationWhereInput = {
    AND?: AgentLocationWhereInput | AgentLocationWhereInput[]
    OR?: AgentLocationWhereInput[]
    NOT?: AgentLocationWhereInput | AgentLocationWhereInput[]
    id?: StringFilter<"AgentLocation"> | string
    agentId?: StringFilter<"AgentLocation"> | string
    latitude?: FloatFilter<"AgentLocation"> | number
    longitude?: FloatFilter<"AgentLocation"> | number
    timestamp?: DateTimeFilter<"AgentLocation"> | Date | string
    agent?: XOR<AgentScalarRelationFilter, AgentWhereInput>
  }

  export type AgentLocationOrderByWithRelationInput = {
    id?: SortOrder
    agentId?: SortOrder
    latitude?: SortOrder
    longitude?: SortOrder
    timestamp?: SortOrder
    agent?: AgentOrderByWithRelationInput
  }

  export type AgentLocationWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: AgentLocationWhereInput | AgentLocationWhereInput[]
    OR?: AgentLocationWhereInput[]
    NOT?: AgentLocationWhereInput | AgentLocationWhereInput[]
    agentId?: StringFilter<"AgentLocation"> | string
    latitude?: FloatFilter<"AgentLocation"> | number
    longitude?: FloatFilter<"AgentLocation"> | number
    timestamp?: DateTimeFilter<"AgentLocation"> | Date | string
    agent?: XOR<AgentScalarRelationFilter, AgentWhereInput>
  }, "id">

  export type AgentLocationOrderByWithAggregationInput = {
    id?: SortOrder
    agentId?: SortOrder
    latitude?: SortOrder
    longitude?: SortOrder
    timestamp?: SortOrder
    _count?: AgentLocationCountOrderByAggregateInput
    _avg?: AgentLocationAvgOrderByAggregateInput
    _max?: AgentLocationMaxOrderByAggregateInput
    _min?: AgentLocationMinOrderByAggregateInput
    _sum?: AgentLocationSumOrderByAggregateInput
  }

  export type AgentLocationScalarWhereWithAggregatesInput = {
    AND?: AgentLocationScalarWhereWithAggregatesInput | AgentLocationScalarWhereWithAggregatesInput[]
    OR?: AgentLocationScalarWhereWithAggregatesInput[]
    NOT?: AgentLocationScalarWhereWithAggregatesInput | AgentLocationScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"AgentLocation"> | string
    agentId?: StringWithAggregatesFilter<"AgentLocation"> | string
    latitude?: FloatWithAggregatesFilter<"AgentLocation"> | number
    longitude?: FloatWithAggregatesFilter<"AgentLocation"> | number
    timestamp?: DateTimeWithAggregatesFilter<"AgentLocation"> | Date | string
  }

  export type PartnerWhereInput = {
    AND?: PartnerWhereInput | PartnerWhereInput[]
    OR?: PartnerWhereInput[]
    NOT?: PartnerWhereInput | PartnerWhereInput[]
    id?: StringFilter<"Partner"> | string
    userId?: StringFilter<"Partner"> | string
    companyName?: StringFilter<"Partner"> | string
    apiKey?: StringFilter<"Partner"> | string
    webhookUrl?: StringNullableFilter<"Partner"> | string | null
    isActive?: BoolFilter<"Partner"> | boolean
    city?: StringNullableFilter<"Partner"> | string | null
    createdAt?: DateTimeFilter<"Partner"> | Date | string
    updatedAt?: DateTimeFilter<"Partner"> | Date | string
    user?: XOR<UserScalarRelationFilter, UserWhereInput>
    orders?: OrderListRelationFilter
    tickets?: SupportTicketListRelationFilter
    dailyStats?: PartnerDailyStatsListRelationFilter
    agentRatings?: AgentRatingListRelationFilter
    partnerRevenues?: PartnerRevenueListRelationFilter
    platformRevenues?: PlatformRevenueListRelationFilter
  }

  export type PartnerOrderByWithRelationInput = {
    id?: SortOrder
    userId?: SortOrder
    companyName?: SortOrder
    apiKey?: SortOrder
    webhookUrl?: SortOrderInput | SortOrder
    isActive?: SortOrder
    city?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    user?: UserOrderByWithRelationInput
    orders?: OrderOrderByRelationAggregateInput
    tickets?: SupportTicketOrderByRelationAggregateInput
    dailyStats?: PartnerDailyStatsOrderByRelationAggregateInput
    agentRatings?: AgentRatingOrderByRelationAggregateInput
    partnerRevenues?: PartnerRevenueOrderByRelationAggregateInput
    platformRevenues?: PlatformRevenueOrderByRelationAggregateInput
  }

  export type PartnerWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    userId?: string
    apiKey?: string
    AND?: PartnerWhereInput | PartnerWhereInput[]
    OR?: PartnerWhereInput[]
    NOT?: PartnerWhereInput | PartnerWhereInput[]
    companyName?: StringFilter<"Partner"> | string
    webhookUrl?: StringNullableFilter<"Partner"> | string | null
    isActive?: BoolFilter<"Partner"> | boolean
    city?: StringNullableFilter<"Partner"> | string | null
    createdAt?: DateTimeFilter<"Partner"> | Date | string
    updatedAt?: DateTimeFilter<"Partner"> | Date | string
    user?: XOR<UserScalarRelationFilter, UserWhereInput>
    orders?: OrderListRelationFilter
    tickets?: SupportTicketListRelationFilter
    dailyStats?: PartnerDailyStatsListRelationFilter
    agentRatings?: AgentRatingListRelationFilter
    partnerRevenues?: PartnerRevenueListRelationFilter
    platformRevenues?: PlatformRevenueListRelationFilter
  }, "id" | "userId" | "apiKey">

  export type PartnerOrderByWithAggregationInput = {
    id?: SortOrder
    userId?: SortOrder
    companyName?: SortOrder
    apiKey?: SortOrder
    webhookUrl?: SortOrderInput | SortOrder
    isActive?: SortOrder
    city?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: PartnerCountOrderByAggregateInput
    _max?: PartnerMaxOrderByAggregateInput
    _min?: PartnerMinOrderByAggregateInput
  }

  export type PartnerScalarWhereWithAggregatesInput = {
    AND?: PartnerScalarWhereWithAggregatesInput | PartnerScalarWhereWithAggregatesInput[]
    OR?: PartnerScalarWhereWithAggregatesInput[]
    NOT?: PartnerScalarWhereWithAggregatesInput | PartnerScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Partner"> | string
    userId?: StringWithAggregatesFilter<"Partner"> | string
    companyName?: StringWithAggregatesFilter<"Partner"> | string
    apiKey?: StringWithAggregatesFilter<"Partner"> | string
    webhookUrl?: StringNullableWithAggregatesFilter<"Partner"> | string | null
    isActive?: BoolWithAggregatesFilter<"Partner"> | boolean
    city?: StringNullableWithAggregatesFilter<"Partner"> | string | null
    createdAt?: DateTimeWithAggregatesFilter<"Partner"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"Partner"> | Date | string
  }

  export type OrderWhereInput = {
    AND?: OrderWhereInput | OrderWhereInput[]
    OR?: OrderWhereInput[]
    NOT?: OrderWhereInput | OrderWhereInput[]
    id?: StringFilter<"Order"> | string
    partnerId?: StringFilter<"Order"> | string
    agentId?: StringNullableFilter<"Order"> | string | null
    pickupLat?: FloatFilter<"Order"> | number
    pickupLng?: FloatFilter<"Order"> | number
    dropLat?: FloatFilter<"Order"> | number
    dropLng?: FloatFilter<"Order"> | number
    payoutAmount?: FloatFilter<"Order"> | number
    orderAmount?: FloatNullableFilter<"Order"> | number | null
    platformFee?: FloatNullableFilter<"Order"> | number | null
    orderType?: StringNullableFilter<"Order"> | string | null
    commissionRate?: FloatNullableFilter<"Order"> | number | null
    priority?: StringNullableFilter<"Order"> | string | null
    status?: EnumOrderStatusFilter<"Order"> | $Enums.OrderStatus
    assignedAt?: DateTimeNullableFilter<"Order"> | Date | string | null
    pickedUpAt?: DateTimeNullableFilter<"Order"> | Date | string | null
    deliveredAt?: DateTimeNullableFilter<"Order"> | Date | string | null
    cancelledAt?: DateTimeNullableFilter<"Order"> | Date | string | null
    cancellationReason?: StringNullableFilter<"Order"> | string | null
    estimatedDuration?: IntNullableFilter<"Order"> | number | null
    actualDuration?: IntNullableFilter<"Order"> | number | null
    createdAt?: DateTimeFilter<"Order"> | Date | string
    updatedAt?: DateTimeFilter<"Order"> | Date | string
    barcode?: StringNullableFilter<"Order"> | string | null
    qrCode?: StringNullableFilter<"Order"> | string | null
    deliveryOtp?: StringNullableFilter<"Order"> | string | null
    deliveryQrCode?: StringNullableFilter<"Order"> | string | null
    otpExpiresAt?: DateTimeNullableFilter<"Order"> | Date | string | null
    verifiedAt?: DateTimeNullableFilter<"Order"> | Date | string | null
    verificationMethod?: StringNullableFilter<"Order"> | string | null
    partner?: XOR<PartnerScalarRelationFilter, PartnerWhereInput>
    agent?: XOR<AgentNullableScalarRelationFilter, AgentWhereInput> | null
    currentAgent?: XOR<AgentNullableScalarRelationFilter, AgentWhereInput> | null
    tickets?: SupportTicketListRelationFilter
    rating?: XOR<AgentRatingNullableScalarRelationFilter, AgentRatingWhereInput> | null
    payments?: PaymentListRelationFilter
    partnerRevenue?: XOR<PartnerRevenueNullableScalarRelationFilter, PartnerRevenueWhereInput> | null
    platformRevenue?: XOR<PlatformRevenueNullableScalarRelationFilter, PlatformRevenueWhereInput> | null
    walletTransactions?: WalletTransactionListRelationFilter
  }

  export type OrderOrderByWithRelationInput = {
    id?: SortOrder
    partnerId?: SortOrder
    agentId?: SortOrderInput | SortOrder
    pickupLat?: SortOrder
    pickupLng?: SortOrder
    dropLat?: SortOrder
    dropLng?: SortOrder
    payoutAmount?: SortOrder
    orderAmount?: SortOrderInput | SortOrder
    platformFee?: SortOrderInput | SortOrder
    orderType?: SortOrderInput | SortOrder
    commissionRate?: SortOrderInput | SortOrder
    priority?: SortOrderInput | SortOrder
    status?: SortOrder
    assignedAt?: SortOrderInput | SortOrder
    pickedUpAt?: SortOrderInput | SortOrder
    deliveredAt?: SortOrderInput | SortOrder
    cancelledAt?: SortOrderInput | SortOrder
    cancellationReason?: SortOrderInput | SortOrder
    estimatedDuration?: SortOrderInput | SortOrder
    actualDuration?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    barcode?: SortOrderInput | SortOrder
    qrCode?: SortOrderInput | SortOrder
    deliveryOtp?: SortOrderInput | SortOrder
    deliveryQrCode?: SortOrderInput | SortOrder
    otpExpiresAt?: SortOrderInput | SortOrder
    verifiedAt?: SortOrderInput | SortOrder
    verificationMethod?: SortOrderInput | SortOrder
    partner?: PartnerOrderByWithRelationInput
    agent?: AgentOrderByWithRelationInput
    currentAgent?: AgentOrderByWithRelationInput
    tickets?: SupportTicketOrderByRelationAggregateInput
    rating?: AgentRatingOrderByWithRelationInput
    payments?: PaymentOrderByRelationAggregateInput
    partnerRevenue?: PartnerRevenueOrderByWithRelationInput
    platformRevenue?: PlatformRevenueOrderByWithRelationInput
    walletTransactions?: WalletTransactionOrderByRelationAggregateInput
  }

  export type OrderWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    barcode?: string
    qrCode?: string
    deliveryOtp?: string
    deliveryQrCode?: string
    AND?: OrderWhereInput | OrderWhereInput[]
    OR?: OrderWhereInput[]
    NOT?: OrderWhereInput | OrderWhereInput[]
    partnerId?: StringFilter<"Order"> | string
    agentId?: StringNullableFilter<"Order"> | string | null
    pickupLat?: FloatFilter<"Order"> | number
    pickupLng?: FloatFilter<"Order"> | number
    dropLat?: FloatFilter<"Order"> | number
    dropLng?: FloatFilter<"Order"> | number
    payoutAmount?: FloatFilter<"Order"> | number
    orderAmount?: FloatNullableFilter<"Order"> | number | null
    platformFee?: FloatNullableFilter<"Order"> | number | null
    orderType?: StringNullableFilter<"Order"> | string | null
    commissionRate?: FloatNullableFilter<"Order"> | number | null
    priority?: StringNullableFilter<"Order"> | string | null
    status?: EnumOrderStatusFilter<"Order"> | $Enums.OrderStatus
    assignedAt?: DateTimeNullableFilter<"Order"> | Date | string | null
    pickedUpAt?: DateTimeNullableFilter<"Order"> | Date | string | null
    deliveredAt?: DateTimeNullableFilter<"Order"> | Date | string | null
    cancelledAt?: DateTimeNullableFilter<"Order"> | Date | string | null
    cancellationReason?: StringNullableFilter<"Order"> | string | null
    estimatedDuration?: IntNullableFilter<"Order"> | number | null
    actualDuration?: IntNullableFilter<"Order"> | number | null
    createdAt?: DateTimeFilter<"Order"> | Date | string
    updatedAt?: DateTimeFilter<"Order"> | Date | string
    otpExpiresAt?: DateTimeNullableFilter<"Order"> | Date | string | null
    verifiedAt?: DateTimeNullableFilter<"Order"> | Date | string | null
    verificationMethod?: StringNullableFilter<"Order"> | string | null
    partner?: XOR<PartnerScalarRelationFilter, PartnerWhereInput>
    agent?: XOR<AgentNullableScalarRelationFilter, AgentWhereInput> | null
    currentAgent?: XOR<AgentNullableScalarRelationFilter, AgentWhereInput> | null
    tickets?: SupportTicketListRelationFilter
    rating?: XOR<AgentRatingNullableScalarRelationFilter, AgentRatingWhereInput> | null
    payments?: PaymentListRelationFilter
    partnerRevenue?: XOR<PartnerRevenueNullableScalarRelationFilter, PartnerRevenueWhereInput> | null
    platformRevenue?: XOR<PlatformRevenueNullableScalarRelationFilter, PlatformRevenueWhereInput> | null
    walletTransactions?: WalletTransactionListRelationFilter
  }, "id" | "barcode" | "qrCode" | "deliveryOtp" | "deliveryQrCode">

  export type OrderOrderByWithAggregationInput = {
    id?: SortOrder
    partnerId?: SortOrder
    agentId?: SortOrderInput | SortOrder
    pickupLat?: SortOrder
    pickupLng?: SortOrder
    dropLat?: SortOrder
    dropLng?: SortOrder
    payoutAmount?: SortOrder
    orderAmount?: SortOrderInput | SortOrder
    platformFee?: SortOrderInput | SortOrder
    orderType?: SortOrderInput | SortOrder
    commissionRate?: SortOrderInput | SortOrder
    priority?: SortOrderInput | SortOrder
    status?: SortOrder
    assignedAt?: SortOrderInput | SortOrder
    pickedUpAt?: SortOrderInput | SortOrder
    deliveredAt?: SortOrderInput | SortOrder
    cancelledAt?: SortOrderInput | SortOrder
    cancellationReason?: SortOrderInput | SortOrder
    estimatedDuration?: SortOrderInput | SortOrder
    actualDuration?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    barcode?: SortOrderInput | SortOrder
    qrCode?: SortOrderInput | SortOrder
    deliveryOtp?: SortOrderInput | SortOrder
    deliveryQrCode?: SortOrderInput | SortOrder
    otpExpiresAt?: SortOrderInput | SortOrder
    verifiedAt?: SortOrderInput | SortOrder
    verificationMethod?: SortOrderInput | SortOrder
    _count?: OrderCountOrderByAggregateInput
    _avg?: OrderAvgOrderByAggregateInput
    _max?: OrderMaxOrderByAggregateInput
    _min?: OrderMinOrderByAggregateInput
    _sum?: OrderSumOrderByAggregateInput
  }

  export type OrderScalarWhereWithAggregatesInput = {
    AND?: OrderScalarWhereWithAggregatesInput | OrderScalarWhereWithAggregatesInput[]
    OR?: OrderScalarWhereWithAggregatesInput[]
    NOT?: OrderScalarWhereWithAggregatesInput | OrderScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Order"> | string
    partnerId?: StringWithAggregatesFilter<"Order"> | string
    agentId?: StringNullableWithAggregatesFilter<"Order"> | string | null
    pickupLat?: FloatWithAggregatesFilter<"Order"> | number
    pickupLng?: FloatWithAggregatesFilter<"Order"> | number
    dropLat?: FloatWithAggregatesFilter<"Order"> | number
    dropLng?: FloatWithAggregatesFilter<"Order"> | number
    payoutAmount?: FloatWithAggregatesFilter<"Order"> | number
    orderAmount?: FloatNullableWithAggregatesFilter<"Order"> | number | null
    platformFee?: FloatNullableWithAggregatesFilter<"Order"> | number | null
    orderType?: StringNullableWithAggregatesFilter<"Order"> | string | null
    commissionRate?: FloatNullableWithAggregatesFilter<"Order"> | number | null
    priority?: StringNullableWithAggregatesFilter<"Order"> | string | null
    status?: EnumOrderStatusWithAggregatesFilter<"Order"> | $Enums.OrderStatus
    assignedAt?: DateTimeNullableWithAggregatesFilter<"Order"> | Date | string | null
    pickedUpAt?: DateTimeNullableWithAggregatesFilter<"Order"> | Date | string | null
    deliveredAt?: DateTimeNullableWithAggregatesFilter<"Order"> | Date | string | null
    cancelledAt?: DateTimeNullableWithAggregatesFilter<"Order"> | Date | string | null
    cancellationReason?: StringNullableWithAggregatesFilter<"Order"> | string | null
    estimatedDuration?: IntNullableWithAggregatesFilter<"Order"> | number | null
    actualDuration?: IntNullableWithAggregatesFilter<"Order"> | number | null
    createdAt?: DateTimeWithAggregatesFilter<"Order"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"Order"> | Date | string
    barcode?: StringNullableWithAggregatesFilter<"Order"> | string | null
    qrCode?: StringNullableWithAggregatesFilter<"Order"> | string | null
    deliveryOtp?: StringNullableWithAggregatesFilter<"Order"> | string | null
    deliveryQrCode?: StringNullableWithAggregatesFilter<"Order"> | string | null
    otpExpiresAt?: DateTimeNullableWithAggregatesFilter<"Order"> | Date | string | null
    verifiedAt?: DateTimeNullableWithAggregatesFilter<"Order"> | Date | string | null
    verificationMethod?: StringNullableWithAggregatesFilter<"Order"> | string | null
  }

  export type NotificationTokenWhereInput = {
    AND?: NotificationTokenWhereInput | NotificationTokenWhereInput[]
    OR?: NotificationTokenWhereInput[]
    NOT?: NotificationTokenWhereInput | NotificationTokenWhereInput[]
    id?: StringFilter<"NotificationToken"> | string
    userId?: StringFilter<"NotificationToken"> | string
    fcmToken?: StringFilter<"NotificationToken"> | string
    deviceType?: StringNullableFilter<"NotificationToken"> | string | null
    isActive?: BoolFilter<"NotificationToken"> | boolean
    createdAt?: DateTimeFilter<"NotificationToken"> | Date | string
    updatedAt?: DateTimeFilter<"NotificationToken"> | Date | string
    user?: XOR<UserScalarRelationFilter, UserWhereInput>
  }

  export type NotificationTokenOrderByWithRelationInput = {
    id?: SortOrder
    userId?: SortOrder
    fcmToken?: SortOrder
    deviceType?: SortOrderInput | SortOrder
    isActive?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    user?: UserOrderByWithRelationInput
  }

  export type NotificationTokenWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    fcmToken?: string
    AND?: NotificationTokenWhereInput | NotificationTokenWhereInput[]
    OR?: NotificationTokenWhereInput[]
    NOT?: NotificationTokenWhereInput | NotificationTokenWhereInput[]
    userId?: StringFilter<"NotificationToken"> | string
    deviceType?: StringNullableFilter<"NotificationToken"> | string | null
    isActive?: BoolFilter<"NotificationToken"> | boolean
    createdAt?: DateTimeFilter<"NotificationToken"> | Date | string
    updatedAt?: DateTimeFilter<"NotificationToken"> | Date | string
    user?: XOR<UserScalarRelationFilter, UserWhereInput>
  }, "id" | "fcmToken">

  export type NotificationTokenOrderByWithAggregationInput = {
    id?: SortOrder
    userId?: SortOrder
    fcmToken?: SortOrder
    deviceType?: SortOrderInput | SortOrder
    isActive?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: NotificationTokenCountOrderByAggregateInput
    _max?: NotificationTokenMaxOrderByAggregateInput
    _min?: NotificationTokenMinOrderByAggregateInput
  }

  export type NotificationTokenScalarWhereWithAggregatesInput = {
    AND?: NotificationTokenScalarWhereWithAggregatesInput | NotificationTokenScalarWhereWithAggregatesInput[]
    OR?: NotificationTokenScalarWhereWithAggregatesInput[]
    NOT?: NotificationTokenScalarWhereWithAggregatesInput | NotificationTokenScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"NotificationToken"> | string
    userId?: StringWithAggregatesFilter<"NotificationToken"> | string
    fcmToken?: StringWithAggregatesFilter<"NotificationToken"> | string
    deviceType?: StringNullableWithAggregatesFilter<"NotificationToken"> | string | null
    isActive?: BoolWithAggregatesFilter<"NotificationToken"> | boolean
    createdAt?: DateTimeWithAggregatesFilter<"NotificationToken"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"NotificationToken"> | Date | string
  }

  export type SupportTicketWhereInput = {
    AND?: SupportTicketWhereInput | SupportTicketWhereInput[]
    OR?: SupportTicketWhereInput[]
    NOT?: SupportTicketWhereInput | SupportTicketWhereInput[]
    id?: StringFilter<"SupportTicket"> | string
    orderId?: StringNullableFilter<"SupportTicket"> | string | null
    agentId?: StringNullableFilter<"SupportTicket"> | string | null
    partnerId?: StringNullableFilter<"SupportTicket"> | string | null
    userId?: StringFilter<"SupportTicket"> | string
    issueType?: StringFilter<"SupportTicket"> | string
    description?: StringFilter<"SupportTicket"> | string
    status?: EnumTicketStatusFilter<"SupportTicket"> | $Enums.TicketStatus
    resolvedAt?: DateTimeNullableFilter<"SupportTicket"> | Date | string | null
    adminNotes?: StringNullableFilter<"SupportTicket"> | string | null
    createdAt?: DateTimeFilter<"SupportTicket"> | Date | string
    updatedAt?: DateTimeFilter<"SupportTicket"> | Date | string
    order?: XOR<OrderNullableScalarRelationFilter, OrderWhereInput> | null
    agent?: XOR<AgentNullableScalarRelationFilter, AgentWhereInput> | null
    partner?: XOR<PartnerNullableScalarRelationFilter, PartnerWhereInput> | null
    user?: XOR<UserScalarRelationFilter, UserWhereInput>
  }

  export type SupportTicketOrderByWithRelationInput = {
    id?: SortOrder
    orderId?: SortOrderInput | SortOrder
    agentId?: SortOrderInput | SortOrder
    partnerId?: SortOrderInput | SortOrder
    userId?: SortOrder
    issueType?: SortOrder
    description?: SortOrder
    status?: SortOrder
    resolvedAt?: SortOrderInput | SortOrder
    adminNotes?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    order?: OrderOrderByWithRelationInput
    agent?: AgentOrderByWithRelationInput
    partner?: PartnerOrderByWithRelationInput
    user?: UserOrderByWithRelationInput
  }

  export type SupportTicketWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: SupportTicketWhereInput | SupportTicketWhereInput[]
    OR?: SupportTicketWhereInput[]
    NOT?: SupportTicketWhereInput | SupportTicketWhereInput[]
    orderId?: StringNullableFilter<"SupportTicket"> | string | null
    agentId?: StringNullableFilter<"SupportTicket"> | string | null
    partnerId?: StringNullableFilter<"SupportTicket"> | string | null
    userId?: StringFilter<"SupportTicket"> | string
    issueType?: StringFilter<"SupportTicket"> | string
    description?: StringFilter<"SupportTicket"> | string
    status?: EnumTicketStatusFilter<"SupportTicket"> | $Enums.TicketStatus
    resolvedAt?: DateTimeNullableFilter<"SupportTicket"> | Date | string | null
    adminNotes?: StringNullableFilter<"SupportTicket"> | string | null
    createdAt?: DateTimeFilter<"SupportTicket"> | Date | string
    updatedAt?: DateTimeFilter<"SupportTicket"> | Date | string
    order?: XOR<OrderNullableScalarRelationFilter, OrderWhereInput> | null
    agent?: XOR<AgentNullableScalarRelationFilter, AgentWhereInput> | null
    partner?: XOR<PartnerNullableScalarRelationFilter, PartnerWhereInput> | null
    user?: XOR<UserScalarRelationFilter, UserWhereInput>
  }, "id">

  export type SupportTicketOrderByWithAggregationInput = {
    id?: SortOrder
    orderId?: SortOrderInput | SortOrder
    agentId?: SortOrderInput | SortOrder
    partnerId?: SortOrderInput | SortOrder
    userId?: SortOrder
    issueType?: SortOrder
    description?: SortOrder
    status?: SortOrder
    resolvedAt?: SortOrderInput | SortOrder
    adminNotes?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: SupportTicketCountOrderByAggregateInput
    _max?: SupportTicketMaxOrderByAggregateInput
    _min?: SupportTicketMinOrderByAggregateInput
  }

  export type SupportTicketScalarWhereWithAggregatesInput = {
    AND?: SupportTicketScalarWhereWithAggregatesInput | SupportTicketScalarWhereWithAggregatesInput[]
    OR?: SupportTicketScalarWhereWithAggregatesInput[]
    NOT?: SupportTicketScalarWhereWithAggregatesInput | SupportTicketScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"SupportTicket"> | string
    orderId?: StringNullableWithAggregatesFilter<"SupportTicket"> | string | null
    agentId?: StringNullableWithAggregatesFilter<"SupportTicket"> | string | null
    partnerId?: StringNullableWithAggregatesFilter<"SupportTicket"> | string | null
    userId?: StringWithAggregatesFilter<"SupportTicket"> | string
    issueType?: StringWithAggregatesFilter<"SupportTicket"> | string
    description?: StringWithAggregatesFilter<"SupportTicket"> | string
    status?: EnumTicketStatusWithAggregatesFilter<"SupportTicket"> | $Enums.TicketStatus
    resolvedAt?: DateTimeNullableWithAggregatesFilter<"SupportTicket"> | Date | string | null
    adminNotes?: StringNullableWithAggregatesFilter<"SupportTicket"> | string | null
    createdAt?: DateTimeWithAggregatesFilter<"SupportTicket"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"SupportTicket"> | Date | string
  }

  export type AppEventWhereInput = {
    AND?: AppEventWhereInput | AppEventWhereInput[]
    OR?: AppEventWhereInput[]
    NOT?: AppEventWhereInput | AppEventWhereInput[]
    id?: StringFilter<"AppEvent"> | string
    userId?: StringNullableFilter<"AppEvent"> | string | null
    actorType?: EnumActorTypeFilter<"AppEvent"> | $Enums.ActorType
    eventType?: EnumEventTypeFilter<"AppEvent"> | $Enums.EventType
    entityType?: StringNullableFilter<"AppEvent"> | string | null
    entityId?: StringNullableFilter<"AppEvent"> | string | null
    metadata?: JsonNullableFilter<"AppEvent">
    createdAt?: DateTimeFilter<"AppEvent"> | Date | string
  }

  export type AppEventOrderByWithRelationInput = {
    id?: SortOrder
    userId?: SortOrderInput | SortOrder
    actorType?: SortOrder
    eventType?: SortOrder
    entityType?: SortOrderInput | SortOrder
    entityId?: SortOrderInput | SortOrder
    metadata?: SortOrderInput | SortOrder
    createdAt?: SortOrder
  }

  export type AppEventWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: AppEventWhereInput | AppEventWhereInput[]
    OR?: AppEventWhereInput[]
    NOT?: AppEventWhereInput | AppEventWhereInput[]
    userId?: StringNullableFilter<"AppEvent"> | string | null
    actorType?: EnumActorTypeFilter<"AppEvent"> | $Enums.ActorType
    eventType?: EnumEventTypeFilter<"AppEvent"> | $Enums.EventType
    entityType?: StringNullableFilter<"AppEvent"> | string | null
    entityId?: StringNullableFilter<"AppEvent"> | string | null
    metadata?: JsonNullableFilter<"AppEvent">
    createdAt?: DateTimeFilter<"AppEvent"> | Date | string
  }, "id">

  export type AppEventOrderByWithAggregationInput = {
    id?: SortOrder
    userId?: SortOrderInput | SortOrder
    actorType?: SortOrder
    eventType?: SortOrder
    entityType?: SortOrderInput | SortOrder
    entityId?: SortOrderInput | SortOrder
    metadata?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    _count?: AppEventCountOrderByAggregateInput
    _max?: AppEventMaxOrderByAggregateInput
    _min?: AppEventMinOrderByAggregateInput
  }

  export type AppEventScalarWhereWithAggregatesInput = {
    AND?: AppEventScalarWhereWithAggregatesInput | AppEventScalarWhereWithAggregatesInput[]
    OR?: AppEventScalarWhereWithAggregatesInput[]
    NOT?: AppEventScalarWhereWithAggregatesInput | AppEventScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"AppEvent"> | string
    userId?: StringNullableWithAggregatesFilter<"AppEvent"> | string | null
    actorType?: EnumActorTypeWithAggregatesFilter<"AppEvent"> | $Enums.ActorType
    eventType?: EnumEventTypeWithAggregatesFilter<"AppEvent"> | $Enums.EventType
    entityType?: StringNullableWithAggregatesFilter<"AppEvent"> | string | null
    entityId?: StringNullableWithAggregatesFilter<"AppEvent"> | string | null
    metadata?: JsonNullableWithAggregatesFilter<"AppEvent">
    createdAt?: DateTimeWithAggregatesFilter<"AppEvent"> | Date | string
  }

  export type DailyStatsWhereInput = {
    AND?: DailyStatsWhereInput | DailyStatsWhereInput[]
    OR?: DailyStatsWhereInput[]
    NOT?: DailyStatsWhereInput | DailyStatsWhereInput[]
    id?: StringFilter<"DailyStats"> | string
    date?: DateTimeFilter<"DailyStats"> | Date | string
    totalOrders?: IntFilter<"DailyStats"> | number
    completedOrders?: IntFilter<"DailyStats"> | number
    cancelledOrders?: IntFilter<"DailyStats"> | number
    activeAgents?: IntFilter<"DailyStats"> | number
    avgAssignmentTime?: FloatNullableFilter<"DailyStats"> | number | null
    totalPayout?: FloatFilter<"DailyStats"> | number
    createdAt?: DateTimeFilter<"DailyStats"> | Date | string
    updatedAt?: DateTimeFilter<"DailyStats"> | Date | string
  }

  export type DailyStatsOrderByWithRelationInput = {
    id?: SortOrder
    date?: SortOrder
    totalOrders?: SortOrder
    completedOrders?: SortOrder
    cancelledOrders?: SortOrder
    activeAgents?: SortOrder
    avgAssignmentTime?: SortOrderInput | SortOrder
    totalPayout?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type DailyStatsWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    date?: Date | string
    AND?: DailyStatsWhereInput | DailyStatsWhereInput[]
    OR?: DailyStatsWhereInput[]
    NOT?: DailyStatsWhereInput | DailyStatsWhereInput[]
    totalOrders?: IntFilter<"DailyStats"> | number
    completedOrders?: IntFilter<"DailyStats"> | number
    cancelledOrders?: IntFilter<"DailyStats"> | number
    activeAgents?: IntFilter<"DailyStats"> | number
    avgAssignmentTime?: FloatNullableFilter<"DailyStats"> | number | null
    totalPayout?: FloatFilter<"DailyStats"> | number
    createdAt?: DateTimeFilter<"DailyStats"> | Date | string
    updatedAt?: DateTimeFilter<"DailyStats"> | Date | string
  }, "id" | "date">

  export type DailyStatsOrderByWithAggregationInput = {
    id?: SortOrder
    date?: SortOrder
    totalOrders?: SortOrder
    completedOrders?: SortOrder
    cancelledOrders?: SortOrder
    activeAgents?: SortOrder
    avgAssignmentTime?: SortOrderInput | SortOrder
    totalPayout?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: DailyStatsCountOrderByAggregateInput
    _avg?: DailyStatsAvgOrderByAggregateInput
    _max?: DailyStatsMaxOrderByAggregateInput
    _min?: DailyStatsMinOrderByAggregateInput
    _sum?: DailyStatsSumOrderByAggregateInput
  }

  export type DailyStatsScalarWhereWithAggregatesInput = {
    AND?: DailyStatsScalarWhereWithAggregatesInput | DailyStatsScalarWhereWithAggregatesInput[]
    OR?: DailyStatsScalarWhereWithAggregatesInput[]
    NOT?: DailyStatsScalarWhereWithAggregatesInput | DailyStatsScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"DailyStats"> | string
    date?: DateTimeWithAggregatesFilter<"DailyStats"> | Date | string
    totalOrders?: IntWithAggregatesFilter<"DailyStats"> | number
    completedOrders?: IntWithAggregatesFilter<"DailyStats"> | number
    cancelledOrders?: IntWithAggregatesFilter<"DailyStats"> | number
    activeAgents?: IntWithAggregatesFilter<"DailyStats"> | number
    avgAssignmentTime?: FloatNullableWithAggregatesFilter<"DailyStats"> | number | null
    totalPayout?: FloatWithAggregatesFilter<"DailyStats"> | number
    createdAt?: DateTimeWithAggregatesFilter<"DailyStats"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"DailyStats"> | Date | string
  }

  export type PartnerDailyStatsWhereInput = {
    AND?: PartnerDailyStatsWhereInput | PartnerDailyStatsWhereInput[]
    OR?: PartnerDailyStatsWhereInput[]
    NOT?: PartnerDailyStatsWhereInput | PartnerDailyStatsWhereInput[]
    id?: StringFilter<"PartnerDailyStats"> | string
    partnerId?: StringFilter<"PartnerDailyStats"> | string
    date?: DateTimeFilter<"PartnerDailyStats"> | Date | string
    totalOrders?: IntFilter<"PartnerDailyStats"> | number
    completedOrders?: IntFilter<"PartnerDailyStats"> | number
    cancelledOrders?: IntFilter<"PartnerDailyStats"> | number
    avgAssignmentTime?: FloatNullableFilter<"PartnerDailyStats"> | number | null
    createdAt?: DateTimeFilter<"PartnerDailyStats"> | Date | string
    updatedAt?: DateTimeFilter<"PartnerDailyStats"> | Date | string
    partner?: XOR<PartnerScalarRelationFilter, PartnerWhereInput>
  }

  export type PartnerDailyStatsOrderByWithRelationInput = {
    id?: SortOrder
    partnerId?: SortOrder
    date?: SortOrder
    totalOrders?: SortOrder
    completedOrders?: SortOrder
    cancelledOrders?: SortOrder
    avgAssignmentTime?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    partner?: PartnerOrderByWithRelationInput
  }

  export type PartnerDailyStatsWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    partnerId_date?: PartnerDailyStatsPartnerIdDateCompoundUniqueInput
    AND?: PartnerDailyStatsWhereInput | PartnerDailyStatsWhereInput[]
    OR?: PartnerDailyStatsWhereInput[]
    NOT?: PartnerDailyStatsWhereInput | PartnerDailyStatsWhereInput[]
    partnerId?: StringFilter<"PartnerDailyStats"> | string
    date?: DateTimeFilter<"PartnerDailyStats"> | Date | string
    totalOrders?: IntFilter<"PartnerDailyStats"> | number
    completedOrders?: IntFilter<"PartnerDailyStats"> | number
    cancelledOrders?: IntFilter<"PartnerDailyStats"> | number
    avgAssignmentTime?: FloatNullableFilter<"PartnerDailyStats"> | number | null
    createdAt?: DateTimeFilter<"PartnerDailyStats"> | Date | string
    updatedAt?: DateTimeFilter<"PartnerDailyStats"> | Date | string
    partner?: XOR<PartnerScalarRelationFilter, PartnerWhereInput>
  }, "id" | "partnerId_date">

  export type PartnerDailyStatsOrderByWithAggregationInput = {
    id?: SortOrder
    partnerId?: SortOrder
    date?: SortOrder
    totalOrders?: SortOrder
    completedOrders?: SortOrder
    cancelledOrders?: SortOrder
    avgAssignmentTime?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: PartnerDailyStatsCountOrderByAggregateInput
    _avg?: PartnerDailyStatsAvgOrderByAggregateInput
    _max?: PartnerDailyStatsMaxOrderByAggregateInput
    _min?: PartnerDailyStatsMinOrderByAggregateInput
    _sum?: PartnerDailyStatsSumOrderByAggregateInput
  }

  export type PartnerDailyStatsScalarWhereWithAggregatesInput = {
    AND?: PartnerDailyStatsScalarWhereWithAggregatesInput | PartnerDailyStatsScalarWhereWithAggregatesInput[]
    OR?: PartnerDailyStatsScalarWhereWithAggregatesInput[]
    NOT?: PartnerDailyStatsScalarWhereWithAggregatesInput | PartnerDailyStatsScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"PartnerDailyStats"> | string
    partnerId?: StringWithAggregatesFilter<"PartnerDailyStats"> | string
    date?: DateTimeWithAggregatesFilter<"PartnerDailyStats"> | Date | string
    totalOrders?: IntWithAggregatesFilter<"PartnerDailyStats"> | number
    completedOrders?: IntWithAggregatesFilter<"PartnerDailyStats"> | number
    cancelledOrders?: IntWithAggregatesFilter<"PartnerDailyStats"> | number
    avgAssignmentTime?: FloatNullableWithAggregatesFilter<"PartnerDailyStats"> | number | null
    createdAt?: DateTimeWithAggregatesFilter<"PartnerDailyStats"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"PartnerDailyStats"> | Date | string
  }

  export type PartnerRevenueWhereInput = {
    AND?: PartnerRevenueWhereInput | PartnerRevenueWhereInput[]
    OR?: PartnerRevenueWhereInput[]
    NOT?: PartnerRevenueWhereInput | PartnerRevenueWhereInput[]
    id?: StringFilter<"PartnerRevenue"> | string
    partnerId?: StringFilter<"PartnerRevenue"> | string
    orderId?: StringFilter<"PartnerRevenue"> | string
    orderAmount?: FloatFilter<"PartnerRevenue"> | number
    deliveryFee?: FloatFilter<"PartnerRevenue"> | number
    platformFee?: FloatFilter<"PartnerRevenue"> | number
    netRevenue?: FloatFilter<"PartnerRevenue"> | number
    status?: StringFilter<"PartnerRevenue"> | string
    processedAt?: DateTimeNullableFilter<"PartnerRevenue"> | Date | string | null
    periodStart?: DateTimeFilter<"PartnerRevenue"> | Date | string
    periodEnd?: DateTimeFilter<"PartnerRevenue"> | Date | string
    periodType?: StringFilter<"PartnerRevenue"> | string
    createdAt?: DateTimeFilter<"PartnerRevenue"> | Date | string
    updatedAt?: DateTimeFilter<"PartnerRevenue"> | Date | string
    partner?: XOR<PartnerScalarRelationFilter, PartnerWhereInput>
    order?: XOR<OrderScalarRelationFilter, OrderWhereInput>
  }

  export type PartnerRevenueOrderByWithRelationInput = {
    id?: SortOrder
    partnerId?: SortOrder
    orderId?: SortOrder
    orderAmount?: SortOrder
    deliveryFee?: SortOrder
    platformFee?: SortOrder
    netRevenue?: SortOrder
    status?: SortOrder
    processedAt?: SortOrderInput | SortOrder
    periodStart?: SortOrder
    periodEnd?: SortOrder
    periodType?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    partner?: PartnerOrderByWithRelationInput
    order?: OrderOrderByWithRelationInput
  }

  export type PartnerRevenueWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    orderId?: string
    AND?: PartnerRevenueWhereInput | PartnerRevenueWhereInput[]
    OR?: PartnerRevenueWhereInput[]
    NOT?: PartnerRevenueWhereInput | PartnerRevenueWhereInput[]
    partnerId?: StringFilter<"PartnerRevenue"> | string
    orderAmount?: FloatFilter<"PartnerRevenue"> | number
    deliveryFee?: FloatFilter<"PartnerRevenue"> | number
    platformFee?: FloatFilter<"PartnerRevenue"> | number
    netRevenue?: FloatFilter<"PartnerRevenue"> | number
    status?: StringFilter<"PartnerRevenue"> | string
    processedAt?: DateTimeNullableFilter<"PartnerRevenue"> | Date | string | null
    periodStart?: DateTimeFilter<"PartnerRevenue"> | Date | string
    periodEnd?: DateTimeFilter<"PartnerRevenue"> | Date | string
    periodType?: StringFilter<"PartnerRevenue"> | string
    createdAt?: DateTimeFilter<"PartnerRevenue"> | Date | string
    updatedAt?: DateTimeFilter<"PartnerRevenue"> | Date | string
    partner?: XOR<PartnerScalarRelationFilter, PartnerWhereInput>
    order?: XOR<OrderScalarRelationFilter, OrderWhereInput>
  }, "id" | "orderId">

  export type PartnerRevenueOrderByWithAggregationInput = {
    id?: SortOrder
    partnerId?: SortOrder
    orderId?: SortOrder
    orderAmount?: SortOrder
    deliveryFee?: SortOrder
    platformFee?: SortOrder
    netRevenue?: SortOrder
    status?: SortOrder
    processedAt?: SortOrderInput | SortOrder
    periodStart?: SortOrder
    periodEnd?: SortOrder
    periodType?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: PartnerRevenueCountOrderByAggregateInput
    _avg?: PartnerRevenueAvgOrderByAggregateInput
    _max?: PartnerRevenueMaxOrderByAggregateInput
    _min?: PartnerRevenueMinOrderByAggregateInput
    _sum?: PartnerRevenueSumOrderByAggregateInput
  }

  export type PartnerRevenueScalarWhereWithAggregatesInput = {
    AND?: PartnerRevenueScalarWhereWithAggregatesInput | PartnerRevenueScalarWhereWithAggregatesInput[]
    OR?: PartnerRevenueScalarWhereWithAggregatesInput[]
    NOT?: PartnerRevenueScalarWhereWithAggregatesInput | PartnerRevenueScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"PartnerRevenue"> | string
    partnerId?: StringWithAggregatesFilter<"PartnerRevenue"> | string
    orderId?: StringWithAggregatesFilter<"PartnerRevenue"> | string
    orderAmount?: FloatWithAggregatesFilter<"PartnerRevenue"> | number
    deliveryFee?: FloatWithAggregatesFilter<"PartnerRevenue"> | number
    platformFee?: FloatWithAggregatesFilter<"PartnerRevenue"> | number
    netRevenue?: FloatWithAggregatesFilter<"PartnerRevenue"> | number
    status?: StringWithAggregatesFilter<"PartnerRevenue"> | string
    processedAt?: DateTimeNullableWithAggregatesFilter<"PartnerRevenue"> | Date | string | null
    periodStart?: DateTimeWithAggregatesFilter<"PartnerRevenue"> | Date | string
    periodEnd?: DateTimeWithAggregatesFilter<"PartnerRevenue"> | Date | string
    periodType?: StringWithAggregatesFilter<"PartnerRevenue"> | string
    createdAt?: DateTimeWithAggregatesFilter<"PartnerRevenue"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"PartnerRevenue"> | Date | string
  }

  export type PlatformRevenueWhereInput = {
    AND?: PlatformRevenueWhereInput | PlatformRevenueWhereInput[]
    OR?: PlatformRevenueWhereInput[]
    NOT?: PlatformRevenueWhereInput | PlatformRevenueWhereInput[]
    id?: StringFilter<"PlatformRevenue"> | string
    orderId?: StringFilter<"PlatformRevenue"> | string
    partnerId?: StringFilter<"PlatformRevenue"> | string
    agentId?: StringNullableFilter<"PlatformRevenue"> | string | null
    orderAmount?: FloatFilter<"PlatformRevenue"> | number
    platformFee?: FloatFilter<"PlatformRevenue"> | number
    agentPayout?: FloatFilter<"PlatformRevenue"> | number
    netRevenue?: FloatFilter<"PlatformRevenue"> | number
    revenueType?: StringFilter<"PlatformRevenue"> | string
    status?: StringFilter<"PlatformRevenue"> | string
    processedAt?: DateTimeNullableFilter<"PlatformRevenue"> | Date | string | null
    periodStart?: DateTimeFilter<"PlatformRevenue"> | Date | string
    periodEnd?: DateTimeFilter<"PlatformRevenue"> | Date | string
    periodType?: StringFilter<"PlatformRevenue"> | string
    createdAt?: DateTimeFilter<"PlatformRevenue"> | Date | string
    updatedAt?: DateTimeFilter<"PlatformRevenue"> | Date | string
    order?: XOR<OrderScalarRelationFilter, OrderWhereInput>
    partner?: XOR<PartnerScalarRelationFilter, PartnerWhereInput>
  }

  export type PlatformRevenueOrderByWithRelationInput = {
    id?: SortOrder
    orderId?: SortOrder
    partnerId?: SortOrder
    agentId?: SortOrderInput | SortOrder
    orderAmount?: SortOrder
    platformFee?: SortOrder
    agentPayout?: SortOrder
    netRevenue?: SortOrder
    revenueType?: SortOrder
    status?: SortOrder
    processedAt?: SortOrderInput | SortOrder
    periodStart?: SortOrder
    periodEnd?: SortOrder
    periodType?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    order?: OrderOrderByWithRelationInput
    partner?: PartnerOrderByWithRelationInput
  }

  export type PlatformRevenueWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    orderId?: string
    AND?: PlatformRevenueWhereInput | PlatformRevenueWhereInput[]
    OR?: PlatformRevenueWhereInput[]
    NOT?: PlatformRevenueWhereInput | PlatformRevenueWhereInput[]
    partnerId?: StringFilter<"PlatformRevenue"> | string
    agentId?: StringNullableFilter<"PlatformRevenue"> | string | null
    orderAmount?: FloatFilter<"PlatformRevenue"> | number
    platformFee?: FloatFilter<"PlatformRevenue"> | number
    agentPayout?: FloatFilter<"PlatformRevenue"> | number
    netRevenue?: FloatFilter<"PlatformRevenue"> | number
    revenueType?: StringFilter<"PlatformRevenue"> | string
    status?: StringFilter<"PlatformRevenue"> | string
    processedAt?: DateTimeNullableFilter<"PlatformRevenue"> | Date | string | null
    periodStart?: DateTimeFilter<"PlatformRevenue"> | Date | string
    periodEnd?: DateTimeFilter<"PlatformRevenue"> | Date | string
    periodType?: StringFilter<"PlatformRevenue"> | string
    createdAt?: DateTimeFilter<"PlatformRevenue"> | Date | string
    updatedAt?: DateTimeFilter<"PlatformRevenue"> | Date | string
    order?: XOR<OrderScalarRelationFilter, OrderWhereInput>
    partner?: XOR<PartnerScalarRelationFilter, PartnerWhereInput>
  }, "id" | "orderId">

  export type PlatformRevenueOrderByWithAggregationInput = {
    id?: SortOrder
    orderId?: SortOrder
    partnerId?: SortOrder
    agentId?: SortOrderInput | SortOrder
    orderAmount?: SortOrder
    platformFee?: SortOrder
    agentPayout?: SortOrder
    netRevenue?: SortOrder
    revenueType?: SortOrder
    status?: SortOrder
    processedAt?: SortOrderInput | SortOrder
    periodStart?: SortOrder
    periodEnd?: SortOrder
    periodType?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: PlatformRevenueCountOrderByAggregateInput
    _avg?: PlatformRevenueAvgOrderByAggregateInput
    _max?: PlatformRevenueMaxOrderByAggregateInput
    _min?: PlatformRevenueMinOrderByAggregateInput
    _sum?: PlatformRevenueSumOrderByAggregateInput
  }

  export type PlatformRevenueScalarWhereWithAggregatesInput = {
    AND?: PlatformRevenueScalarWhereWithAggregatesInput | PlatformRevenueScalarWhereWithAggregatesInput[]
    OR?: PlatformRevenueScalarWhereWithAggregatesInput[]
    NOT?: PlatformRevenueScalarWhereWithAggregatesInput | PlatformRevenueScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"PlatformRevenue"> | string
    orderId?: StringWithAggregatesFilter<"PlatformRevenue"> | string
    partnerId?: StringWithAggregatesFilter<"PlatformRevenue"> | string
    agentId?: StringNullableWithAggregatesFilter<"PlatformRevenue"> | string | null
    orderAmount?: FloatWithAggregatesFilter<"PlatformRevenue"> | number
    platformFee?: FloatWithAggregatesFilter<"PlatformRevenue"> | number
    agentPayout?: FloatWithAggregatesFilter<"PlatformRevenue"> | number
    netRevenue?: FloatWithAggregatesFilter<"PlatformRevenue"> | number
    revenueType?: StringWithAggregatesFilter<"PlatformRevenue"> | string
    status?: StringWithAggregatesFilter<"PlatformRevenue"> | string
    processedAt?: DateTimeNullableWithAggregatesFilter<"PlatformRevenue"> | Date | string | null
    periodStart?: DateTimeWithAggregatesFilter<"PlatformRevenue"> | Date | string
    periodEnd?: DateTimeWithAggregatesFilter<"PlatformRevenue"> | Date | string
    periodType?: StringWithAggregatesFilter<"PlatformRevenue"> | string
    createdAt?: DateTimeWithAggregatesFilter<"PlatformRevenue"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"PlatformRevenue"> | Date | string
  }

  export type AdminWalletWhereInput = {
    AND?: AdminWalletWhereInput | AdminWalletWhereInput[]
    OR?: AdminWalletWhereInput[]
    NOT?: AdminWalletWhereInput | AdminWalletWhereInput[]
    id?: StringFilter<"AdminWallet"> | string
    balance?: FloatFilter<"AdminWallet"> | number
    totalDeposited?: FloatFilter<"AdminWallet"> | number
    totalPaidOut?: FloatFilter<"AdminWallet"> | number
    lastUpdated?: DateTimeFilter<"AdminWallet"> | Date | string
    createdAt?: DateTimeFilter<"AdminWallet"> | Date | string
    transactions?: WalletTransactionListRelationFilter
  }

  export type AdminWalletOrderByWithRelationInput = {
    id?: SortOrder
    balance?: SortOrder
    totalDeposited?: SortOrder
    totalPaidOut?: SortOrder
    lastUpdated?: SortOrder
    createdAt?: SortOrder
    transactions?: WalletTransactionOrderByRelationAggregateInput
  }

  export type AdminWalletWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: AdminWalletWhereInput | AdminWalletWhereInput[]
    OR?: AdminWalletWhereInput[]
    NOT?: AdminWalletWhereInput | AdminWalletWhereInput[]
    balance?: FloatFilter<"AdminWallet"> | number
    totalDeposited?: FloatFilter<"AdminWallet"> | number
    totalPaidOut?: FloatFilter<"AdminWallet"> | number
    lastUpdated?: DateTimeFilter<"AdminWallet"> | Date | string
    createdAt?: DateTimeFilter<"AdminWallet"> | Date | string
    transactions?: WalletTransactionListRelationFilter
  }, "id">

  export type AdminWalletOrderByWithAggregationInput = {
    id?: SortOrder
    balance?: SortOrder
    totalDeposited?: SortOrder
    totalPaidOut?: SortOrder
    lastUpdated?: SortOrder
    createdAt?: SortOrder
    _count?: AdminWalletCountOrderByAggregateInput
    _avg?: AdminWalletAvgOrderByAggregateInput
    _max?: AdminWalletMaxOrderByAggregateInput
    _min?: AdminWalletMinOrderByAggregateInput
    _sum?: AdminWalletSumOrderByAggregateInput
  }

  export type AdminWalletScalarWhereWithAggregatesInput = {
    AND?: AdminWalletScalarWhereWithAggregatesInput | AdminWalletScalarWhereWithAggregatesInput[]
    OR?: AdminWalletScalarWhereWithAggregatesInput[]
    NOT?: AdminWalletScalarWhereWithAggregatesInput | AdminWalletScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"AdminWallet"> | string
    balance?: FloatWithAggregatesFilter<"AdminWallet"> | number
    totalDeposited?: FloatWithAggregatesFilter<"AdminWallet"> | number
    totalPaidOut?: FloatWithAggregatesFilter<"AdminWallet"> | number
    lastUpdated?: DateTimeWithAggregatesFilter<"AdminWallet"> | Date | string
    createdAt?: DateTimeWithAggregatesFilter<"AdminWallet"> | Date | string
  }

  export type AgentWalletWhereInput = {
    AND?: AgentWalletWhereInput | AgentWalletWhereInput[]
    OR?: AgentWalletWhereInput[]
    NOT?: AgentWalletWhereInput | AgentWalletWhereInput[]
    id?: StringFilter<"AgentWallet"> | string
    agentId?: StringFilter<"AgentWallet"> | string
    balance?: FloatFilter<"AgentWallet"> | number
    totalEarned?: FloatFilter<"AgentWallet"> | number
    totalPaidOut?: FloatFilter<"AgentWallet"> | number
    lastPayoutDate?: DateTimeNullableFilter<"AgentWallet"> | Date | string | null
    nextPayoutDate?: DateTimeNullableFilter<"AgentWallet"> | Date | string | null
    createdAt?: DateTimeFilter<"AgentWallet"> | Date | string
    updatedAt?: DateTimeFilter<"AgentWallet"> | Date | string
    agent?: XOR<AgentScalarRelationFilter, AgentWhereInput>
    transactions?: WalletTransactionListRelationFilter
    payouts?: WalletPayoutListRelationFilter
  }

  export type AgentWalletOrderByWithRelationInput = {
    id?: SortOrder
    agentId?: SortOrder
    balance?: SortOrder
    totalEarned?: SortOrder
    totalPaidOut?: SortOrder
    lastPayoutDate?: SortOrderInput | SortOrder
    nextPayoutDate?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    agent?: AgentOrderByWithRelationInput
    transactions?: WalletTransactionOrderByRelationAggregateInput
    payouts?: WalletPayoutOrderByRelationAggregateInput
  }

  export type AgentWalletWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    agentId?: string
    AND?: AgentWalletWhereInput | AgentWalletWhereInput[]
    OR?: AgentWalletWhereInput[]
    NOT?: AgentWalletWhereInput | AgentWalletWhereInput[]
    balance?: FloatFilter<"AgentWallet"> | number
    totalEarned?: FloatFilter<"AgentWallet"> | number
    totalPaidOut?: FloatFilter<"AgentWallet"> | number
    lastPayoutDate?: DateTimeNullableFilter<"AgentWallet"> | Date | string | null
    nextPayoutDate?: DateTimeNullableFilter<"AgentWallet"> | Date | string | null
    createdAt?: DateTimeFilter<"AgentWallet"> | Date | string
    updatedAt?: DateTimeFilter<"AgentWallet"> | Date | string
    agent?: XOR<AgentScalarRelationFilter, AgentWhereInput>
    transactions?: WalletTransactionListRelationFilter
    payouts?: WalletPayoutListRelationFilter
  }, "id" | "agentId">

  export type AgentWalletOrderByWithAggregationInput = {
    id?: SortOrder
    agentId?: SortOrder
    balance?: SortOrder
    totalEarned?: SortOrder
    totalPaidOut?: SortOrder
    lastPayoutDate?: SortOrderInput | SortOrder
    nextPayoutDate?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: AgentWalletCountOrderByAggregateInput
    _avg?: AgentWalletAvgOrderByAggregateInput
    _max?: AgentWalletMaxOrderByAggregateInput
    _min?: AgentWalletMinOrderByAggregateInput
    _sum?: AgentWalletSumOrderByAggregateInput
  }

  export type AgentWalletScalarWhereWithAggregatesInput = {
    AND?: AgentWalletScalarWhereWithAggregatesInput | AgentWalletScalarWhereWithAggregatesInput[]
    OR?: AgentWalletScalarWhereWithAggregatesInput[]
    NOT?: AgentWalletScalarWhereWithAggregatesInput | AgentWalletScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"AgentWallet"> | string
    agentId?: StringWithAggregatesFilter<"AgentWallet"> | string
    balance?: FloatWithAggregatesFilter<"AgentWallet"> | number
    totalEarned?: FloatWithAggregatesFilter<"AgentWallet"> | number
    totalPaidOut?: FloatWithAggregatesFilter<"AgentWallet"> | number
    lastPayoutDate?: DateTimeNullableWithAggregatesFilter<"AgentWallet"> | Date | string | null
    nextPayoutDate?: DateTimeNullableWithAggregatesFilter<"AgentWallet"> | Date | string | null
    createdAt?: DateTimeWithAggregatesFilter<"AgentWallet"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"AgentWallet"> | Date | string
  }

  export type WalletTransactionWhereInput = {
    AND?: WalletTransactionWhereInput | WalletTransactionWhereInput[]
    OR?: WalletTransactionWhereInput[]
    NOT?: WalletTransactionWhereInput | WalletTransactionWhereInput[]
    id?: StringFilter<"WalletTransaction"> | string
    walletType?: StringFilter<"WalletTransaction"> | string
    adminWalletId?: StringNullableFilter<"WalletTransaction"> | string | null
    agentWalletId?: StringNullableFilter<"WalletTransaction"> | string | null
    orderId?: StringNullableFilter<"WalletTransaction"> | string | null
    amount?: FloatFilter<"WalletTransaction"> | number
    type?: StringFilter<"WalletTransaction"> | string
    description?: StringNullableFilter<"WalletTransaction"> | string | null
    balanceBefore?: FloatFilter<"WalletTransaction"> | number
    balanceAfter?: FloatFilter<"WalletTransaction"> | number
    status?: StringFilter<"WalletTransaction"> | string
    createdAt?: DateTimeFilter<"WalletTransaction"> | Date | string
    adminWallet?: XOR<AdminWalletNullableScalarRelationFilter, AdminWalletWhereInput> | null
    agentWallet?: XOR<AgentWalletNullableScalarRelationFilter, AgentWalletWhereInput> | null
    order?: XOR<OrderNullableScalarRelationFilter, OrderWhereInput> | null
  }

  export type WalletTransactionOrderByWithRelationInput = {
    id?: SortOrder
    walletType?: SortOrder
    adminWalletId?: SortOrderInput | SortOrder
    agentWalletId?: SortOrderInput | SortOrder
    orderId?: SortOrderInput | SortOrder
    amount?: SortOrder
    type?: SortOrder
    description?: SortOrderInput | SortOrder
    balanceBefore?: SortOrder
    balanceAfter?: SortOrder
    status?: SortOrder
    createdAt?: SortOrder
    adminWallet?: AdminWalletOrderByWithRelationInput
    agentWallet?: AgentWalletOrderByWithRelationInput
    order?: OrderOrderByWithRelationInput
  }

  export type WalletTransactionWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: WalletTransactionWhereInput | WalletTransactionWhereInput[]
    OR?: WalletTransactionWhereInput[]
    NOT?: WalletTransactionWhereInput | WalletTransactionWhereInput[]
    walletType?: StringFilter<"WalletTransaction"> | string
    adminWalletId?: StringNullableFilter<"WalletTransaction"> | string | null
    agentWalletId?: StringNullableFilter<"WalletTransaction"> | string | null
    orderId?: StringNullableFilter<"WalletTransaction"> | string | null
    amount?: FloatFilter<"WalletTransaction"> | number
    type?: StringFilter<"WalletTransaction"> | string
    description?: StringNullableFilter<"WalletTransaction"> | string | null
    balanceBefore?: FloatFilter<"WalletTransaction"> | number
    balanceAfter?: FloatFilter<"WalletTransaction"> | number
    status?: StringFilter<"WalletTransaction"> | string
    createdAt?: DateTimeFilter<"WalletTransaction"> | Date | string
    adminWallet?: XOR<AdminWalletNullableScalarRelationFilter, AdminWalletWhereInput> | null
    agentWallet?: XOR<AgentWalletNullableScalarRelationFilter, AgentWalletWhereInput> | null
    order?: XOR<OrderNullableScalarRelationFilter, OrderWhereInput> | null
  }, "id">

  export type WalletTransactionOrderByWithAggregationInput = {
    id?: SortOrder
    walletType?: SortOrder
    adminWalletId?: SortOrderInput | SortOrder
    agentWalletId?: SortOrderInput | SortOrder
    orderId?: SortOrderInput | SortOrder
    amount?: SortOrder
    type?: SortOrder
    description?: SortOrderInput | SortOrder
    balanceBefore?: SortOrder
    balanceAfter?: SortOrder
    status?: SortOrder
    createdAt?: SortOrder
    _count?: WalletTransactionCountOrderByAggregateInput
    _avg?: WalletTransactionAvgOrderByAggregateInput
    _max?: WalletTransactionMaxOrderByAggregateInput
    _min?: WalletTransactionMinOrderByAggregateInput
    _sum?: WalletTransactionSumOrderByAggregateInput
  }

  export type WalletTransactionScalarWhereWithAggregatesInput = {
    AND?: WalletTransactionScalarWhereWithAggregatesInput | WalletTransactionScalarWhereWithAggregatesInput[]
    OR?: WalletTransactionScalarWhereWithAggregatesInput[]
    NOT?: WalletTransactionScalarWhereWithAggregatesInput | WalletTransactionScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"WalletTransaction"> | string
    walletType?: StringWithAggregatesFilter<"WalletTransaction"> | string
    adminWalletId?: StringNullableWithAggregatesFilter<"WalletTransaction"> | string | null
    agentWalletId?: StringNullableWithAggregatesFilter<"WalletTransaction"> | string | null
    orderId?: StringNullableWithAggregatesFilter<"WalletTransaction"> | string | null
    amount?: FloatWithAggregatesFilter<"WalletTransaction"> | number
    type?: StringWithAggregatesFilter<"WalletTransaction"> | string
    description?: StringNullableWithAggregatesFilter<"WalletTransaction"> | string | null
    balanceBefore?: FloatWithAggregatesFilter<"WalletTransaction"> | number
    balanceAfter?: FloatWithAggregatesFilter<"WalletTransaction"> | number
    status?: StringWithAggregatesFilter<"WalletTransaction"> | string
    createdAt?: DateTimeWithAggregatesFilter<"WalletTransaction"> | Date | string
  }

  export type WalletPayoutWhereInput = {
    AND?: WalletPayoutWhereInput | WalletPayoutWhereInput[]
    OR?: WalletPayoutWhereInput[]
    NOT?: WalletPayoutWhereInput | WalletPayoutWhereInput[]
    id?: StringFilter<"WalletPayout"> | string
    agentWalletId?: StringFilter<"WalletPayout"> | string
    agentId?: StringFilter<"WalletPayout"> | string
    amount?: FloatFilter<"WalletPayout"> | number
    periodStart?: DateTimeFilter<"WalletPayout"> | Date | string
    periodEnd?: DateTimeFilter<"WalletPayout"> | Date | string
    status?: StringFilter<"WalletPayout"> | string
    paymentMethod?: StringNullableFilter<"WalletPayout"> | string | null
    transactionId?: StringNullableFilter<"WalletPayout"> | string | null
    bankAccount?: StringNullableFilter<"WalletPayout"> | string | null
    upiId?: StringNullableFilter<"WalletPayout"> | string | null
    processedAt?: DateTimeNullableFilter<"WalletPayout"> | Date | string | null
    failedAt?: DateTimeNullableFilter<"WalletPayout"> | Date | string | null
    failureReason?: StringNullableFilter<"WalletPayout"> | string | null
    notes?: StringNullableFilter<"WalletPayout"> | string | null
    createdAt?: DateTimeFilter<"WalletPayout"> | Date | string
    updatedAt?: DateTimeFilter<"WalletPayout"> | Date | string
    agentWallet?: XOR<AgentWalletScalarRelationFilter, AgentWalletWhereInput>
    agent?: XOR<AgentScalarRelationFilter, AgentWhereInput>
  }

  export type WalletPayoutOrderByWithRelationInput = {
    id?: SortOrder
    agentWalletId?: SortOrder
    agentId?: SortOrder
    amount?: SortOrder
    periodStart?: SortOrder
    periodEnd?: SortOrder
    status?: SortOrder
    paymentMethod?: SortOrderInput | SortOrder
    transactionId?: SortOrderInput | SortOrder
    bankAccount?: SortOrderInput | SortOrder
    upiId?: SortOrderInput | SortOrder
    processedAt?: SortOrderInput | SortOrder
    failedAt?: SortOrderInput | SortOrder
    failureReason?: SortOrderInput | SortOrder
    notes?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    agentWallet?: AgentWalletOrderByWithRelationInput
    agent?: AgentOrderByWithRelationInput
  }

  export type WalletPayoutWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    agentId_periodStart_periodEnd?: WalletPayoutAgentIdPeriodStartPeriodEndCompoundUniqueInput
    AND?: WalletPayoutWhereInput | WalletPayoutWhereInput[]
    OR?: WalletPayoutWhereInput[]
    NOT?: WalletPayoutWhereInput | WalletPayoutWhereInput[]
    agentWalletId?: StringFilter<"WalletPayout"> | string
    agentId?: StringFilter<"WalletPayout"> | string
    amount?: FloatFilter<"WalletPayout"> | number
    periodStart?: DateTimeFilter<"WalletPayout"> | Date | string
    periodEnd?: DateTimeFilter<"WalletPayout"> | Date | string
    status?: StringFilter<"WalletPayout"> | string
    paymentMethod?: StringNullableFilter<"WalletPayout"> | string | null
    transactionId?: StringNullableFilter<"WalletPayout"> | string | null
    bankAccount?: StringNullableFilter<"WalletPayout"> | string | null
    upiId?: StringNullableFilter<"WalletPayout"> | string | null
    processedAt?: DateTimeNullableFilter<"WalletPayout"> | Date | string | null
    failedAt?: DateTimeNullableFilter<"WalletPayout"> | Date | string | null
    failureReason?: StringNullableFilter<"WalletPayout"> | string | null
    notes?: StringNullableFilter<"WalletPayout"> | string | null
    createdAt?: DateTimeFilter<"WalletPayout"> | Date | string
    updatedAt?: DateTimeFilter<"WalletPayout"> | Date | string
    agentWallet?: XOR<AgentWalletScalarRelationFilter, AgentWalletWhereInput>
    agent?: XOR<AgentScalarRelationFilter, AgentWhereInput>
  }, "id" | "agentId_periodStart_periodEnd">

  export type WalletPayoutOrderByWithAggregationInput = {
    id?: SortOrder
    agentWalletId?: SortOrder
    agentId?: SortOrder
    amount?: SortOrder
    periodStart?: SortOrder
    periodEnd?: SortOrder
    status?: SortOrder
    paymentMethod?: SortOrderInput | SortOrder
    transactionId?: SortOrderInput | SortOrder
    bankAccount?: SortOrderInput | SortOrder
    upiId?: SortOrderInput | SortOrder
    processedAt?: SortOrderInput | SortOrder
    failedAt?: SortOrderInput | SortOrder
    failureReason?: SortOrderInput | SortOrder
    notes?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: WalletPayoutCountOrderByAggregateInput
    _avg?: WalletPayoutAvgOrderByAggregateInput
    _max?: WalletPayoutMaxOrderByAggregateInput
    _min?: WalletPayoutMinOrderByAggregateInput
    _sum?: WalletPayoutSumOrderByAggregateInput
  }

  export type WalletPayoutScalarWhereWithAggregatesInput = {
    AND?: WalletPayoutScalarWhereWithAggregatesInput | WalletPayoutScalarWhereWithAggregatesInput[]
    OR?: WalletPayoutScalarWhereWithAggregatesInput[]
    NOT?: WalletPayoutScalarWhereWithAggregatesInput | WalletPayoutScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"WalletPayout"> | string
    agentWalletId?: StringWithAggregatesFilter<"WalletPayout"> | string
    agentId?: StringWithAggregatesFilter<"WalletPayout"> | string
    amount?: FloatWithAggregatesFilter<"WalletPayout"> | number
    periodStart?: DateTimeWithAggregatesFilter<"WalletPayout"> | Date | string
    periodEnd?: DateTimeWithAggregatesFilter<"WalletPayout"> | Date | string
    status?: StringWithAggregatesFilter<"WalletPayout"> | string
    paymentMethod?: StringNullableWithAggregatesFilter<"WalletPayout"> | string | null
    transactionId?: StringNullableWithAggregatesFilter<"WalletPayout"> | string | null
    bankAccount?: StringNullableWithAggregatesFilter<"WalletPayout"> | string | null
    upiId?: StringNullableWithAggregatesFilter<"WalletPayout"> | string | null
    processedAt?: DateTimeNullableWithAggregatesFilter<"WalletPayout"> | Date | string | null
    failedAt?: DateTimeNullableWithAggregatesFilter<"WalletPayout"> | Date | string | null
    failureReason?: StringNullableWithAggregatesFilter<"WalletPayout"> | string | null
    notes?: StringNullableWithAggregatesFilter<"WalletPayout"> | string | null
    createdAt?: DateTimeWithAggregatesFilter<"WalletPayout"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"WalletPayout"> | Date | string
  }

  export type NotificationWhereInput = {
    AND?: NotificationWhereInput | NotificationWhereInput[]
    OR?: NotificationWhereInput[]
    NOT?: NotificationWhereInput | NotificationWhereInput[]
    id?: StringFilter<"Notification"> | string
    userId?: StringFilter<"Notification"> | string
    title?: StringFilter<"Notification"> | string
    message?: StringFilter<"Notification"> | string
    type?: StringFilter<"Notification"> | string
    isRead?: BoolFilter<"Notification"> | boolean
    link?: StringNullableFilter<"Notification"> | string | null
    metadata?: JsonNullableFilter<"Notification">
    createdAt?: DateTimeFilter<"Notification"> | Date | string
    readAt?: DateTimeNullableFilter<"Notification"> | Date | string | null
    user?: XOR<UserScalarRelationFilter, UserWhereInput>
  }

  export type NotificationOrderByWithRelationInput = {
    id?: SortOrder
    userId?: SortOrder
    title?: SortOrder
    message?: SortOrder
    type?: SortOrder
    isRead?: SortOrder
    link?: SortOrderInput | SortOrder
    metadata?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    readAt?: SortOrderInput | SortOrder
    user?: UserOrderByWithRelationInput
  }

  export type NotificationWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: NotificationWhereInput | NotificationWhereInput[]
    OR?: NotificationWhereInput[]
    NOT?: NotificationWhereInput | NotificationWhereInput[]
    userId?: StringFilter<"Notification"> | string
    title?: StringFilter<"Notification"> | string
    message?: StringFilter<"Notification"> | string
    type?: StringFilter<"Notification"> | string
    isRead?: BoolFilter<"Notification"> | boolean
    link?: StringNullableFilter<"Notification"> | string | null
    metadata?: JsonNullableFilter<"Notification">
    createdAt?: DateTimeFilter<"Notification"> | Date | string
    readAt?: DateTimeNullableFilter<"Notification"> | Date | string | null
    user?: XOR<UserScalarRelationFilter, UserWhereInput>
  }, "id">

  export type NotificationOrderByWithAggregationInput = {
    id?: SortOrder
    userId?: SortOrder
    title?: SortOrder
    message?: SortOrder
    type?: SortOrder
    isRead?: SortOrder
    link?: SortOrderInput | SortOrder
    metadata?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    readAt?: SortOrderInput | SortOrder
    _count?: NotificationCountOrderByAggregateInput
    _max?: NotificationMaxOrderByAggregateInput
    _min?: NotificationMinOrderByAggregateInput
  }

  export type NotificationScalarWhereWithAggregatesInput = {
    AND?: NotificationScalarWhereWithAggregatesInput | NotificationScalarWhereWithAggregatesInput[]
    OR?: NotificationScalarWhereWithAggregatesInput[]
    NOT?: NotificationScalarWhereWithAggregatesInput | NotificationScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Notification"> | string
    userId?: StringWithAggregatesFilter<"Notification"> | string
    title?: StringWithAggregatesFilter<"Notification"> | string
    message?: StringWithAggregatesFilter<"Notification"> | string
    type?: StringWithAggregatesFilter<"Notification"> | string
    isRead?: BoolWithAggregatesFilter<"Notification"> | boolean
    link?: StringNullableWithAggregatesFilter<"Notification"> | string | null
    metadata?: JsonNullableWithAggregatesFilter<"Notification">
    createdAt?: DateTimeWithAggregatesFilter<"Notification"> | Date | string
    readAt?: DateTimeNullableWithAggregatesFilter<"Notification"> | Date | string | null
  }

  export type AgentRatingWhereInput = {
    AND?: AgentRatingWhereInput | AgentRatingWhereInput[]
    OR?: AgentRatingWhereInput[]
    NOT?: AgentRatingWhereInput | AgentRatingWhereInput[]
    id?: StringFilter<"AgentRating"> | string
    orderId?: StringFilter<"AgentRating"> | string
    agentId?: StringFilter<"AgentRating"> | string
    partnerId?: StringFilter<"AgentRating"> | string
    rating?: IntFilter<"AgentRating"> | number
    comment?: StringNullableFilter<"AgentRating"> | string | null
    createdAt?: DateTimeFilter<"AgentRating"> | Date | string
    updatedAt?: DateTimeFilter<"AgentRating"> | Date | string
    order?: XOR<OrderScalarRelationFilter, OrderWhereInput>
    agent?: XOR<AgentScalarRelationFilter, AgentWhereInput>
    partner?: XOR<PartnerScalarRelationFilter, PartnerWhereInput>
  }

  export type AgentRatingOrderByWithRelationInput = {
    id?: SortOrder
    orderId?: SortOrder
    agentId?: SortOrder
    partnerId?: SortOrder
    rating?: SortOrder
    comment?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    order?: OrderOrderByWithRelationInput
    agent?: AgentOrderByWithRelationInput
    partner?: PartnerOrderByWithRelationInput
  }

  export type AgentRatingWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    orderId?: string
    AND?: AgentRatingWhereInput | AgentRatingWhereInput[]
    OR?: AgentRatingWhereInput[]
    NOT?: AgentRatingWhereInput | AgentRatingWhereInput[]
    agentId?: StringFilter<"AgentRating"> | string
    partnerId?: StringFilter<"AgentRating"> | string
    rating?: IntFilter<"AgentRating"> | number
    comment?: StringNullableFilter<"AgentRating"> | string | null
    createdAt?: DateTimeFilter<"AgentRating"> | Date | string
    updatedAt?: DateTimeFilter<"AgentRating"> | Date | string
    order?: XOR<OrderScalarRelationFilter, OrderWhereInput>
    agent?: XOR<AgentScalarRelationFilter, AgentWhereInput>
    partner?: XOR<PartnerScalarRelationFilter, PartnerWhereInput>
  }, "id" | "orderId">

  export type AgentRatingOrderByWithAggregationInput = {
    id?: SortOrder
    orderId?: SortOrder
    agentId?: SortOrder
    partnerId?: SortOrder
    rating?: SortOrder
    comment?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: AgentRatingCountOrderByAggregateInput
    _avg?: AgentRatingAvgOrderByAggregateInput
    _max?: AgentRatingMaxOrderByAggregateInput
    _min?: AgentRatingMinOrderByAggregateInput
    _sum?: AgentRatingSumOrderByAggregateInput
  }

  export type AgentRatingScalarWhereWithAggregatesInput = {
    AND?: AgentRatingScalarWhereWithAggregatesInput | AgentRatingScalarWhereWithAggregatesInput[]
    OR?: AgentRatingScalarWhereWithAggregatesInput[]
    NOT?: AgentRatingScalarWhereWithAggregatesInput | AgentRatingScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"AgentRating"> | string
    orderId?: StringWithAggregatesFilter<"AgentRating"> | string
    agentId?: StringWithAggregatesFilter<"AgentRating"> | string
    partnerId?: StringWithAggregatesFilter<"AgentRating"> | string
    rating?: IntWithAggregatesFilter<"AgentRating"> | number
    comment?: StringNullableWithAggregatesFilter<"AgentRating"> | string | null
    createdAt?: DateTimeWithAggregatesFilter<"AgentRating"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"AgentRating"> | Date | string
  }

  export type PaymentWhereInput = {
    AND?: PaymentWhereInput | PaymentWhereInput[]
    OR?: PaymentWhereInput[]
    NOT?: PaymentWhereInput | PaymentWhereInput[]
    id?: StringFilter<"Payment"> | string
    agentId?: StringFilter<"Payment"> | string
    orderId?: StringFilter<"Payment"> | string
    amount?: FloatFilter<"Payment"> | number
    paymentType?: StringFilter<"Payment"> | string
    status?: StringFilter<"Payment"> | string
    processedAt?: DateTimeNullableFilter<"Payment"> | Date | string | null
    paymentMethod?: StringNullableFilter<"Payment"> | string | null
    transactionId?: StringNullableFilter<"Payment"> | string | null
    notes?: StringNullableFilter<"Payment"> | string | null
    createdAt?: DateTimeFilter<"Payment"> | Date | string
    updatedAt?: DateTimeFilter<"Payment"> | Date | string
    agent?: XOR<AgentScalarRelationFilter, AgentWhereInput>
    order?: XOR<OrderScalarRelationFilter, OrderWhereInput>
  }

  export type PaymentOrderByWithRelationInput = {
    id?: SortOrder
    agentId?: SortOrder
    orderId?: SortOrder
    amount?: SortOrder
    paymentType?: SortOrder
    status?: SortOrder
    processedAt?: SortOrderInput | SortOrder
    paymentMethod?: SortOrderInput | SortOrder
    transactionId?: SortOrderInput | SortOrder
    notes?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    agent?: AgentOrderByWithRelationInput
    order?: OrderOrderByWithRelationInput
  }

  export type PaymentWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: PaymentWhereInput | PaymentWhereInput[]
    OR?: PaymentWhereInput[]
    NOT?: PaymentWhereInput | PaymentWhereInput[]
    agentId?: StringFilter<"Payment"> | string
    orderId?: StringFilter<"Payment"> | string
    amount?: FloatFilter<"Payment"> | number
    paymentType?: StringFilter<"Payment"> | string
    status?: StringFilter<"Payment"> | string
    processedAt?: DateTimeNullableFilter<"Payment"> | Date | string | null
    paymentMethod?: StringNullableFilter<"Payment"> | string | null
    transactionId?: StringNullableFilter<"Payment"> | string | null
    notes?: StringNullableFilter<"Payment"> | string | null
    createdAt?: DateTimeFilter<"Payment"> | Date | string
    updatedAt?: DateTimeFilter<"Payment"> | Date | string
    agent?: XOR<AgentScalarRelationFilter, AgentWhereInput>
    order?: XOR<OrderScalarRelationFilter, OrderWhereInput>
  }, "id">

  export type PaymentOrderByWithAggregationInput = {
    id?: SortOrder
    agentId?: SortOrder
    orderId?: SortOrder
    amount?: SortOrder
    paymentType?: SortOrder
    status?: SortOrder
    processedAt?: SortOrderInput | SortOrder
    paymentMethod?: SortOrderInput | SortOrder
    transactionId?: SortOrderInput | SortOrder
    notes?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: PaymentCountOrderByAggregateInput
    _avg?: PaymentAvgOrderByAggregateInput
    _max?: PaymentMaxOrderByAggregateInput
    _min?: PaymentMinOrderByAggregateInput
    _sum?: PaymentSumOrderByAggregateInput
  }

  export type PaymentScalarWhereWithAggregatesInput = {
    AND?: PaymentScalarWhereWithAggregatesInput | PaymentScalarWhereWithAggregatesInput[]
    OR?: PaymentScalarWhereWithAggregatesInput[]
    NOT?: PaymentScalarWhereWithAggregatesInput | PaymentScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Payment"> | string
    agentId?: StringWithAggregatesFilter<"Payment"> | string
    orderId?: StringWithAggregatesFilter<"Payment"> | string
    amount?: FloatWithAggregatesFilter<"Payment"> | number
    paymentType?: StringWithAggregatesFilter<"Payment"> | string
    status?: StringWithAggregatesFilter<"Payment"> | string
    processedAt?: DateTimeNullableWithAggregatesFilter<"Payment"> | Date | string | null
    paymentMethod?: StringNullableWithAggregatesFilter<"Payment"> | string | null
    transactionId?: StringNullableWithAggregatesFilter<"Payment"> | string | null
    notes?: StringNullableWithAggregatesFilter<"Payment"> | string | null
    createdAt?: DateTimeWithAggregatesFilter<"Payment"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"Payment"> | Date | string
  }

  export type PayrollWhereInput = {
    AND?: PayrollWhereInput | PayrollWhereInput[]
    OR?: PayrollWhereInput[]
    NOT?: PayrollWhereInput | PayrollWhereInput[]
    id?: StringFilter<"Payroll"> | string
    agentId?: StringFilter<"Payroll"> | string
    periodStart?: DateTimeFilter<"Payroll"> | Date | string
    periodEnd?: DateTimeFilter<"Payroll"> | Date | string
    periodType?: StringFilter<"Payroll"> | string
    totalEarnings?: FloatFilter<"Payroll"> | number
    totalOrders?: IntFilter<"Payroll"> | number
    basePay?: FloatFilter<"Payroll"> | number
    bonuses?: FloatFilter<"Payroll"> | number
    deductions?: FloatFilter<"Payroll"> | number
    netPay?: FloatFilter<"Payroll"> | number
    status?: StringFilter<"Payroll"> | string
    processedAt?: DateTimeNullableFilter<"Payroll"> | Date | string | null
    paidAt?: DateTimeNullableFilter<"Payroll"> | Date | string | null
    paymentMethod?: StringNullableFilter<"Payroll"> | string | null
    transactionId?: StringNullableFilter<"Payroll"> | string | null
    notes?: StringNullableFilter<"Payroll"> | string | null
    createdAt?: DateTimeFilter<"Payroll"> | Date | string
    updatedAt?: DateTimeFilter<"Payroll"> | Date | string
    agent?: XOR<AgentScalarRelationFilter, AgentWhereInput>
  }

  export type PayrollOrderByWithRelationInput = {
    id?: SortOrder
    agentId?: SortOrder
    periodStart?: SortOrder
    periodEnd?: SortOrder
    periodType?: SortOrder
    totalEarnings?: SortOrder
    totalOrders?: SortOrder
    basePay?: SortOrder
    bonuses?: SortOrder
    deductions?: SortOrder
    netPay?: SortOrder
    status?: SortOrder
    processedAt?: SortOrderInput | SortOrder
    paidAt?: SortOrderInput | SortOrder
    paymentMethod?: SortOrderInput | SortOrder
    transactionId?: SortOrderInput | SortOrder
    notes?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    agent?: AgentOrderByWithRelationInput
  }

  export type PayrollWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    agentId_periodStart_periodEnd_periodType?: PayrollAgentIdPeriodStartPeriodEndPeriodTypeCompoundUniqueInput
    AND?: PayrollWhereInput | PayrollWhereInput[]
    OR?: PayrollWhereInput[]
    NOT?: PayrollWhereInput | PayrollWhereInput[]
    agentId?: StringFilter<"Payroll"> | string
    periodStart?: DateTimeFilter<"Payroll"> | Date | string
    periodEnd?: DateTimeFilter<"Payroll"> | Date | string
    periodType?: StringFilter<"Payroll"> | string
    totalEarnings?: FloatFilter<"Payroll"> | number
    totalOrders?: IntFilter<"Payroll"> | number
    basePay?: FloatFilter<"Payroll"> | number
    bonuses?: FloatFilter<"Payroll"> | number
    deductions?: FloatFilter<"Payroll"> | number
    netPay?: FloatFilter<"Payroll"> | number
    status?: StringFilter<"Payroll"> | string
    processedAt?: DateTimeNullableFilter<"Payroll"> | Date | string | null
    paidAt?: DateTimeNullableFilter<"Payroll"> | Date | string | null
    paymentMethod?: StringNullableFilter<"Payroll"> | string | null
    transactionId?: StringNullableFilter<"Payroll"> | string | null
    notes?: StringNullableFilter<"Payroll"> | string | null
    createdAt?: DateTimeFilter<"Payroll"> | Date | string
    updatedAt?: DateTimeFilter<"Payroll"> | Date | string
    agent?: XOR<AgentScalarRelationFilter, AgentWhereInput>
  }, "id" | "agentId_periodStart_periodEnd_periodType">

  export type PayrollOrderByWithAggregationInput = {
    id?: SortOrder
    agentId?: SortOrder
    periodStart?: SortOrder
    periodEnd?: SortOrder
    periodType?: SortOrder
    totalEarnings?: SortOrder
    totalOrders?: SortOrder
    basePay?: SortOrder
    bonuses?: SortOrder
    deductions?: SortOrder
    netPay?: SortOrder
    status?: SortOrder
    processedAt?: SortOrderInput | SortOrder
    paidAt?: SortOrderInput | SortOrder
    paymentMethod?: SortOrderInput | SortOrder
    transactionId?: SortOrderInput | SortOrder
    notes?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: PayrollCountOrderByAggregateInput
    _avg?: PayrollAvgOrderByAggregateInput
    _max?: PayrollMaxOrderByAggregateInput
    _min?: PayrollMinOrderByAggregateInput
    _sum?: PayrollSumOrderByAggregateInput
  }

  export type PayrollScalarWhereWithAggregatesInput = {
    AND?: PayrollScalarWhereWithAggregatesInput | PayrollScalarWhereWithAggregatesInput[]
    OR?: PayrollScalarWhereWithAggregatesInput[]
    NOT?: PayrollScalarWhereWithAggregatesInput | PayrollScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Payroll"> | string
    agentId?: StringWithAggregatesFilter<"Payroll"> | string
    periodStart?: DateTimeWithAggregatesFilter<"Payroll"> | Date | string
    periodEnd?: DateTimeWithAggregatesFilter<"Payroll"> | Date | string
    periodType?: StringWithAggregatesFilter<"Payroll"> | string
    totalEarnings?: FloatWithAggregatesFilter<"Payroll"> | number
    totalOrders?: IntWithAggregatesFilter<"Payroll"> | number
    basePay?: FloatWithAggregatesFilter<"Payroll"> | number
    bonuses?: FloatWithAggregatesFilter<"Payroll"> | number
    deductions?: FloatWithAggregatesFilter<"Payroll"> | number
    netPay?: FloatWithAggregatesFilter<"Payroll"> | number
    status?: StringWithAggregatesFilter<"Payroll"> | string
    processedAt?: DateTimeNullableWithAggregatesFilter<"Payroll"> | Date | string | null
    paidAt?: DateTimeNullableWithAggregatesFilter<"Payroll"> | Date | string | null
    paymentMethod?: StringNullableWithAggregatesFilter<"Payroll"> | string | null
    transactionId?: StringNullableWithAggregatesFilter<"Payroll"> | string | null
    notes?: StringNullableWithAggregatesFilter<"Payroll"> | string | null
    createdAt?: DateTimeWithAggregatesFilter<"Payroll"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"Payroll"> | Date | string
  }

  export type AgentScheduleWhereInput = {
    AND?: AgentScheduleWhereInput | AgentScheduleWhereInput[]
    OR?: AgentScheduleWhereInput[]
    NOT?: AgentScheduleWhereInput | AgentScheduleWhereInput[]
    id?: StringFilter<"AgentSchedule"> | string
    agentId?: StringFilter<"AgentSchedule"> | string
    date?: DateTimeFilter<"AgentSchedule"> | Date | string
    startTime?: StringNullableFilter<"AgentSchedule"> | string | null
    endTime?: StringNullableFilter<"AgentSchedule"> | string | null
    isAvailable?: BoolFilter<"AgentSchedule"> | boolean
    notes?: StringNullableFilter<"AgentSchedule"> | string | null
    createdAt?: DateTimeFilter<"AgentSchedule"> | Date | string
    updatedAt?: DateTimeFilter<"AgentSchedule"> | Date | string
    agent?: XOR<AgentScalarRelationFilter, AgentWhereInput>
  }

  export type AgentScheduleOrderByWithRelationInput = {
    id?: SortOrder
    agentId?: SortOrder
    date?: SortOrder
    startTime?: SortOrderInput | SortOrder
    endTime?: SortOrderInput | SortOrder
    isAvailable?: SortOrder
    notes?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    agent?: AgentOrderByWithRelationInput
  }

  export type AgentScheduleWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    agentId_date?: AgentScheduleAgentIdDateCompoundUniqueInput
    AND?: AgentScheduleWhereInput | AgentScheduleWhereInput[]
    OR?: AgentScheduleWhereInput[]
    NOT?: AgentScheduleWhereInput | AgentScheduleWhereInput[]
    agentId?: StringFilter<"AgentSchedule"> | string
    date?: DateTimeFilter<"AgentSchedule"> | Date | string
    startTime?: StringNullableFilter<"AgentSchedule"> | string | null
    endTime?: StringNullableFilter<"AgentSchedule"> | string | null
    isAvailable?: BoolFilter<"AgentSchedule"> | boolean
    notes?: StringNullableFilter<"AgentSchedule"> | string | null
    createdAt?: DateTimeFilter<"AgentSchedule"> | Date | string
    updatedAt?: DateTimeFilter<"AgentSchedule"> | Date | string
    agent?: XOR<AgentScalarRelationFilter, AgentWhereInput>
  }, "id" | "agentId_date">

  export type AgentScheduleOrderByWithAggregationInput = {
    id?: SortOrder
    agentId?: SortOrder
    date?: SortOrder
    startTime?: SortOrderInput | SortOrder
    endTime?: SortOrderInput | SortOrder
    isAvailable?: SortOrder
    notes?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: AgentScheduleCountOrderByAggregateInput
    _max?: AgentScheduleMaxOrderByAggregateInput
    _min?: AgentScheduleMinOrderByAggregateInput
  }

  export type AgentScheduleScalarWhereWithAggregatesInput = {
    AND?: AgentScheduleScalarWhereWithAggregatesInput | AgentScheduleScalarWhereWithAggregatesInput[]
    OR?: AgentScheduleScalarWhereWithAggregatesInput[]
    NOT?: AgentScheduleScalarWhereWithAggregatesInput | AgentScheduleScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"AgentSchedule"> | string
    agentId?: StringWithAggregatesFilter<"AgentSchedule"> | string
    date?: DateTimeWithAggregatesFilter<"AgentSchedule"> | Date | string
    startTime?: StringNullableWithAggregatesFilter<"AgentSchedule"> | string | null
    endTime?: StringNullableWithAggregatesFilter<"AgentSchedule"> | string | null
    isAvailable?: BoolWithAggregatesFilter<"AgentSchedule"> | boolean
    notes?: StringNullableWithAggregatesFilter<"AgentSchedule"> | string | null
    createdAt?: DateTimeWithAggregatesFilter<"AgentSchedule"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"AgentSchedule"> | Date | string
  }

  export type PayStructureWhereInput = {
    AND?: PayStructureWhereInput | PayStructureWhereInput[]
    OR?: PayStructureWhereInput[]
    NOT?: PayStructureWhereInput | PayStructureWhereInput[]
    id?: StringFilter<"PayStructure"> | string
    name?: StringFilter<"PayStructure"> | string
    payType?: StringFilter<"PayStructure"> | string
    baseRate?: FloatNullableFilter<"PayStructure"> | number | null
    commissionRate?: FloatNullableFilter<"PayStructure"> | number | null
    minGuarantee?: FloatNullableFilter<"PayStructure"> | number | null
    maxLimit?: FloatNullableFilter<"PayStructure"> | number | null
    bonusRules?: JsonNullableFilter<"PayStructure">
    deductionRules?: JsonNullableFilter<"PayStructure">
    isActive?: BoolFilter<"PayStructure"> | boolean
    effectiveFrom?: DateTimeFilter<"PayStructure"> | Date | string
    effectiveTo?: DateTimeNullableFilter<"PayStructure"> | Date | string | null
    createdAt?: DateTimeFilter<"PayStructure"> | Date | string
    updatedAt?: DateTimeFilter<"PayStructure"> | Date | string
  }

  export type PayStructureOrderByWithRelationInput = {
    id?: SortOrder
    name?: SortOrder
    payType?: SortOrder
    baseRate?: SortOrderInput | SortOrder
    commissionRate?: SortOrderInput | SortOrder
    minGuarantee?: SortOrderInput | SortOrder
    maxLimit?: SortOrderInput | SortOrder
    bonusRules?: SortOrderInput | SortOrder
    deductionRules?: SortOrderInput | SortOrder
    isActive?: SortOrder
    effectiveFrom?: SortOrder
    effectiveTo?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type PayStructureWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: PayStructureWhereInput | PayStructureWhereInput[]
    OR?: PayStructureWhereInput[]
    NOT?: PayStructureWhereInput | PayStructureWhereInput[]
    name?: StringFilter<"PayStructure"> | string
    payType?: StringFilter<"PayStructure"> | string
    baseRate?: FloatNullableFilter<"PayStructure"> | number | null
    commissionRate?: FloatNullableFilter<"PayStructure"> | number | null
    minGuarantee?: FloatNullableFilter<"PayStructure"> | number | null
    maxLimit?: FloatNullableFilter<"PayStructure"> | number | null
    bonusRules?: JsonNullableFilter<"PayStructure">
    deductionRules?: JsonNullableFilter<"PayStructure">
    isActive?: BoolFilter<"PayStructure"> | boolean
    effectiveFrom?: DateTimeFilter<"PayStructure"> | Date | string
    effectiveTo?: DateTimeNullableFilter<"PayStructure"> | Date | string | null
    createdAt?: DateTimeFilter<"PayStructure"> | Date | string
    updatedAt?: DateTimeFilter<"PayStructure"> | Date | string
  }, "id">

  export type PayStructureOrderByWithAggregationInput = {
    id?: SortOrder
    name?: SortOrder
    payType?: SortOrder
    baseRate?: SortOrderInput | SortOrder
    commissionRate?: SortOrderInput | SortOrder
    minGuarantee?: SortOrderInput | SortOrder
    maxLimit?: SortOrderInput | SortOrder
    bonusRules?: SortOrderInput | SortOrder
    deductionRules?: SortOrderInput | SortOrder
    isActive?: SortOrder
    effectiveFrom?: SortOrder
    effectiveTo?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: PayStructureCountOrderByAggregateInput
    _avg?: PayStructureAvgOrderByAggregateInput
    _max?: PayStructureMaxOrderByAggregateInput
    _min?: PayStructureMinOrderByAggregateInput
    _sum?: PayStructureSumOrderByAggregateInput
  }

  export type PayStructureScalarWhereWithAggregatesInput = {
    AND?: PayStructureScalarWhereWithAggregatesInput | PayStructureScalarWhereWithAggregatesInput[]
    OR?: PayStructureScalarWhereWithAggregatesInput[]
    NOT?: PayStructureScalarWhereWithAggregatesInput | PayStructureScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"PayStructure"> | string
    name?: StringWithAggregatesFilter<"PayStructure"> | string
    payType?: StringWithAggregatesFilter<"PayStructure"> | string
    baseRate?: FloatNullableWithAggregatesFilter<"PayStructure"> | number | null
    commissionRate?: FloatNullableWithAggregatesFilter<"PayStructure"> | number | null
    minGuarantee?: FloatNullableWithAggregatesFilter<"PayStructure"> | number | null
    maxLimit?: FloatNullableWithAggregatesFilter<"PayStructure"> | number | null
    bonusRules?: JsonNullableWithAggregatesFilter<"PayStructure">
    deductionRules?: JsonNullableWithAggregatesFilter<"PayStructure">
    isActive?: BoolWithAggregatesFilter<"PayStructure"> | boolean
    effectiveFrom?: DateTimeWithAggregatesFilter<"PayStructure"> | Date | string
    effectiveTo?: DateTimeNullableWithAggregatesFilter<"PayStructure"> | Date | string | null
    createdAt?: DateTimeWithAggregatesFilter<"PayStructure"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"PayStructure"> | Date | string
  }

  export type UserCreateInput = {
    id?: string
    name: string
    email: string
    phone: string
    passwordHash: string
    role: $Enums.UserRole
    emailVerified?: Date | string | null
    phoneVerified?: boolean
    profilePicture?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    agent?: AgentCreateNestedOneWithoutUserInput
    partner?: PartnerCreateNestedOneWithoutUserInput
    notifications?: NotificationTokenCreateNestedManyWithoutUserInput
    userNotifications?: NotificationCreateNestedManyWithoutUserInput
    tickets?: SupportTicketCreateNestedManyWithoutUserInput
  }

  export type UserUncheckedCreateInput = {
    id?: string
    name: string
    email: string
    phone: string
    passwordHash: string
    role: $Enums.UserRole
    emailVerified?: Date | string | null
    phoneVerified?: boolean
    profilePicture?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    agent?: AgentUncheckedCreateNestedOneWithoutUserInput
    partner?: PartnerUncheckedCreateNestedOneWithoutUserInput
    notifications?: NotificationTokenUncheckedCreateNestedManyWithoutUserInput
    userNotifications?: NotificationUncheckedCreateNestedManyWithoutUserInput
    tickets?: SupportTicketUncheckedCreateNestedManyWithoutUserInput
  }

  export type UserUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    phone?: StringFieldUpdateOperationsInput | string
    passwordHash?: StringFieldUpdateOperationsInput | string
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    emailVerified?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    phoneVerified?: BoolFieldUpdateOperationsInput | boolean
    profilePicture?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    agent?: AgentUpdateOneWithoutUserNestedInput
    partner?: PartnerUpdateOneWithoutUserNestedInput
    notifications?: NotificationTokenUpdateManyWithoutUserNestedInput
    userNotifications?: NotificationUpdateManyWithoutUserNestedInput
    tickets?: SupportTicketUpdateManyWithoutUserNestedInput
  }

  export type UserUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    phone?: StringFieldUpdateOperationsInput | string
    passwordHash?: StringFieldUpdateOperationsInput | string
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    emailVerified?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    phoneVerified?: BoolFieldUpdateOperationsInput | boolean
    profilePicture?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    agent?: AgentUncheckedUpdateOneWithoutUserNestedInput
    partner?: PartnerUncheckedUpdateOneWithoutUserNestedInput
    notifications?: NotificationTokenUncheckedUpdateManyWithoutUserNestedInput
    userNotifications?: NotificationUncheckedUpdateManyWithoutUserNestedInput
    tickets?: SupportTicketUncheckedUpdateManyWithoutUserNestedInput
  }

  export type UserCreateManyInput = {
    id?: string
    name: string
    email: string
    phone: string
    passwordHash: string
    role: $Enums.UserRole
    emailVerified?: Date | string | null
    phoneVerified?: boolean
    profilePicture?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type UserUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    phone?: StringFieldUpdateOperationsInput | string
    passwordHash?: StringFieldUpdateOperationsInput | string
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    emailVerified?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    phoneVerified?: BoolFieldUpdateOperationsInput | boolean
    profilePicture?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type UserUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    phone?: StringFieldUpdateOperationsInput | string
    passwordHash?: StringFieldUpdateOperationsInput | string
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    emailVerified?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    phoneVerified?: BoolFieldUpdateOperationsInput | boolean
    profilePicture?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AgentCreateInput = {
    id?: string
    vehicleType: $Enums.VehicleType
    status?: $Enums.AgentStatus
    rating?: number | null
    totalOrders?: number
    completedOrders?: number
    cancelledOrders?: number
    acceptanceRate?: number
    isApproved?: boolean
    isBlocked?: boolean
    blockedReason?: string | null
    city?: string | null
    state?: string | null
    pincode?: string | null
    lastOnlineAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    user: UserCreateNestedOneWithoutAgentInput
    orders?: OrderCreateNestedManyWithoutAgentInput
    currentOrder?: OrderCreateNestedOneWithoutCurrentAgentInput
    documents?: AgentDocumentCreateNestedManyWithoutAgentInput
    locationHistory?: AgentLocationCreateNestedManyWithoutAgentInput
    tickets?: SupportTicketCreateNestedManyWithoutAgentInput
    ratings?: AgentRatingCreateNestedManyWithoutAgentInput
    wallet?: AgentWalletCreateNestedOneWithoutAgentInput
    walletPayouts?: WalletPayoutCreateNestedManyWithoutAgentInput
    payments?: PaymentCreateNestedManyWithoutAgentInput
    payrolls?: PayrollCreateNestedManyWithoutAgentInput
    schedules?: AgentScheduleCreateNestedManyWithoutAgentInput
  }

  export type AgentUncheckedCreateInput = {
    id?: string
    userId: string
    vehicleType: $Enums.VehicleType
    status?: $Enums.AgentStatus
    rating?: number | null
    totalOrders?: number
    completedOrders?: number
    cancelledOrders?: number
    acceptanceRate?: number
    currentOrderId?: string | null
    isApproved?: boolean
    isBlocked?: boolean
    blockedReason?: string | null
    city?: string | null
    state?: string | null
    pincode?: string | null
    lastOnlineAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    orders?: OrderUncheckedCreateNestedManyWithoutAgentInput
    documents?: AgentDocumentUncheckedCreateNestedManyWithoutAgentInput
    locationHistory?: AgentLocationUncheckedCreateNestedManyWithoutAgentInput
    tickets?: SupportTicketUncheckedCreateNestedManyWithoutAgentInput
    ratings?: AgentRatingUncheckedCreateNestedManyWithoutAgentInput
    wallet?: AgentWalletUncheckedCreateNestedOneWithoutAgentInput
    walletPayouts?: WalletPayoutUncheckedCreateNestedManyWithoutAgentInput
    payments?: PaymentUncheckedCreateNestedManyWithoutAgentInput
    payrolls?: PayrollUncheckedCreateNestedManyWithoutAgentInput
    schedules?: AgentScheduleUncheckedCreateNestedManyWithoutAgentInput
  }

  export type AgentUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    vehicleType?: EnumVehicleTypeFieldUpdateOperationsInput | $Enums.VehicleType
    status?: EnumAgentStatusFieldUpdateOperationsInput | $Enums.AgentStatus
    rating?: NullableFloatFieldUpdateOperationsInput | number | null
    totalOrders?: IntFieldUpdateOperationsInput | number
    completedOrders?: IntFieldUpdateOperationsInput | number
    cancelledOrders?: IntFieldUpdateOperationsInput | number
    acceptanceRate?: FloatFieldUpdateOperationsInput | number
    isApproved?: BoolFieldUpdateOperationsInput | boolean
    isBlocked?: BoolFieldUpdateOperationsInput | boolean
    blockedReason?: NullableStringFieldUpdateOperationsInput | string | null
    city?: NullableStringFieldUpdateOperationsInput | string | null
    state?: NullableStringFieldUpdateOperationsInput | string | null
    pincode?: NullableStringFieldUpdateOperationsInput | string | null
    lastOnlineAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneRequiredWithoutAgentNestedInput
    orders?: OrderUpdateManyWithoutAgentNestedInput
    currentOrder?: OrderUpdateOneWithoutCurrentAgentNestedInput
    documents?: AgentDocumentUpdateManyWithoutAgentNestedInput
    locationHistory?: AgentLocationUpdateManyWithoutAgentNestedInput
    tickets?: SupportTicketUpdateManyWithoutAgentNestedInput
    ratings?: AgentRatingUpdateManyWithoutAgentNestedInput
    wallet?: AgentWalletUpdateOneWithoutAgentNestedInput
    walletPayouts?: WalletPayoutUpdateManyWithoutAgentNestedInput
    payments?: PaymentUpdateManyWithoutAgentNestedInput
    payrolls?: PayrollUpdateManyWithoutAgentNestedInput
    schedules?: AgentScheduleUpdateManyWithoutAgentNestedInput
  }

  export type AgentUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    vehicleType?: EnumVehicleTypeFieldUpdateOperationsInput | $Enums.VehicleType
    status?: EnumAgentStatusFieldUpdateOperationsInput | $Enums.AgentStatus
    rating?: NullableFloatFieldUpdateOperationsInput | number | null
    totalOrders?: IntFieldUpdateOperationsInput | number
    completedOrders?: IntFieldUpdateOperationsInput | number
    cancelledOrders?: IntFieldUpdateOperationsInput | number
    acceptanceRate?: FloatFieldUpdateOperationsInput | number
    currentOrderId?: NullableStringFieldUpdateOperationsInput | string | null
    isApproved?: BoolFieldUpdateOperationsInput | boolean
    isBlocked?: BoolFieldUpdateOperationsInput | boolean
    blockedReason?: NullableStringFieldUpdateOperationsInput | string | null
    city?: NullableStringFieldUpdateOperationsInput | string | null
    state?: NullableStringFieldUpdateOperationsInput | string | null
    pincode?: NullableStringFieldUpdateOperationsInput | string | null
    lastOnlineAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    orders?: OrderUncheckedUpdateManyWithoutAgentNestedInput
    documents?: AgentDocumentUncheckedUpdateManyWithoutAgentNestedInput
    locationHistory?: AgentLocationUncheckedUpdateManyWithoutAgentNestedInput
    tickets?: SupportTicketUncheckedUpdateManyWithoutAgentNestedInput
    ratings?: AgentRatingUncheckedUpdateManyWithoutAgentNestedInput
    wallet?: AgentWalletUncheckedUpdateOneWithoutAgentNestedInput
    walletPayouts?: WalletPayoutUncheckedUpdateManyWithoutAgentNestedInput
    payments?: PaymentUncheckedUpdateManyWithoutAgentNestedInput
    payrolls?: PayrollUncheckedUpdateManyWithoutAgentNestedInput
    schedules?: AgentScheduleUncheckedUpdateManyWithoutAgentNestedInput
  }

  export type AgentCreateManyInput = {
    id?: string
    userId: string
    vehicleType: $Enums.VehicleType
    status?: $Enums.AgentStatus
    rating?: number | null
    totalOrders?: number
    completedOrders?: number
    cancelledOrders?: number
    acceptanceRate?: number
    currentOrderId?: string | null
    isApproved?: boolean
    isBlocked?: boolean
    blockedReason?: string | null
    city?: string | null
    state?: string | null
    pincode?: string | null
    lastOnlineAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type AgentUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    vehicleType?: EnumVehicleTypeFieldUpdateOperationsInput | $Enums.VehicleType
    status?: EnumAgentStatusFieldUpdateOperationsInput | $Enums.AgentStatus
    rating?: NullableFloatFieldUpdateOperationsInput | number | null
    totalOrders?: IntFieldUpdateOperationsInput | number
    completedOrders?: IntFieldUpdateOperationsInput | number
    cancelledOrders?: IntFieldUpdateOperationsInput | number
    acceptanceRate?: FloatFieldUpdateOperationsInput | number
    isApproved?: BoolFieldUpdateOperationsInput | boolean
    isBlocked?: BoolFieldUpdateOperationsInput | boolean
    blockedReason?: NullableStringFieldUpdateOperationsInput | string | null
    city?: NullableStringFieldUpdateOperationsInput | string | null
    state?: NullableStringFieldUpdateOperationsInput | string | null
    pincode?: NullableStringFieldUpdateOperationsInput | string | null
    lastOnlineAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AgentUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    vehicleType?: EnumVehicleTypeFieldUpdateOperationsInput | $Enums.VehicleType
    status?: EnumAgentStatusFieldUpdateOperationsInput | $Enums.AgentStatus
    rating?: NullableFloatFieldUpdateOperationsInput | number | null
    totalOrders?: IntFieldUpdateOperationsInput | number
    completedOrders?: IntFieldUpdateOperationsInput | number
    cancelledOrders?: IntFieldUpdateOperationsInput | number
    acceptanceRate?: FloatFieldUpdateOperationsInput | number
    currentOrderId?: NullableStringFieldUpdateOperationsInput | string | null
    isApproved?: BoolFieldUpdateOperationsInput | boolean
    isBlocked?: BoolFieldUpdateOperationsInput | boolean
    blockedReason?: NullableStringFieldUpdateOperationsInput | string | null
    city?: NullableStringFieldUpdateOperationsInput | string | null
    state?: NullableStringFieldUpdateOperationsInput | string | null
    pincode?: NullableStringFieldUpdateOperationsInput | string | null
    lastOnlineAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AgentDocumentCreateInput = {
    id?: string
    documentType: string
    fileName: string
    fileUrl: string
    verified?: boolean
    uploadedAt?: Date | string
    agent: AgentCreateNestedOneWithoutDocumentsInput
  }

  export type AgentDocumentUncheckedCreateInput = {
    id?: string
    agentId: string
    documentType: string
    fileName: string
    fileUrl: string
    verified?: boolean
    uploadedAt?: Date | string
  }

  export type AgentDocumentUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    documentType?: StringFieldUpdateOperationsInput | string
    fileName?: StringFieldUpdateOperationsInput | string
    fileUrl?: StringFieldUpdateOperationsInput | string
    verified?: BoolFieldUpdateOperationsInput | boolean
    uploadedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    agent?: AgentUpdateOneRequiredWithoutDocumentsNestedInput
  }

  export type AgentDocumentUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    agentId?: StringFieldUpdateOperationsInput | string
    documentType?: StringFieldUpdateOperationsInput | string
    fileName?: StringFieldUpdateOperationsInput | string
    fileUrl?: StringFieldUpdateOperationsInput | string
    verified?: BoolFieldUpdateOperationsInput | boolean
    uploadedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AgentDocumentCreateManyInput = {
    id?: string
    agentId: string
    documentType: string
    fileName: string
    fileUrl: string
    verified?: boolean
    uploadedAt?: Date | string
  }

  export type AgentDocumentUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    documentType?: StringFieldUpdateOperationsInput | string
    fileName?: StringFieldUpdateOperationsInput | string
    fileUrl?: StringFieldUpdateOperationsInput | string
    verified?: BoolFieldUpdateOperationsInput | boolean
    uploadedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AgentDocumentUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    agentId?: StringFieldUpdateOperationsInput | string
    documentType?: StringFieldUpdateOperationsInput | string
    fileName?: StringFieldUpdateOperationsInput | string
    fileUrl?: StringFieldUpdateOperationsInput | string
    verified?: BoolFieldUpdateOperationsInput | boolean
    uploadedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AgentLocationCreateInput = {
    id?: string
    latitude: number
    longitude: number
    timestamp?: Date | string
    agent: AgentCreateNestedOneWithoutLocationHistoryInput
  }

  export type AgentLocationUncheckedCreateInput = {
    id?: string
    agentId: string
    latitude: number
    longitude: number
    timestamp?: Date | string
  }

  export type AgentLocationUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    latitude?: FloatFieldUpdateOperationsInput | number
    longitude?: FloatFieldUpdateOperationsInput | number
    timestamp?: DateTimeFieldUpdateOperationsInput | Date | string
    agent?: AgentUpdateOneRequiredWithoutLocationHistoryNestedInput
  }

  export type AgentLocationUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    agentId?: StringFieldUpdateOperationsInput | string
    latitude?: FloatFieldUpdateOperationsInput | number
    longitude?: FloatFieldUpdateOperationsInput | number
    timestamp?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AgentLocationCreateManyInput = {
    id?: string
    agentId: string
    latitude: number
    longitude: number
    timestamp?: Date | string
  }

  export type AgentLocationUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    latitude?: FloatFieldUpdateOperationsInput | number
    longitude?: FloatFieldUpdateOperationsInput | number
    timestamp?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AgentLocationUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    agentId?: StringFieldUpdateOperationsInput | string
    latitude?: FloatFieldUpdateOperationsInput | number
    longitude?: FloatFieldUpdateOperationsInput | number
    timestamp?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PartnerCreateInput = {
    id?: string
    companyName: string
    apiKey: string
    webhookUrl?: string | null
    isActive?: boolean
    city?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    user: UserCreateNestedOneWithoutPartnerInput
    orders?: OrderCreateNestedManyWithoutPartnerInput
    tickets?: SupportTicketCreateNestedManyWithoutPartnerInput
    dailyStats?: PartnerDailyStatsCreateNestedManyWithoutPartnerInput
    agentRatings?: AgentRatingCreateNestedManyWithoutPartnerInput
    partnerRevenues?: PartnerRevenueCreateNestedManyWithoutPartnerInput
    platformRevenues?: PlatformRevenueCreateNestedManyWithoutPartnerInput
  }

  export type PartnerUncheckedCreateInput = {
    id?: string
    userId: string
    companyName: string
    apiKey: string
    webhookUrl?: string | null
    isActive?: boolean
    city?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    orders?: OrderUncheckedCreateNestedManyWithoutPartnerInput
    tickets?: SupportTicketUncheckedCreateNestedManyWithoutPartnerInput
    dailyStats?: PartnerDailyStatsUncheckedCreateNestedManyWithoutPartnerInput
    agentRatings?: AgentRatingUncheckedCreateNestedManyWithoutPartnerInput
    partnerRevenues?: PartnerRevenueUncheckedCreateNestedManyWithoutPartnerInput
    platformRevenues?: PlatformRevenueUncheckedCreateNestedManyWithoutPartnerInput
  }

  export type PartnerUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    companyName?: StringFieldUpdateOperationsInput | string
    apiKey?: StringFieldUpdateOperationsInput | string
    webhookUrl?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    city?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneRequiredWithoutPartnerNestedInput
    orders?: OrderUpdateManyWithoutPartnerNestedInput
    tickets?: SupportTicketUpdateManyWithoutPartnerNestedInput
    dailyStats?: PartnerDailyStatsUpdateManyWithoutPartnerNestedInput
    agentRatings?: AgentRatingUpdateManyWithoutPartnerNestedInput
    partnerRevenues?: PartnerRevenueUpdateManyWithoutPartnerNestedInput
    platformRevenues?: PlatformRevenueUpdateManyWithoutPartnerNestedInput
  }

  export type PartnerUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    companyName?: StringFieldUpdateOperationsInput | string
    apiKey?: StringFieldUpdateOperationsInput | string
    webhookUrl?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    city?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    orders?: OrderUncheckedUpdateManyWithoutPartnerNestedInput
    tickets?: SupportTicketUncheckedUpdateManyWithoutPartnerNestedInput
    dailyStats?: PartnerDailyStatsUncheckedUpdateManyWithoutPartnerNestedInput
    agentRatings?: AgentRatingUncheckedUpdateManyWithoutPartnerNestedInput
    partnerRevenues?: PartnerRevenueUncheckedUpdateManyWithoutPartnerNestedInput
    platformRevenues?: PlatformRevenueUncheckedUpdateManyWithoutPartnerNestedInput
  }

  export type PartnerCreateManyInput = {
    id?: string
    userId: string
    companyName: string
    apiKey: string
    webhookUrl?: string | null
    isActive?: boolean
    city?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type PartnerUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    companyName?: StringFieldUpdateOperationsInput | string
    apiKey?: StringFieldUpdateOperationsInput | string
    webhookUrl?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    city?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PartnerUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    companyName?: StringFieldUpdateOperationsInput | string
    apiKey?: StringFieldUpdateOperationsInput | string
    webhookUrl?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    city?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type OrderCreateInput = {
    id?: string
    pickupLat: number
    pickupLng: number
    dropLat: number
    dropLng: number
    payoutAmount: number
    orderAmount?: number | null
    platformFee?: number | null
    orderType?: string | null
    commissionRate?: number | null
    priority?: string | null
    status?: $Enums.OrderStatus
    assignedAt?: Date | string | null
    pickedUpAt?: Date | string | null
    deliveredAt?: Date | string | null
    cancelledAt?: Date | string | null
    cancellationReason?: string | null
    estimatedDuration?: number | null
    actualDuration?: number | null
    createdAt?: Date | string
    updatedAt?: Date | string
    barcode?: string | null
    qrCode?: string | null
    deliveryOtp?: string | null
    deliveryQrCode?: string | null
    otpExpiresAt?: Date | string | null
    verifiedAt?: Date | string | null
    verificationMethod?: string | null
    partner: PartnerCreateNestedOneWithoutOrdersInput
    agent?: AgentCreateNestedOneWithoutOrdersInput
    currentAgent?: AgentCreateNestedOneWithoutCurrentOrderInput
    tickets?: SupportTicketCreateNestedManyWithoutOrderInput
    rating?: AgentRatingCreateNestedOneWithoutOrderInput
    payments?: PaymentCreateNestedManyWithoutOrderInput
    partnerRevenue?: PartnerRevenueCreateNestedOneWithoutOrderInput
    platformRevenue?: PlatformRevenueCreateNestedOneWithoutOrderInput
    walletTransactions?: WalletTransactionCreateNestedManyWithoutOrderInput
  }

  export type OrderUncheckedCreateInput = {
    id?: string
    partnerId: string
    agentId?: string | null
    pickupLat: number
    pickupLng: number
    dropLat: number
    dropLng: number
    payoutAmount: number
    orderAmount?: number | null
    platformFee?: number | null
    orderType?: string | null
    commissionRate?: number | null
    priority?: string | null
    status?: $Enums.OrderStatus
    assignedAt?: Date | string | null
    pickedUpAt?: Date | string | null
    deliveredAt?: Date | string | null
    cancelledAt?: Date | string | null
    cancellationReason?: string | null
    estimatedDuration?: number | null
    actualDuration?: number | null
    createdAt?: Date | string
    updatedAt?: Date | string
    barcode?: string | null
    qrCode?: string | null
    deliveryOtp?: string | null
    deliveryQrCode?: string | null
    otpExpiresAt?: Date | string | null
    verifiedAt?: Date | string | null
    verificationMethod?: string | null
    currentAgent?: AgentUncheckedCreateNestedOneWithoutCurrentOrderInput
    tickets?: SupportTicketUncheckedCreateNestedManyWithoutOrderInput
    rating?: AgentRatingUncheckedCreateNestedOneWithoutOrderInput
    payments?: PaymentUncheckedCreateNestedManyWithoutOrderInput
    partnerRevenue?: PartnerRevenueUncheckedCreateNestedOneWithoutOrderInput
    platformRevenue?: PlatformRevenueUncheckedCreateNestedOneWithoutOrderInput
    walletTransactions?: WalletTransactionUncheckedCreateNestedManyWithoutOrderInput
  }

  export type OrderUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    pickupLat?: FloatFieldUpdateOperationsInput | number
    pickupLng?: FloatFieldUpdateOperationsInput | number
    dropLat?: FloatFieldUpdateOperationsInput | number
    dropLng?: FloatFieldUpdateOperationsInput | number
    payoutAmount?: FloatFieldUpdateOperationsInput | number
    orderAmount?: NullableFloatFieldUpdateOperationsInput | number | null
    platformFee?: NullableFloatFieldUpdateOperationsInput | number | null
    orderType?: NullableStringFieldUpdateOperationsInput | string | null
    commissionRate?: NullableFloatFieldUpdateOperationsInput | number | null
    priority?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumOrderStatusFieldUpdateOperationsInput | $Enums.OrderStatus
    assignedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    pickedUpAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    deliveredAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    cancelledAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    cancellationReason?: NullableStringFieldUpdateOperationsInput | string | null
    estimatedDuration?: NullableIntFieldUpdateOperationsInput | number | null
    actualDuration?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    barcode?: NullableStringFieldUpdateOperationsInput | string | null
    qrCode?: NullableStringFieldUpdateOperationsInput | string | null
    deliveryOtp?: NullableStringFieldUpdateOperationsInput | string | null
    deliveryQrCode?: NullableStringFieldUpdateOperationsInput | string | null
    otpExpiresAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    verifiedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    verificationMethod?: NullableStringFieldUpdateOperationsInput | string | null
    partner?: PartnerUpdateOneRequiredWithoutOrdersNestedInput
    agent?: AgentUpdateOneWithoutOrdersNestedInput
    currentAgent?: AgentUpdateOneWithoutCurrentOrderNestedInput
    tickets?: SupportTicketUpdateManyWithoutOrderNestedInput
    rating?: AgentRatingUpdateOneWithoutOrderNestedInput
    payments?: PaymentUpdateManyWithoutOrderNestedInput
    partnerRevenue?: PartnerRevenueUpdateOneWithoutOrderNestedInput
    platformRevenue?: PlatformRevenueUpdateOneWithoutOrderNestedInput
    walletTransactions?: WalletTransactionUpdateManyWithoutOrderNestedInput
  }

  export type OrderUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    partnerId?: StringFieldUpdateOperationsInput | string
    agentId?: NullableStringFieldUpdateOperationsInput | string | null
    pickupLat?: FloatFieldUpdateOperationsInput | number
    pickupLng?: FloatFieldUpdateOperationsInput | number
    dropLat?: FloatFieldUpdateOperationsInput | number
    dropLng?: FloatFieldUpdateOperationsInput | number
    payoutAmount?: FloatFieldUpdateOperationsInput | number
    orderAmount?: NullableFloatFieldUpdateOperationsInput | number | null
    platformFee?: NullableFloatFieldUpdateOperationsInput | number | null
    orderType?: NullableStringFieldUpdateOperationsInput | string | null
    commissionRate?: NullableFloatFieldUpdateOperationsInput | number | null
    priority?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumOrderStatusFieldUpdateOperationsInput | $Enums.OrderStatus
    assignedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    pickedUpAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    deliveredAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    cancelledAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    cancellationReason?: NullableStringFieldUpdateOperationsInput | string | null
    estimatedDuration?: NullableIntFieldUpdateOperationsInput | number | null
    actualDuration?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    barcode?: NullableStringFieldUpdateOperationsInput | string | null
    qrCode?: NullableStringFieldUpdateOperationsInput | string | null
    deliveryOtp?: NullableStringFieldUpdateOperationsInput | string | null
    deliveryQrCode?: NullableStringFieldUpdateOperationsInput | string | null
    otpExpiresAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    verifiedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    verificationMethod?: NullableStringFieldUpdateOperationsInput | string | null
    currentAgent?: AgentUncheckedUpdateOneWithoutCurrentOrderNestedInput
    tickets?: SupportTicketUncheckedUpdateManyWithoutOrderNestedInput
    rating?: AgentRatingUncheckedUpdateOneWithoutOrderNestedInput
    payments?: PaymentUncheckedUpdateManyWithoutOrderNestedInput
    partnerRevenue?: PartnerRevenueUncheckedUpdateOneWithoutOrderNestedInput
    platformRevenue?: PlatformRevenueUncheckedUpdateOneWithoutOrderNestedInput
    walletTransactions?: WalletTransactionUncheckedUpdateManyWithoutOrderNestedInput
  }

  export type OrderCreateManyInput = {
    id?: string
    partnerId: string
    agentId?: string | null
    pickupLat: number
    pickupLng: number
    dropLat: number
    dropLng: number
    payoutAmount: number
    orderAmount?: number | null
    platformFee?: number | null
    orderType?: string | null
    commissionRate?: number | null
    priority?: string | null
    status?: $Enums.OrderStatus
    assignedAt?: Date | string | null
    pickedUpAt?: Date | string | null
    deliveredAt?: Date | string | null
    cancelledAt?: Date | string | null
    cancellationReason?: string | null
    estimatedDuration?: number | null
    actualDuration?: number | null
    createdAt?: Date | string
    updatedAt?: Date | string
    barcode?: string | null
    qrCode?: string | null
    deliveryOtp?: string | null
    deliveryQrCode?: string | null
    otpExpiresAt?: Date | string | null
    verifiedAt?: Date | string | null
    verificationMethod?: string | null
  }

  export type OrderUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    pickupLat?: FloatFieldUpdateOperationsInput | number
    pickupLng?: FloatFieldUpdateOperationsInput | number
    dropLat?: FloatFieldUpdateOperationsInput | number
    dropLng?: FloatFieldUpdateOperationsInput | number
    payoutAmount?: FloatFieldUpdateOperationsInput | number
    orderAmount?: NullableFloatFieldUpdateOperationsInput | number | null
    platformFee?: NullableFloatFieldUpdateOperationsInput | number | null
    orderType?: NullableStringFieldUpdateOperationsInput | string | null
    commissionRate?: NullableFloatFieldUpdateOperationsInput | number | null
    priority?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumOrderStatusFieldUpdateOperationsInput | $Enums.OrderStatus
    assignedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    pickedUpAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    deliveredAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    cancelledAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    cancellationReason?: NullableStringFieldUpdateOperationsInput | string | null
    estimatedDuration?: NullableIntFieldUpdateOperationsInput | number | null
    actualDuration?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    barcode?: NullableStringFieldUpdateOperationsInput | string | null
    qrCode?: NullableStringFieldUpdateOperationsInput | string | null
    deliveryOtp?: NullableStringFieldUpdateOperationsInput | string | null
    deliveryQrCode?: NullableStringFieldUpdateOperationsInput | string | null
    otpExpiresAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    verifiedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    verificationMethod?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type OrderUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    partnerId?: StringFieldUpdateOperationsInput | string
    agentId?: NullableStringFieldUpdateOperationsInput | string | null
    pickupLat?: FloatFieldUpdateOperationsInput | number
    pickupLng?: FloatFieldUpdateOperationsInput | number
    dropLat?: FloatFieldUpdateOperationsInput | number
    dropLng?: FloatFieldUpdateOperationsInput | number
    payoutAmount?: FloatFieldUpdateOperationsInput | number
    orderAmount?: NullableFloatFieldUpdateOperationsInput | number | null
    platformFee?: NullableFloatFieldUpdateOperationsInput | number | null
    orderType?: NullableStringFieldUpdateOperationsInput | string | null
    commissionRate?: NullableFloatFieldUpdateOperationsInput | number | null
    priority?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumOrderStatusFieldUpdateOperationsInput | $Enums.OrderStatus
    assignedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    pickedUpAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    deliveredAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    cancelledAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    cancellationReason?: NullableStringFieldUpdateOperationsInput | string | null
    estimatedDuration?: NullableIntFieldUpdateOperationsInput | number | null
    actualDuration?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    barcode?: NullableStringFieldUpdateOperationsInput | string | null
    qrCode?: NullableStringFieldUpdateOperationsInput | string | null
    deliveryOtp?: NullableStringFieldUpdateOperationsInput | string | null
    deliveryQrCode?: NullableStringFieldUpdateOperationsInput | string | null
    otpExpiresAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    verifiedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    verificationMethod?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type NotificationTokenCreateInput = {
    id?: string
    fcmToken: string
    deviceType?: string | null
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    user: UserCreateNestedOneWithoutNotificationsInput
  }

  export type NotificationTokenUncheckedCreateInput = {
    id?: string
    userId: string
    fcmToken: string
    deviceType?: string | null
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type NotificationTokenUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    fcmToken?: StringFieldUpdateOperationsInput | string
    deviceType?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneRequiredWithoutNotificationsNestedInput
  }

  export type NotificationTokenUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    fcmToken?: StringFieldUpdateOperationsInput | string
    deviceType?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type NotificationTokenCreateManyInput = {
    id?: string
    userId: string
    fcmToken: string
    deviceType?: string | null
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type NotificationTokenUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    fcmToken?: StringFieldUpdateOperationsInput | string
    deviceType?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type NotificationTokenUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    fcmToken?: StringFieldUpdateOperationsInput | string
    deviceType?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SupportTicketCreateInput = {
    id?: string
    issueType: string
    description: string
    status?: $Enums.TicketStatus
    resolvedAt?: Date | string | null
    adminNotes?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    order?: OrderCreateNestedOneWithoutTicketsInput
    agent?: AgentCreateNestedOneWithoutTicketsInput
    partner?: PartnerCreateNestedOneWithoutTicketsInput
    user: UserCreateNestedOneWithoutTicketsInput
  }

  export type SupportTicketUncheckedCreateInput = {
    id?: string
    orderId?: string | null
    agentId?: string | null
    partnerId?: string | null
    userId: string
    issueType: string
    description: string
    status?: $Enums.TicketStatus
    resolvedAt?: Date | string | null
    adminNotes?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type SupportTicketUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    issueType?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    status?: EnumTicketStatusFieldUpdateOperationsInput | $Enums.TicketStatus
    resolvedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    adminNotes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    order?: OrderUpdateOneWithoutTicketsNestedInput
    agent?: AgentUpdateOneWithoutTicketsNestedInput
    partner?: PartnerUpdateOneWithoutTicketsNestedInput
    user?: UserUpdateOneRequiredWithoutTicketsNestedInput
  }

  export type SupportTicketUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    orderId?: NullableStringFieldUpdateOperationsInput | string | null
    agentId?: NullableStringFieldUpdateOperationsInput | string | null
    partnerId?: NullableStringFieldUpdateOperationsInput | string | null
    userId?: StringFieldUpdateOperationsInput | string
    issueType?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    status?: EnumTicketStatusFieldUpdateOperationsInput | $Enums.TicketStatus
    resolvedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    adminNotes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SupportTicketCreateManyInput = {
    id?: string
    orderId?: string | null
    agentId?: string | null
    partnerId?: string | null
    userId: string
    issueType: string
    description: string
    status?: $Enums.TicketStatus
    resolvedAt?: Date | string | null
    adminNotes?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type SupportTicketUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    issueType?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    status?: EnumTicketStatusFieldUpdateOperationsInput | $Enums.TicketStatus
    resolvedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    adminNotes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SupportTicketUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    orderId?: NullableStringFieldUpdateOperationsInput | string | null
    agentId?: NullableStringFieldUpdateOperationsInput | string | null
    partnerId?: NullableStringFieldUpdateOperationsInput | string | null
    userId?: StringFieldUpdateOperationsInput | string
    issueType?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    status?: EnumTicketStatusFieldUpdateOperationsInput | $Enums.TicketStatus
    resolvedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    adminNotes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AppEventCreateInput = {
    id?: string
    userId?: string | null
    actorType: $Enums.ActorType
    eventType: $Enums.EventType
    entityType?: string | null
    entityId?: string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
  }

  export type AppEventUncheckedCreateInput = {
    id?: string
    userId?: string | null
    actorType: $Enums.ActorType
    eventType: $Enums.EventType
    entityType?: string | null
    entityId?: string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
  }

  export type AppEventUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: NullableStringFieldUpdateOperationsInput | string | null
    actorType?: EnumActorTypeFieldUpdateOperationsInput | $Enums.ActorType
    eventType?: EnumEventTypeFieldUpdateOperationsInput | $Enums.EventType
    entityType?: NullableStringFieldUpdateOperationsInput | string | null
    entityId?: NullableStringFieldUpdateOperationsInput | string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AppEventUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: NullableStringFieldUpdateOperationsInput | string | null
    actorType?: EnumActorTypeFieldUpdateOperationsInput | $Enums.ActorType
    eventType?: EnumEventTypeFieldUpdateOperationsInput | $Enums.EventType
    entityType?: NullableStringFieldUpdateOperationsInput | string | null
    entityId?: NullableStringFieldUpdateOperationsInput | string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AppEventCreateManyInput = {
    id?: string
    userId?: string | null
    actorType: $Enums.ActorType
    eventType: $Enums.EventType
    entityType?: string | null
    entityId?: string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
  }

  export type AppEventUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: NullableStringFieldUpdateOperationsInput | string | null
    actorType?: EnumActorTypeFieldUpdateOperationsInput | $Enums.ActorType
    eventType?: EnumEventTypeFieldUpdateOperationsInput | $Enums.EventType
    entityType?: NullableStringFieldUpdateOperationsInput | string | null
    entityId?: NullableStringFieldUpdateOperationsInput | string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AppEventUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: NullableStringFieldUpdateOperationsInput | string | null
    actorType?: EnumActorTypeFieldUpdateOperationsInput | $Enums.ActorType
    eventType?: EnumEventTypeFieldUpdateOperationsInput | $Enums.EventType
    entityType?: NullableStringFieldUpdateOperationsInput | string | null
    entityId?: NullableStringFieldUpdateOperationsInput | string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type DailyStatsCreateInput = {
    id?: string
    date: Date | string
    totalOrders?: number
    completedOrders?: number
    cancelledOrders?: number
    activeAgents?: number
    avgAssignmentTime?: number | null
    totalPayout?: number
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type DailyStatsUncheckedCreateInput = {
    id?: string
    date: Date | string
    totalOrders?: number
    completedOrders?: number
    cancelledOrders?: number
    activeAgents?: number
    avgAssignmentTime?: number | null
    totalPayout?: number
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type DailyStatsUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    totalOrders?: IntFieldUpdateOperationsInput | number
    completedOrders?: IntFieldUpdateOperationsInput | number
    cancelledOrders?: IntFieldUpdateOperationsInput | number
    activeAgents?: IntFieldUpdateOperationsInput | number
    avgAssignmentTime?: NullableFloatFieldUpdateOperationsInput | number | null
    totalPayout?: FloatFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type DailyStatsUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    totalOrders?: IntFieldUpdateOperationsInput | number
    completedOrders?: IntFieldUpdateOperationsInput | number
    cancelledOrders?: IntFieldUpdateOperationsInput | number
    activeAgents?: IntFieldUpdateOperationsInput | number
    avgAssignmentTime?: NullableFloatFieldUpdateOperationsInput | number | null
    totalPayout?: FloatFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type DailyStatsCreateManyInput = {
    id?: string
    date: Date | string
    totalOrders?: number
    completedOrders?: number
    cancelledOrders?: number
    activeAgents?: number
    avgAssignmentTime?: number | null
    totalPayout?: number
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type DailyStatsUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    totalOrders?: IntFieldUpdateOperationsInput | number
    completedOrders?: IntFieldUpdateOperationsInput | number
    cancelledOrders?: IntFieldUpdateOperationsInput | number
    activeAgents?: IntFieldUpdateOperationsInput | number
    avgAssignmentTime?: NullableFloatFieldUpdateOperationsInput | number | null
    totalPayout?: FloatFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type DailyStatsUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    totalOrders?: IntFieldUpdateOperationsInput | number
    completedOrders?: IntFieldUpdateOperationsInput | number
    cancelledOrders?: IntFieldUpdateOperationsInput | number
    activeAgents?: IntFieldUpdateOperationsInput | number
    avgAssignmentTime?: NullableFloatFieldUpdateOperationsInput | number | null
    totalPayout?: FloatFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PartnerDailyStatsCreateInput = {
    id?: string
    date: Date | string
    totalOrders?: number
    completedOrders?: number
    cancelledOrders?: number
    avgAssignmentTime?: number | null
    createdAt?: Date | string
    updatedAt?: Date | string
    partner: PartnerCreateNestedOneWithoutDailyStatsInput
  }

  export type PartnerDailyStatsUncheckedCreateInput = {
    id?: string
    partnerId: string
    date: Date | string
    totalOrders?: number
    completedOrders?: number
    cancelledOrders?: number
    avgAssignmentTime?: number | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type PartnerDailyStatsUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    totalOrders?: IntFieldUpdateOperationsInput | number
    completedOrders?: IntFieldUpdateOperationsInput | number
    cancelledOrders?: IntFieldUpdateOperationsInput | number
    avgAssignmentTime?: NullableFloatFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    partner?: PartnerUpdateOneRequiredWithoutDailyStatsNestedInput
  }

  export type PartnerDailyStatsUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    partnerId?: StringFieldUpdateOperationsInput | string
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    totalOrders?: IntFieldUpdateOperationsInput | number
    completedOrders?: IntFieldUpdateOperationsInput | number
    cancelledOrders?: IntFieldUpdateOperationsInput | number
    avgAssignmentTime?: NullableFloatFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PartnerDailyStatsCreateManyInput = {
    id?: string
    partnerId: string
    date: Date | string
    totalOrders?: number
    completedOrders?: number
    cancelledOrders?: number
    avgAssignmentTime?: number | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type PartnerDailyStatsUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    totalOrders?: IntFieldUpdateOperationsInput | number
    completedOrders?: IntFieldUpdateOperationsInput | number
    cancelledOrders?: IntFieldUpdateOperationsInput | number
    avgAssignmentTime?: NullableFloatFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PartnerDailyStatsUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    partnerId?: StringFieldUpdateOperationsInput | string
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    totalOrders?: IntFieldUpdateOperationsInput | number
    completedOrders?: IntFieldUpdateOperationsInput | number
    cancelledOrders?: IntFieldUpdateOperationsInput | number
    avgAssignmentTime?: NullableFloatFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PartnerRevenueCreateInput = {
    id?: string
    orderAmount: number
    deliveryFee: number
    platformFee: number
    netRevenue: number
    status?: string
    processedAt?: Date | string | null
    periodStart: Date | string
    periodEnd: Date | string
    periodType: string
    createdAt?: Date | string
    updatedAt?: Date | string
    partner: PartnerCreateNestedOneWithoutPartnerRevenuesInput
    order: OrderCreateNestedOneWithoutPartnerRevenueInput
  }

  export type PartnerRevenueUncheckedCreateInput = {
    id?: string
    partnerId: string
    orderId: string
    orderAmount: number
    deliveryFee: number
    platformFee: number
    netRevenue: number
    status?: string
    processedAt?: Date | string | null
    periodStart: Date | string
    periodEnd: Date | string
    periodType: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type PartnerRevenueUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    orderAmount?: FloatFieldUpdateOperationsInput | number
    deliveryFee?: FloatFieldUpdateOperationsInput | number
    platformFee?: FloatFieldUpdateOperationsInput | number
    netRevenue?: FloatFieldUpdateOperationsInput | number
    status?: StringFieldUpdateOperationsInput | string
    processedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    periodStart?: DateTimeFieldUpdateOperationsInput | Date | string
    periodEnd?: DateTimeFieldUpdateOperationsInput | Date | string
    periodType?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    partner?: PartnerUpdateOneRequiredWithoutPartnerRevenuesNestedInput
    order?: OrderUpdateOneRequiredWithoutPartnerRevenueNestedInput
  }

  export type PartnerRevenueUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    partnerId?: StringFieldUpdateOperationsInput | string
    orderId?: StringFieldUpdateOperationsInput | string
    orderAmount?: FloatFieldUpdateOperationsInput | number
    deliveryFee?: FloatFieldUpdateOperationsInput | number
    platformFee?: FloatFieldUpdateOperationsInput | number
    netRevenue?: FloatFieldUpdateOperationsInput | number
    status?: StringFieldUpdateOperationsInput | string
    processedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    periodStart?: DateTimeFieldUpdateOperationsInput | Date | string
    periodEnd?: DateTimeFieldUpdateOperationsInput | Date | string
    periodType?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PartnerRevenueCreateManyInput = {
    id?: string
    partnerId: string
    orderId: string
    orderAmount: number
    deliveryFee: number
    platformFee: number
    netRevenue: number
    status?: string
    processedAt?: Date | string | null
    periodStart: Date | string
    periodEnd: Date | string
    periodType: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type PartnerRevenueUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    orderAmount?: FloatFieldUpdateOperationsInput | number
    deliveryFee?: FloatFieldUpdateOperationsInput | number
    platformFee?: FloatFieldUpdateOperationsInput | number
    netRevenue?: FloatFieldUpdateOperationsInput | number
    status?: StringFieldUpdateOperationsInput | string
    processedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    periodStart?: DateTimeFieldUpdateOperationsInput | Date | string
    periodEnd?: DateTimeFieldUpdateOperationsInput | Date | string
    periodType?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PartnerRevenueUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    partnerId?: StringFieldUpdateOperationsInput | string
    orderId?: StringFieldUpdateOperationsInput | string
    orderAmount?: FloatFieldUpdateOperationsInput | number
    deliveryFee?: FloatFieldUpdateOperationsInput | number
    platformFee?: FloatFieldUpdateOperationsInput | number
    netRevenue?: FloatFieldUpdateOperationsInput | number
    status?: StringFieldUpdateOperationsInput | string
    processedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    periodStart?: DateTimeFieldUpdateOperationsInput | Date | string
    periodEnd?: DateTimeFieldUpdateOperationsInput | Date | string
    periodType?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PlatformRevenueCreateInput = {
    id?: string
    agentId?: string | null
    orderAmount: number
    platformFee: number
    agentPayout: number
    netRevenue: number
    revenueType: string
    status?: string
    processedAt?: Date | string | null
    periodStart: Date | string
    periodEnd: Date | string
    periodType: string
    createdAt?: Date | string
    updatedAt?: Date | string
    order: OrderCreateNestedOneWithoutPlatformRevenueInput
    partner: PartnerCreateNestedOneWithoutPlatformRevenuesInput
  }

  export type PlatformRevenueUncheckedCreateInput = {
    id?: string
    orderId: string
    partnerId: string
    agentId?: string | null
    orderAmount: number
    platformFee: number
    agentPayout: number
    netRevenue: number
    revenueType: string
    status?: string
    processedAt?: Date | string | null
    periodStart: Date | string
    periodEnd: Date | string
    periodType: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type PlatformRevenueUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    agentId?: NullableStringFieldUpdateOperationsInput | string | null
    orderAmount?: FloatFieldUpdateOperationsInput | number
    platformFee?: FloatFieldUpdateOperationsInput | number
    agentPayout?: FloatFieldUpdateOperationsInput | number
    netRevenue?: FloatFieldUpdateOperationsInput | number
    revenueType?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    processedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    periodStart?: DateTimeFieldUpdateOperationsInput | Date | string
    periodEnd?: DateTimeFieldUpdateOperationsInput | Date | string
    periodType?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    order?: OrderUpdateOneRequiredWithoutPlatformRevenueNestedInput
    partner?: PartnerUpdateOneRequiredWithoutPlatformRevenuesNestedInput
  }

  export type PlatformRevenueUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    orderId?: StringFieldUpdateOperationsInput | string
    partnerId?: StringFieldUpdateOperationsInput | string
    agentId?: NullableStringFieldUpdateOperationsInput | string | null
    orderAmount?: FloatFieldUpdateOperationsInput | number
    platformFee?: FloatFieldUpdateOperationsInput | number
    agentPayout?: FloatFieldUpdateOperationsInput | number
    netRevenue?: FloatFieldUpdateOperationsInput | number
    revenueType?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    processedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    periodStart?: DateTimeFieldUpdateOperationsInput | Date | string
    periodEnd?: DateTimeFieldUpdateOperationsInput | Date | string
    periodType?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PlatformRevenueCreateManyInput = {
    id?: string
    orderId: string
    partnerId: string
    agentId?: string | null
    orderAmount: number
    platformFee: number
    agentPayout: number
    netRevenue: number
    revenueType: string
    status?: string
    processedAt?: Date | string | null
    periodStart: Date | string
    periodEnd: Date | string
    periodType: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type PlatformRevenueUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    agentId?: NullableStringFieldUpdateOperationsInput | string | null
    orderAmount?: FloatFieldUpdateOperationsInput | number
    platformFee?: FloatFieldUpdateOperationsInput | number
    agentPayout?: FloatFieldUpdateOperationsInput | number
    netRevenue?: FloatFieldUpdateOperationsInput | number
    revenueType?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    processedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    periodStart?: DateTimeFieldUpdateOperationsInput | Date | string
    periodEnd?: DateTimeFieldUpdateOperationsInput | Date | string
    periodType?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PlatformRevenueUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    orderId?: StringFieldUpdateOperationsInput | string
    partnerId?: StringFieldUpdateOperationsInput | string
    agentId?: NullableStringFieldUpdateOperationsInput | string | null
    orderAmount?: FloatFieldUpdateOperationsInput | number
    platformFee?: FloatFieldUpdateOperationsInput | number
    agentPayout?: FloatFieldUpdateOperationsInput | number
    netRevenue?: FloatFieldUpdateOperationsInput | number
    revenueType?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    processedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    periodStart?: DateTimeFieldUpdateOperationsInput | Date | string
    periodEnd?: DateTimeFieldUpdateOperationsInput | Date | string
    periodType?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AdminWalletCreateInput = {
    id?: string
    balance?: number
    totalDeposited?: number
    totalPaidOut?: number
    lastUpdated?: Date | string
    createdAt?: Date | string
    transactions?: WalletTransactionCreateNestedManyWithoutAdminWalletInput
  }

  export type AdminWalletUncheckedCreateInput = {
    id?: string
    balance?: number
    totalDeposited?: number
    totalPaidOut?: number
    lastUpdated?: Date | string
    createdAt?: Date | string
    transactions?: WalletTransactionUncheckedCreateNestedManyWithoutAdminWalletInput
  }

  export type AdminWalletUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    balance?: FloatFieldUpdateOperationsInput | number
    totalDeposited?: FloatFieldUpdateOperationsInput | number
    totalPaidOut?: FloatFieldUpdateOperationsInput | number
    lastUpdated?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    transactions?: WalletTransactionUpdateManyWithoutAdminWalletNestedInput
  }

  export type AdminWalletUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    balance?: FloatFieldUpdateOperationsInput | number
    totalDeposited?: FloatFieldUpdateOperationsInput | number
    totalPaidOut?: FloatFieldUpdateOperationsInput | number
    lastUpdated?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    transactions?: WalletTransactionUncheckedUpdateManyWithoutAdminWalletNestedInput
  }

  export type AdminWalletCreateManyInput = {
    id?: string
    balance?: number
    totalDeposited?: number
    totalPaidOut?: number
    lastUpdated?: Date | string
    createdAt?: Date | string
  }

  export type AdminWalletUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    balance?: FloatFieldUpdateOperationsInput | number
    totalDeposited?: FloatFieldUpdateOperationsInput | number
    totalPaidOut?: FloatFieldUpdateOperationsInput | number
    lastUpdated?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AdminWalletUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    balance?: FloatFieldUpdateOperationsInput | number
    totalDeposited?: FloatFieldUpdateOperationsInput | number
    totalPaidOut?: FloatFieldUpdateOperationsInput | number
    lastUpdated?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AgentWalletCreateInput = {
    id?: string
    balance?: number
    totalEarned?: number
    totalPaidOut?: number
    lastPayoutDate?: Date | string | null
    nextPayoutDate?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    agent: AgentCreateNestedOneWithoutWalletInput
    transactions?: WalletTransactionCreateNestedManyWithoutAgentWalletInput
    payouts?: WalletPayoutCreateNestedManyWithoutAgentWalletInput
  }

  export type AgentWalletUncheckedCreateInput = {
    id?: string
    agentId: string
    balance?: number
    totalEarned?: number
    totalPaidOut?: number
    lastPayoutDate?: Date | string | null
    nextPayoutDate?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    transactions?: WalletTransactionUncheckedCreateNestedManyWithoutAgentWalletInput
    payouts?: WalletPayoutUncheckedCreateNestedManyWithoutAgentWalletInput
  }

  export type AgentWalletUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    balance?: FloatFieldUpdateOperationsInput | number
    totalEarned?: FloatFieldUpdateOperationsInput | number
    totalPaidOut?: FloatFieldUpdateOperationsInput | number
    lastPayoutDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    nextPayoutDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    agent?: AgentUpdateOneRequiredWithoutWalletNestedInput
    transactions?: WalletTransactionUpdateManyWithoutAgentWalletNestedInput
    payouts?: WalletPayoutUpdateManyWithoutAgentWalletNestedInput
  }

  export type AgentWalletUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    agentId?: StringFieldUpdateOperationsInput | string
    balance?: FloatFieldUpdateOperationsInput | number
    totalEarned?: FloatFieldUpdateOperationsInput | number
    totalPaidOut?: FloatFieldUpdateOperationsInput | number
    lastPayoutDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    nextPayoutDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    transactions?: WalletTransactionUncheckedUpdateManyWithoutAgentWalletNestedInput
    payouts?: WalletPayoutUncheckedUpdateManyWithoutAgentWalletNestedInput
  }

  export type AgentWalletCreateManyInput = {
    id?: string
    agentId: string
    balance?: number
    totalEarned?: number
    totalPaidOut?: number
    lastPayoutDate?: Date | string | null
    nextPayoutDate?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type AgentWalletUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    balance?: FloatFieldUpdateOperationsInput | number
    totalEarned?: FloatFieldUpdateOperationsInput | number
    totalPaidOut?: FloatFieldUpdateOperationsInput | number
    lastPayoutDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    nextPayoutDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AgentWalletUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    agentId?: StringFieldUpdateOperationsInput | string
    balance?: FloatFieldUpdateOperationsInput | number
    totalEarned?: FloatFieldUpdateOperationsInput | number
    totalPaidOut?: FloatFieldUpdateOperationsInput | number
    lastPayoutDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    nextPayoutDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type WalletTransactionCreateInput = {
    id?: string
    walletType: string
    amount: number
    type: string
    description?: string | null
    balanceBefore: number
    balanceAfter: number
    status?: string
    createdAt?: Date | string
    adminWallet?: AdminWalletCreateNestedOneWithoutTransactionsInput
    agentWallet?: AgentWalletCreateNestedOneWithoutTransactionsInput
    order?: OrderCreateNestedOneWithoutWalletTransactionsInput
  }

  export type WalletTransactionUncheckedCreateInput = {
    id?: string
    walletType: string
    adminWalletId?: string | null
    agentWalletId?: string | null
    orderId?: string | null
    amount: number
    type: string
    description?: string | null
    balanceBefore: number
    balanceAfter: number
    status?: string
    createdAt?: Date | string
  }

  export type WalletTransactionUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    walletType?: StringFieldUpdateOperationsInput | string
    amount?: FloatFieldUpdateOperationsInput | number
    type?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    balanceBefore?: FloatFieldUpdateOperationsInput | number
    balanceAfter?: FloatFieldUpdateOperationsInput | number
    status?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    adminWallet?: AdminWalletUpdateOneWithoutTransactionsNestedInput
    agentWallet?: AgentWalletUpdateOneWithoutTransactionsNestedInput
    order?: OrderUpdateOneWithoutWalletTransactionsNestedInput
  }

  export type WalletTransactionUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    walletType?: StringFieldUpdateOperationsInput | string
    adminWalletId?: NullableStringFieldUpdateOperationsInput | string | null
    agentWalletId?: NullableStringFieldUpdateOperationsInput | string | null
    orderId?: NullableStringFieldUpdateOperationsInput | string | null
    amount?: FloatFieldUpdateOperationsInput | number
    type?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    balanceBefore?: FloatFieldUpdateOperationsInput | number
    balanceAfter?: FloatFieldUpdateOperationsInput | number
    status?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type WalletTransactionCreateManyInput = {
    id?: string
    walletType: string
    adminWalletId?: string | null
    agentWalletId?: string | null
    orderId?: string | null
    amount: number
    type: string
    description?: string | null
    balanceBefore: number
    balanceAfter: number
    status?: string
    createdAt?: Date | string
  }

  export type WalletTransactionUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    walletType?: StringFieldUpdateOperationsInput | string
    amount?: FloatFieldUpdateOperationsInput | number
    type?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    balanceBefore?: FloatFieldUpdateOperationsInput | number
    balanceAfter?: FloatFieldUpdateOperationsInput | number
    status?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type WalletTransactionUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    walletType?: StringFieldUpdateOperationsInput | string
    adminWalletId?: NullableStringFieldUpdateOperationsInput | string | null
    agentWalletId?: NullableStringFieldUpdateOperationsInput | string | null
    orderId?: NullableStringFieldUpdateOperationsInput | string | null
    amount?: FloatFieldUpdateOperationsInput | number
    type?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    balanceBefore?: FloatFieldUpdateOperationsInput | number
    balanceAfter?: FloatFieldUpdateOperationsInput | number
    status?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type WalletPayoutCreateInput = {
    id?: string
    amount: number
    periodStart: Date | string
    periodEnd: Date | string
    status?: string
    paymentMethod?: string | null
    transactionId?: string | null
    bankAccount?: string | null
    upiId?: string | null
    processedAt?: Date | string | null
    failedAt?: Date | string | null
    failureReason?: string | null
    notes?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    agentWallet: AgentWalletCreateNestedOneWithoutPayoutsInput
    agent: AgentCreateNestedOneWithoutWalletPayoutsInput
  }

  export type WalletPayoutUncheckedCreateInput = {
    id?: string
    agentWalletId: string
    agentId: string
    amount: number
    periodStart: Date | string
    periodEnd: Date | string
    status?: string
    paymentMethod?: string | null
    transactionId?: string | null
    bankAccount?: string | null
    upiId?: string | null
    processedAt?: Date | string | null
    failedAt?: Date | string | null
    failureReason?: string | null
    notes?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type WalletPayoutUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    amount?: FloatFieldUpdateOperationsInput | number
    periodStart?: DateTimeFieldUpdateOperationsInput | Date | string
    periodEnd?: DateTimeFieldUpdateOperationsInput | Date | string
    status?: StringFieldUpdateOperationsInput | string
    paymentMethod?: NullableStringFieldUpdateOperationsInput | string | null
    transactionId?: NullableStringFieldUpdateOperationsInput | string | null
    bankAccount?: NullableStringFieldUpdateOperationsInput | string | null
    upiId?: NullableStringFieldUpdateOperationsInput | string | null
    processedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    failedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    failureReason?: NullableStringFieldUpdateOperationsInput | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    agentWallet?: AgentWalletUpdateOneRequiredWithoutPayoutsNestedInput
    agent?: AgentUpdateOneRequiredWithoutWalletPayoutsNestedInput
  }

  export type WalletPayoutUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    agentWalletId?: StringFieldUpdateOperationsInput | string
    agentId?: StringFieldUpdateOperationsInput | string
    amount?: FloatFieldUpdateOperationsInput | number
    periodStart?: DateTimeFieldUpdateOperationsInput | Date | string
    periodEnd?: DateTimeFieldUpdateOperationsInput | Date | string
    status?: StringFieldUpdateOperationsInput | string
    paymentMethod?: NullableStringFieldUpdateOperationsInput | string | null
    transactionId?: NullableStringFieldUpdateOperationsInput | string | null
    bankAccount?: NullableStringFieldUpdateOperationsInput | string | null
    upiId?: NullableStringFieldUpdateOperationsInput | string | null
    processedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    failedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    failureReason?: NullableStringFieldUpdateOperationsInput | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type WalletPayoutCreateManyInput = {
    id?: string
    agentWalletId: string
    agentId: string
    amount: number
    periodStart: Date | string
    periodEnd: Date | string
    status?: string
    paymentMethod?: string | null
    transactionId?: string | null
    bankAccount?: string | null
    upiId?: string | null
    processedAt?: Date | string | null
    failedAt?: Date | string | null
    failureReason?: string | null
    notes?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type WalletPayoutUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    amount?: FloatFieldUpdateOperationsInput | number
    periodStart?: DateTimeFieldUpdateOperationsInput | Date | string
    periodEnd?: DateTimeFieldUpdateOperationsInput | Date | string
    status?: StringFieldUpdateOperationsInput | string
    paymentMethod?: NullableStringFieldUpdateOperationsInput | string | null
    transactionId?: NullableStringFieldUpdateOperationsInput | string | null
    bankAccount?: NullableStringFieldUpdateOperationsInput | string | null
    upiId?: NullableStringFieldUpdateOperationsInput | string | null
    processedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    failedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    failureReason?: NullableStringFieldUpdateOperationsInput | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type WalletPayoutUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    agentWalletId?: StringFieldUpdateOperationsInput | string
    agentId?: StringFieldUpdateOperationsInput | string
    amount?: FloatFieldUpdateOperationsInput | number
    periodStart?: DateTimeFieldUpdateOperationsInput | Date | string
    periodEnd?: DateTimeFieldUpdateOperationsInput | Date | string
    status?: StringFieldUpdateOperationsInput | string
    paymentMethod?: NullableStringFieldUpdateOperationsInput | string | null
    transactionId?: NullableStringFieldUpdateOperationsInput | string | null
    bankAccount?: NullableStringFieldUpdateOperationsInput | string | null
    upiId?: NullableStringFieldUpdateOperationsInput | string | null
    processedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    failedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    failureReason?: NullableStringFieldUpdateOperationsInput | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type NotificationCreateInput = {
    id?: string
    title: string
    message: string
    type: string
    isRead?: boolean
    link?: string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    readAt?: Date | string | null
    user: UserCreateNestedOneWithoutUserNotificationsInput
  }

  export type NotificationUncheckedCreateInput = {
    id?: string
    userId: string
    title: string
    message: string
    type: string
    isRead?: boolean
    link?: string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    readAt?: Date | string | null
  }

  export type NotificationUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    message?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    isRead?: BoolFieldUpdateOperationsInput | boolean
    link?: NullableStringFieldUpdateOperationsInput | string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    readAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    user?: UserUpdateOneRequiredWithoutUserNotificationsNestedInput
  }

  export type NotificationUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    message?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    isRead?: BoolFieldUpdateOperationsInput | boolean
    link?: NullableStringFieldUpdateOperationsInput | string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    readAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type NotificationCreateManyInput = {
    id?: string
    userId: string
    title: string
    message: string
    type: string
    isRead?: boolean
    link?: string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    readAt?: Date | string | null
  }

  export type NotificationUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    message?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    isRead?: BoolFieldUpdateOperationsInput | boolean
    link?: NullableStringFieldUpdateOperationsInput | string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    readAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type NotificationUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    message?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    isRead?: BoolFieldUpdateOperationsInput | boolean
    link?: NullableStringFieldUpdateOperationsInput | string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    readAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type AgentRatingCreateInput = {
    id?: string
    rating: number
    comment?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    order: OrderCreateNestedOneWithoutRatingInput
    agent: AgentCreateNestedOneWithoutRatingsInput
    partner: PartnerCreateNestedOneWithoutAgentRatingsInput
  }

  export type AgentRatingUncheckedCreateInput = {
    id?: string
    orderId: string
    agentId: string
    partnerId: string
    rating: number
    comment?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type AgentRatingUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    rating?: IntFieldUpdateOperationsInput | number
    comment?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    order?: OrderUpdateOneRequiredWithoutRatingNestedInput
    agent?: AgentUpdateOneRequiredWithoutRatingsNestedInput
    partner?: PartnerUpdateOneRequiredWithoutAgentRatingsNestedInput
  }

  export type AgentRatingUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    orderId?: StringFieldUpdateOperationsInput | string
    agentId?: StringFieldUpdateOperationsInput | string
    partnerId?: StringFieldUpdateOperationsInput | string
    rating?: IntFieldUpdateOperationsInput | number
    comment?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AgentRatingCreateManyInput = {
    id?: string
    orderId: string
    agentId: string
    partnerId: string
    rating: number
    comment?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type AgentRatingUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    rating?: IntFieldUpdateOperationsInput | number
    comment?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AgentRatingUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    orderId?: StringFieldUpdateOperationsInput | string
    agentId?: StringFieldUpdateOperationsInput | string
    partnerId?: StringFieldUpdateOperationsInput | string
    rating?: IntFieldUpdateOperationsInput | number
    comment?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PaymentCreateInput = {
    id?: string
    amount: number
    paymentType: string
    status?: string
    processedAt?: Date | string | null
    paymentMethod?: string | null
    transactionId?: string | null
    notes?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    agent: AgentCreateNestedOneWithoutPaymentsInput
    order: OrderCreateNestedOneWithoutPaymentsInput
  }

  export type PaymentUncheckedCreateInput = {
    id?: string
    agentId: string
    orderId: string
    amount: number
    paymentType: string
    status?: string
    processedAt?: Date | string | null
    paymentMethod?: string | null
    transactionId?: string | null
    notes?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type PaymentUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    amount?: FloatFieldUpdateOperationsInput | number
    paymentType?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    processedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    paymentMethod?: NullableStringFieldUpdateOperationsInput | string | null
    transactionId?: NullableStringFieldUpdateOperationsInput | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    agent?: AgentUpdateOneRequiredWithoutPaymentsNestedInput
    order?: OrderUpdateOneRequiredWithoutPaymentsNestedInput
  }

  export type PaymentUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    agentId?: StringFieldUpdateOperationsInput | string
    orderId?: StringFieldUpdateOperationsInput | string
    amount?: FloatFieldUpdateOperationsInput | number
    paymentType?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    processedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    paymentMethod?: NullableStringFieldUpdateOperationsInput | string | null
    transactionId?: NullableStringFieldUpdateOperationsInput | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PaymentCreateManyInput = {
    id?: string
    agentId: string
    orderId: string
    amount: number
    paymentType: string
    status?: string
    processedAt?: Date | string | null
    paymentMethod?: string | null
    transactionId?: string | null
    notes?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type PaymentUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    amount?: FloatFieldUpdateOperationsInput | number
    paymentType?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    processedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    paymentMethod?: NullableStringFieldUpdateOperationsInput | string | null
    transactionId?: NullableStringFieldUpdateOperationsInput | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PaymentUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    agentId?: StringFieldUpdateOperationsInput | string
    orderId?: StringFieldUpdateOperationsInput | string
    amount?: FloatFieldUpdateOperationsInput | number
    paymentType?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    processedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    paymentMethod?: NullableStringFieldUpdateOperationsInput | string | null
    transactionId?: NullableStringFieldUpdateOperationsInput | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PayrollCreateInput = {
    id?: string
    periodStart: Date | string
    periodEnd: Date | string
    periodType: string
    totalEarnings?: number
    totalOrders?: number
    basePay?: number
    bonuses?: number
    deductions?: number
    netPay?: number
    status?: string
    processedAt?: Date | string | null
    paidAt?: Date | string | null
    paymentMethod?: string | null
    transactionId?: string | null
    notes?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    agent: AgentCreateNestedOneWithoutPayrollsInput
  }

  export type PayrollUncheckedCreateInput = {
    id?: string
    agentId: string
    periodStart: Date | string
    periodEnd: Date | string
    periodType: string
    totalEarnings?: number
    totalOrders?: number
    basePay?: number
    bonuses?: number
    deductions?: number
    netPay?: number
    status?: string
    processedAt?: Date | string | null
    paidAt?: Date | string | null
    paymentMethod?: string | null
    transactionId?: string | null
    notes?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type PayrollUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    periodStart?: DateTimeFieldUpdateOperationsInput | Date | string
    periodEnd?: DateTimeFieldUpdateOperationsInput | Date | string
    periodType?: StringFieldUpdateOperationsInput | string
    totalEarnings?: FloatFieldUpdateOperationsInput | number
    totalOrders?: IntFieldUpdateOperationsInput | number
    basePay?: FloatFieldUpdateOperationsInput | number
    bonuses?: FloatFieldUpdateOperationsInput | number
    deductions?: FloatFieldUpdateOperationsInput | number
    netPay?: FloatFieldUpdateOperationsInput | number
    status?: StringFieldUpdateOperationsInput | string
    processedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    paidAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    paymentMethod?: NullableStringFieldUpdateOperationsInput | string | null
    transactionId?: NullableStringFieldUpdateOperationsInput | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    agent?: AgentUpdateOneRequiredWithoutPayrollsNestedInput
  }

  export type PayrollUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    agentId?: StringFieldUpdateOperationsInput | string
    periodStart?: DateTimeFieldUpdateOperationsInput | Date | string
    periodEnd?: DateTimeFieldUpdateOperationsInput | Date | string
    periodType?: StringFieldUpdateOperationsInput | string
    totalEarnings?: FloatFieldUpdateOperationsInput | number
    totalOrders?: IntFieldUpdateOperationsInput | number
    basePay?: FloatFieldUpdateOperationsInput | number
    bonuses?: FloatFieldUpdateOperationsInput | number
    deductions?: FloatFieldUpdateOperationsInput | number
    netPay?: FloatFieldUpdateOperationsInput | number
    status?: StringFieldUpdateOperationsInput | string
    processedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    paidAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    paymentMethod?: NullableStringFieldUpdateOperationsInput | string | null
    transactionId?: NullableStringFieldUpdateOperationsInput | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PayrollCreateManyInput = {
    id?: string
    agentId: string
    periodStart: Date | string
    periodEnd: Date | string
    periodType: string
    totalEarnings?: number
    totalOrders?: number
    basePay?: number
    bonuses?: number
    deductions?: number
    netPay?: number
    status?: string
    processedAt?: Date | string | null
    paidAt?: Date | string | null
    paymentMethod?: string | null
    transactionId?: string | null
    notes?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type PayrollUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    periodStart?: DateTimeFieldUpdateOperationsInput | Date | string
    periodEnd?: DateTimeFieldUpdateOperationsInput | Date | string
    periodType?: StringFieldUpdateOperationsInput | string
    totalEarnings?: FloatFieldUpdateOperationsInput | number
    totalOrders?: IntFieldUpdateOperationsInput | number
    basePay?: FloatFieldUpdateOperationsInput | number
    bonuses?: FloatFieldUpdateOperationsInput | number
    deductions?: FloatFieldUpdateOperationsInput | number
    netPay?: FloatFieldUpdateOperationsInput | number
    status?: StringFieldUpdateOperationsInput | string
    processedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    paidAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    paymentMethod?: NullableStringFieldUpdateOperationsInput | string | null
    transactionId?: NullableStringFieldUpdateOperationsInput | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PayrollUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    agentId?: StringFieldUpdateOperationsInput | string
    periodStart?: DateTimeFieldUpdateOperationsInput | Date | string
    periodEnd?: DateTimeFieldUpdateOperationsInput | Date | string
    periodType?: StringFieldUpdateOperationsInput | string
    totalEarnings?: FloatFieldUpdateOperationsInput | number
    totalOrders?: IntFieldUpdateOperationsInput | number
    basePay?: FloatFieldUpdateOperationsInput | number
    bonuses?: FloatFieldUpdateOperationsInput | number
    deductions?: FloatFieldUpdateOperationsInput | number
    netPay?: FloatFieldUpdateOperationsInput | number
    status?: StringFieldUpdateOperationsInput | string
    processedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    paidAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    paymentMethod?: NullableStringFieldUpdateOperationsInput | string | null
    transactionId?: NullableStringFieldUpdateOperationsInput | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AgentScheduleCreateInput = {
    id?: string
    date: Date | string
    startTime?: string | null
    endTime?: string | null
    isAvailable?: boolean
    notes?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    agent: AgentCreateNestedOneWithoutSchedulesInput
  }

  export type AgentScheduleUncheckedCreateInput = {
    id?: string
    agentId: string
    date: Date | string
    startTime?: string | null
    endTime?: string | null
    isAvailable?: boolean
    notes?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type AgentScheduleUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    startTime?: NullableStringFieldUpdateOperationsInput | string | null
    endTime?: NullableStringFieldUpdateOperationsInput | string | null
    isAvailable?: BoolFieldUpdateOperationsInput | boolean
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    agent?: AgentUpdateOneRequiredWithoutSchedulesNestedInput
  }

  export type AgentScheduleUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    agentId?: StringFieldUpdateOperationsInput | string
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    startTime?: NullableStringFieldUpdateOperationsInput | string | null
    endTime?: NullableStringFieldUpdateOperationsInput | string | null
    isAvailable?: BoolFieldUpdateOperationsInput | boolean
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AgentScheduleCreateManyInput = {
    id?: string
    agentId: string
    date: Date | string
    startTime?: string | null
    endTime?: string | null
    isAvailable?: boolean
    notes?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type AgentScheduleUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    startTime?: NullableStringFieldUpdateOperationsInput | string | null
    endTime?: NullableStringFieldUpdateOperationsInput | string | null
    isAvailable?: BoolFieldUpdateOperationsInput | boolean
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AgentScheduleUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    agentId?: StringFieldUpdateOperationsInput | string
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    startTime?: NullableStringFieldUpdateOperationsInput | string | null
    endTime?: NullableStringFieldUpdateOperationsInput | string | null
    isAvailable?: BoolFieldUpdateOperationsInput | boolean
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PayStructureCreateInput = {
    id?: string
    name: string
    payType: string
    baseRate?: number | null
    commissionRate?: number | null
    minGuarantee?: number | null
    maxLimit?: number | null
    bonusRules?: NullableJsonNullValueInput | InputJsonValue
    deductionRules?: NullableJsonNullValueInput | InputJsonValue
    isActive?: boolean
    effectiveFrom?: Date | string
    effectiveTo?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type PayStructureUncheckedCreateInput = {
    id?: string
    name: string
    payType: string
    baseRate?: number | null
    commissionRate?: number | null
    minGuarantee?: number | null
    maxLimit?: number | null
    bonusRules?: NullableJsonNullValueInput | InputJsonValue
    deductionRules?: NullableJsonNullValueInput | InputJsonValue
    isActive?: boolean
    effectiveFrom?: Date | string
    effectiveTo?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type PayStructureUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    payType?: StringFieldUpdateOperationsInput | string
    baseRate?: NullableFloatFieldUpdateOperationsInput | number | null
    commissionRate?: NullableFloatFieldUpdateOperationsInput | number | null
    minGuarantee?: NullableFloatFieldUpdateOperationsInput | number | null
    maxLimit?: NullableFloatFieldUpdateOperationsInput | number | null
    bonusRules?: NullableJsonNullValueInput | InputJsonValue
    deductionRules?: NullableJsonNullValueInput | InputJsonValue
    isActive?: BoolFieldUpdateOperationsInput | boolean
    effectiveFrom?: DateTimeFieldUpdateOperationsInput | Date | string
    effectiveTo?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PayStructureUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    payType?: StringFieldUpdateOperationsInput | string
    baseRate?: NullableFloatFieldUpdateOperationsInput | number | null
    commissionRate?: NullableFloatFieldUpdateOperationsInput | number | null
    minGuarantee?: NullableFloatFieldUpdateOperationsInput | number | null
    maxLimit?: NullableFloatFieldUpdateOperationsInput | number | null
    bonusRules?: NullableJsonNullValueInput | InputJsonValue
    deductionRules?: NullableJsonNullValueInput | InputJsonValue
    isActive?: BoolFieldUpdateOperationsInput | boolean
    effectiveFrom?: DateTimeFieldUpdateOperationsInput | Date | string
    effectiveTo?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PayStructureCreateManyInput = {
    id?: string
    name: string
    payType: string
    baseRate?: number | null
    commissionRate?: number | null
    minGuarantee?: number | null
    maxLimit?: number | null
    bonusRules?: NullableJsonNullValueInput | InputJsonValue
    deductionRules?: NullableJsonNullValueInput | InputJsonValue
    isActive?: boolean
    effectiveFrom?: Date | string
    effectiveTo?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type PayStructureUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    payType?: StringFieldUpdateOperationsInput | string
    baseRate?: NullableFloatFieldUpdateOperationsInput | number | null
    commissionRate?: NullableFloatFieldUpdateOperationsInput | number | null
    minGuarantee?: NullableFloatFieldUpdateOperationsInput | number | null
    maxLimit?: NullableFloatFieldUpdateOperationsInput | number | null
    bonusRules?: NullableJsonNullValueInput | InputJsonValue
    deductionRules?: NullableJsonNullValueInput | InputJsonValue
    isActive?: BoolFieldUpdateOperationsInput | boolean
    effectiveFrom?: DateTimeFieldUpdateOperationsInput | Date | string
    effectiveTo?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PayStructureUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    payType?: StringFieldUpdateOperationsInput | string
    baseRate?: NullableFloatFieldUpdateOperationsInput | number | null
    commissionRate?: NullableFloatFieldUpdateOperationsInput | number | null
    minGuarantee?: NullableFloatFieldUpdateOperationsInput | number | null
    maxLimit?: NullableFloatFieldUpdateOperationsInput | number | null
    bonusRules?: NullableJsonNullValueInput | InputJsonValue
    deductionRules?: NullableJsonNullValueInput | InputJsonValue
    isActive?: BoolFieldUpdateOperationsInput | boolean
    effectiveFrom?: DateTimeFieldUpdateOperationsInput | Date | string
    effectiveTo?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type StringFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[] | ListStringFieldRefInput<$PrismaModel>
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel>
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    mode?: QueryMode
    not?: NestedStringFilter<$PrismaModel> | string
  }

  export type EnumUserRoleFilter<$PrismaModel = never> = {
    equals?: $Enums.UserRole | EnumUserRoleFieldRefInput<$PrismaModel>
    in?: $Enums.UserRole[] | ListEnumUserRoleFieldRefInput<$PrismaModel>
    notIn?: $Enums.UserRole[] | ListEnumUserRoleFieldRefInput<$PrismaModel>
    not?: NestedEnumUserRoleFilter<$PrismaModel> | $Enums.UserRole
  }

  export type DateTimeNullableFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel> | null
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeNullableFilter<$PrismaModel> | Date | string | null
  }

  export type BoolFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel>
    not?: NestedBoolFilter<$PrismaModel> | boolean
  }

  export type StringNullableFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    mode?: QueryMode
    not?: NestedStringNullableFilter<$PrismaModel> | string | null
  }

  export type DateTimeFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeFilter<$PrismaModel> | Date | string
  }

  export type AgentNullableScalarRelationFilter = {
    is?: AgentWhereInput | null
    isNot?: AgentWhereInput | null
  }

  export type PartnerNullableScalarRelationFilter = {
    is?: PartnerWhereInput | null
    isNot?: PartnerWhereInput | null
  }

  export type NotificationTokenListRelationFilter = {
    every?: NotificationTokenWhereInput
    some?: NotificationTokenWhereInput
    none?: NotificationTokenWhereInput
  }

  export type NotificationListRelationFilter = {
    every?: NotificationWhereInput
    some?: NotificationWhereInput
    none?: NotificationWhereInput
  }

  export type SupportTicketListRelationFilter = {
    every?: SupportTicketWhereInput
    some?: SupportTicketWhereInput
    none?: SupportTicketWhereInput
  }

  export type SortOrderInput = {
    sort: SortOrder
    nulls?: NullsOrder
  }

  export type NotificationTokenOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type NotificationOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type SupportTicketOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type UserCountOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    email?: SortOrder
    phone?: SortOrder
    passwordHash?: SortOrder
    role?: SortOrder
    emailVerified?: SortOrder
    phoneVerified?: SortOrder
    profilePicture?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type UserMaxOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    email?: SortOrder
    phone?: SortOrder
    passwordHash?: SortOrder
    role?: SortOrder
    emailVerified?: SortOrder
    phoneVerified?: SortOrder
    profilePicture?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type UserMinOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    email?: SortOrder
    phone?: SortOrder
    passwordHash?: SortOrder
    role?: SortOrder
    emailVerified?: SortOrder
    phoneVerified?: SortOrder
    profilePicture?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type StringWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[] | ListStringFieldRefInput<$PrismaModel>
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel>
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    mode?: QueryMode
    not?: NestedStringWithAggregatesFilter<$PrismaModel> | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedStringFilter<$PrismaModel>
    _max?: NestedStringFilter<$PrismaModel>
  }

  export type EnumUserRoleWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.UserRole | EnumUserRoleFieldRefInput<$PrismaModel>
    in?: $Enums.UserRole[] | ListEnumUserRoleFieldRefInput<$PrismaModel>
    notIn?: $Enums.UserRole[] | ListEnumUserRoleFieldRefInput<$PrismaModel>
    not?: NestedEnumUserRoleWithAggregatesFilter<$PrismaModel> | $Enums.UserRole
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumUserRoleFilter<$PrismaModel>
    _max?: NestedEnumUserRoleFilter<$PrismaModel>
  }

  export type DateTimeNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel> | null
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeNullableWithAggregatesFilter<$PrismaModel> | Date | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedDateTimeNullableFilter<$PrismaModel>
    _max?: NestedDateTimeNullableFilter<$PrismaModel>
  }

  export type BoolWithAggregatesFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel>
    not?: NestedBoolWithAggregatesFilter<$PrismaModel> | boolean
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedBoolFilter<$PrismaModel>
    _max?: NestedBoolFilter<$PrismaModel>
  }

  export type StringNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    mode?: QueryMode
    not?: NestedStringNullableWithAggregatesFilter<$PrismaModel> | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedStringNullableFilter<$PrismaModel>
    _max?: NestedStringNullableFilter<$PrismaModel>
  }

  export type DateTimeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeWithAggregatesFilter<$PrismaModel> | Date | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedDateTimeFilter<$PrismaModel>
    _max?: NestedDateTimeFilter<$PrismaModel>
  }

  export type EnumVehicleTypeFilter<$PrismaModel = never> = {
    equals?: $Enums.VehicleType | EnumVehicleTypeFieldRefInput<$PrismaModel>
    in?: $Enums.VehicleType[] | ListEnumVehicleTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.VehicleType[] | ListEnumVehicleTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumVehicleTypeFilter<$PrismaModel> | $Enums.VehicleType
  }

  export type EnumAgentStatusFilter<$PrismaModel = never> = {
    equals?: $Enums.AgentStatus | EnumAgentStatusFieldRefInput<$PrismaModel>
    in?: $Enums.AgentStatus[] | ListEnumAgentStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.AgentStatus[] | ListEnumAgentStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumAgentStatusFilter<$PrismaModel> | $Enums.AgentStatus
  }

  export type FloatNullableFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel> | null
    in?: number[] | ListFloatFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListFloatFieldRefInput<$PrismaModel> | null
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatNullableFilter<$PrismaModel> | number | null
  }

  export type IntFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[] | ListIntFieldRefInput<$PrismaModel>
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel>
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntFilter<$PrismaModel> | number
  }

  export type FloatFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel>
    in?: number[] | ListFloatFieldRefInput<$PrismaModel>
    notIn?: number[] | ListFloatFieldRefInput<$PrismaModel>
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatFilter<$PrismaModel> | number
  }

  export type UserScalarRelationFilter = {
    is?: UserWhereInput
    isNot?: UserWhereInput
  }

  export type OrderListRelationFilter = {
    every?: OrderWhereInput
    some?: OrderWhereInput
    none?: OrderWhereInput
  }

  export type OrderNullableScalarRelationFilter = {
    is?: OrderWhereInput | null
    isNot?: OrderWhereInput | null
  }

  export type AgentDocumentListRelationFilter = {
    every?: AgentDocumentWhereInput
    some?: AgentDocumentWhereInput
    none?: AgentDocumentWhereInput
  }

  export type AgentLocationListRelationFilter = {
    every?: AgentLocationWhereInput
    some?: AgentLocationWhereInput
    none?: AgentLocationWhereInput
  }

  export type AgentRatingListRelationFilter = {
    every?: AgentRatingWhereInput
    some?: AgentRatingWhereInput
    none?: AgentRatingWhereInput
  }

  export type AgentWalletNullableScalarRelationFilter = {
    is?: AgentWalletWhereInput | null
    isNot?: AgentWalletWhereInput | null
  }

  export type WalletPayoutListRelationFilter = {
    every?: WalletPayoutWhereInput
    some?: WalletPayoutWhereInput
    none?: WalletPayoutWhereInput
  }

  export type PaymentListRelationFilter = {
    every?: PaymentWhereInput
    some?: PaymentWhereInput
    none?: PaymentWhereInput
  }

  export type PayrollListRelationFilter = {
    every?: PayrollWhereInput
    some?: PayrollWhereInput
    none?: PayrollWhereInput
  }

  export type AgentScheduleListRelationFilter = {
    every?: AgentScheduleWhereInput
    some?: AgentScheduleWhereInput
    none?: AgentScheduleWhereInput
  }

  export type OrderOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type AgentDocumentOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type AgentLocationOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type AgentRatingOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type WalletPayoutOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type PaymentOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type PayrollOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type AgentScheduleOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type AgentCountOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    vehicleType?: SortOrder
    status?: SortOrder
    rating?: SortOrder
    totalOrders?: SortOrder
    completedOrders?: SortOrder
    cancelledOrders?: SortOrder
    acceptanceRate?: SortOrder
    currentOrderId?: SortOrder
    isApproved?: SortOrder
    isBlocked?: SortOrder
    blockedReason?: SortOrder
    city?: SortOrder
    state?: SortOrder
    pincode?: SortOrder
    lastOnlineAt?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type AgentAvgOrderByAggregateInput = {
    rating?: SortOrder
    totalOrders?: SortOrder
    completedOrders?: SortOrder
    cancelledOrders?: SortOrder
    acceptanceRate?: SortOrder
  }

  export type AgentMaxOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    vehicleType?: SortOrder
    status?: SortOrder
    rating?: SortOrder
    totalOrders?: SortOrder
    completedOrders?: SortOrder
    cancelledOrders?: SortOrder
    acceptanceRate?: SortOrder
    currentOrderId?: SortOrder
    isApproved?: SortOrder
    isBlocked?: SortOrder
    blockedReason?: SortOrder
    city?: SortOrder
    state?: SortOrder
    pincode?: SortOrder
    lastOnlineAt?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type AgentMinOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    vehicleType?: SortOrder
    status?: SortOrder
    rating?: SortOrder
    totalOrders?: SortOrder
    completedOrders?: SortOrder
    cancelledOrders?: SortOrder
    acceptanceRate?: SortOrder
    currentOrderId?: SortOrder
    isApproved?: SortOrder
    isBlocked?: SortOrder
    blockedReason?: SortOrder
    city?: SortOrder
    state?: SortOrder
    pincode?: SortOrder
    lastOnlineAt?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type AgentSumOrderByAggregateInput = {
    rating?: SortOrder
    totalOrders?: SortOrder
    completedOrders?: SortOrder
    cancelledOrders?: SortOrder
    acceptanceRate?: SortOrder
  }

  export type EnumVehicleTypeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.VehicleType | EnumVehicleTypeFieldRefInput<$PrismaModel>
    in?: $Enums.VehicleType[] | ListEnumVehicleTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.VehicleType[] | ListEnumVehicleTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumVehicleTypeWithAggregatesFilter<$PrismaModel> | $Enums.VehicleType
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumVehicleTypeFilter<$PrismaModel>
    _max?: NestedEnumVehicleTypeFilter<$PrismaModel>
  }

  export type EnumAgentStatusWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.AgentStatus | EnumAgentStatusFieldRefInput<$PrismaModel>
    in?: $Enums.AgentStatus[] | ListEnumAgentStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.AgentStatus[] | ListEnumAgentStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumAgentStatusWithAggregatesFilter<$PrismaModel> | $Enums.AgentStatus
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumAgentStatusFilter<$PrismaModel>
    _max?: NestedEnumAgentStatusFilter<$PrismaModel>
  }

  export type FloatNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel> | null
    in?: number[] | ListFloatFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListFloatFieldRefInput<$PrismaModel> | null
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatNullableWithAggregatesFilter<$PrismaModel> | number | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _avg?: NestedFloatNullableFilter<$PrismaModel>
    _sum?: NestedFloatNullableFilter<$PrismaModel>
    _min?: NestedFloatNullableFilter<$PrismaModel>
    _max?: NestedFloatNullableFilter<$PrismaModel>
  }

  export type IntWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[] | ListIntFieldRefInput<$PrismaModel>
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel>
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntWithAggregatesFilter<$PrismaModel> | number
    _count?: NestedIntFilter<$PrismaModel>
    _avg?: NestedFloatFilter<$PrismaModel>
    _sum?: NestedIntFilter<$PrismaModel>
    _min?: NestedIntFilter<$PrismaModel>
    _max?: NestedIntFilter<$PrismaModel>
  }

  export type FloatWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel>
    in?: number[] | ListFloatFieldRefInput<$PrismaModel>
    notIn?: number[] | ListFloatFieldRefInput<$PrismaModel>
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatWithAggregatesFilter<$PrismaModel> | number
    _count?: NestedIntFilter<$PrismaModel>
    _avg?: NestedFloatFilter<$PrismaModel>
    _sum?: NestedFloatFilter<$PrismaModel>
    _min?: NestedFloatFilter<$PrismaModel>
    _max?: NestedFloatFilter<$PrismaModel>
  }

  export type AgentScalarRelationFilter = {
    is?: AgentWhereInput
    isNot?: AgentWhereInput
  }

  export type AgentDocumentCountOrderByAggregateInput = {
    id?: SortOrder
    agentId?: SortOrder
    documentType?: SortOrder
    fileName?: SortOrder
    fileUrl?: SortOrder
    verified?: SortOrder
    uploadedAt?: SortOrder
  }

  export type AgentDocumentMaxOrderByAggregateInput = {
    id?: SortOrder
    agentId?: SortOrder
    documentType?: SortOrder
    fileName?: SortOrder
    fileUrl?: SortOrder
    verified?: SortOrder
    uploadedAt?: SortOrder
  }

  export type AgentDocumentMinOrderByAggregateInput = {
    id?: SortOrder
    agentId?: SortOrder
    documentType?: SortOrder
    fileName?: SortOrder
    fileUrl?: SortOrder
    verified?: SortOrder
    uploadedAt?: SortOrder
  }

  export type AgentLocationCountOrderByAggregateInput = {
    id?: SortOrder
    agentId?: SortOrder
    latitude?: SortOrder
    longitude?: SortOrder
    timestamp?: SortOrder
  }

  export type AgentLocationAvgOrderByAggregateInput = {
    latitude?: SortOrder
    longitude?: SortOrder
  }

  export type AgentLocationMaxOrderByAggregateInput = {
    id?: SortOrder
    agentId?: SortOrder
    latitude?: SortOrder
    longitude?: SortOrder
    timestamp?: SortOrder
  }

  export type AgentLocationMinOrderByAggregateInput = {
    id?: SortOrder
    agentId?: SortOrder
    latitude?: SortOrder
    longitude?: SortOrder
    timestamp?: SortOrder
  }

  export type AgentLocationSumOrderByAggregateInput = {
    latitude?: SortOrder
    longitude?: SortOrder
  }

  export type PartnerDailyStatsListRelationFilter = {
    every?: PartnerDailyStatsWhereInput
    some?: PartnerDailyStatsWhereInput
    none?: PartnerDailyStatsWhereInput
  }

  export type PartnerRevenueListRelationFilter = {
    every?: PartnerRevenueWhereInput
    some?: PartnerRevenueWhereInput
    none?: PartnerRevenueWhereInput
  }

  export type PlatformRevenueListRelationFilter = {
    every?: PlatformRevenueWhereInput
    some?: PlatformRevenueWhereInput
    none?: PlatformRevenueWhereInput
  }

  export type PartnerDailyStatsOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type PartnerRevenueOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type PlatformRevenueOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type PartnerCountOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    companyName?: SortOrder
    apiKey?: SortOrder
    webhookUrl?: SortOrder
    isActive?: SortOrder
    city?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type PartnerMaxOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    companyName?: SortOrder
    apiKey?: SortOrder
    webhookUrl?: SortOrder
    isActive?: SortOrder
    city?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type PartnerMinOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    companyName?: SortOrder
    apiKey?: SortOrder
    webhookUrl?: SortOrder
    isActive?: SortOrder
    city?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type EnumOrderStatusFilter<$PrismaModel = never> = {
    equals?: $Enums.OrderStatus | EnumOrderStatusFieldRefInput<$PrismaModel>
    in?: $Enums.OrderStatus[] | ListEnumOrderStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.OrderStatus[] | ListEnumOrderStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumOrderStatusFilter<$PrismaModel> | $Enums.OrderStatus
  }

  export type IntNullableFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel> | null
    in?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntNullableFilter<$PrismaModel> | number | null
  }

  export type PartnerScalarRelationFilter = {
    is?: PartnerWhereInput
    isNot?: PartnerWhereInput
  }

  export type AgentRatingNullableScalarRelationFilter = {
    is?: AgentRatingWhereInput | null
    isNot?: AgentRatingWhereInput | null
  }

  export type PartnerRevenueNullableScalarRelationFilter = {
    is?: PartnerRevenueWhereInput | null
    isNot?: PartnerRevenueWhereInput | null
  }

  export type PlatformRevenueNullableScalarRelationFilter = {
    is?: PlatformRevenueWhereInput | null
    isNot?: PlatformRevenueWhereInput | null
  }

  export type WalletTransactionListRelationFilter = {
    every?: WalletTransactionWhereInput
    some?: WalletTransactionWhereInput
    none?: WalletTransactionWhereInput
  }

  export type WalletTransactionOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type OrderCountOrderByAggregateInput = {
    id?: SortOrder
    partnerId?: SortOrder
    agentId?: SortOrder
    pickupLat?: SortOrder
    pickupLng?: SortOrder
    dropLat?: SortOrder
    dropLng?: SortOrder
    payoutAmount?: SortOrder
    orderAmount?: SortOrder
    platformFee?: SortOrder
    orderType?: SortOrder
    commissionRate?: SortOrder
    priority?: SortOrder
    status?: SortOrder
    assignedAt?: SortOrder
    pickedUpAt?: SortOrder
    deliveredAt?: SortOrder
    cancelledAt?: SortOrder
    cancellationReason?: SortOrder
    estimatedDuration?: SortOrder
    actualDuration?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    barcode?: SortOrder
    qrCode?: SortOrder
    deliveryOtp?: SortOrder
    deliveryQrCode?: SortOrder
    otpExpiresAt?: SortOrder
    verifiedAt?: SortOrder
    verificationMethod?: SortOrder
  }

  export type OrderAvgOrderByAggregateInput = {
    pickupLat?: SortOrder
    pickupLng?: SortOrder
    dropLat?: SortOrder
    dropLng?: SortOrder
    payoutAmount?: SortOrder
    orderAmount?: SortOrder
    platformFee?: SortOrder
    commissionRate?: SortOrder
    estimatedDuration?: SortOrder
    actualDuration?: SortOrder
  }

  export type OrderMaxOrderByAggregateInput = {
    id?: SortOrder
    partnerId?: SortOrder
    agentId?: SortOrder
    pickupLat?: SortOrder
    pickupLng?: SortOrder
    dropLat?: SortOrder
    dropLng?: SortOrder
    payoutAmount?: SortOrder
    orderAmount?: SortOrder
    platformFee?: SortOrder
    orderType?: SortOrder
    commissionRate?: SortOrder
    priority?: SortOrder
    status?: SortOrder
    assignedAt?: SortOrder
    pickedUpAt?: SortOrder
    deliveredAt?: SortOrder
    cancelledAt?: SortOrder
    cancellationReason?: SortOrder
    estimatedDuration?: SortOrder
    actualDuration?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    barcode?: SortOrder
    qrCode?: SortOrder
    deliveryOtp?: SortOrder
    deliveryQrCode?: SortOrder
    otpExpiresAt?: SortOrder
    verifiedAt?: SortOrder
    verificationMethod?: SortOrder
  }

  export type OrderMinOrderByAggregateInput = {
    id?: SortOrder
    partnerId?: SortOrder
    agentId?: SortOrder
    pickupLat?: SortOrder
    pickupLng?: SortOrder
    dropLat?: SortOrder
    dropLng?: SortOrder
    payoutAmount?: SortOrder
    orderAmount?: SortOrder
    platformFee?: SortOrder
    orderType?: SortOrder
    commissionRate?: SortOrder
    priority?: SortOrder
    status?: SortOrder
    assignedAt?: SortOrder
    pickedUpAt?: SortOrder
    deliveredAt?: SortOrder
    cancelledAt?: SortOrder
    cancellationReason?: SortOrder
    estimatedDuration?: SortOrder
    actualDuration?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    barcode?: SortOrder
    qrCode?: SortOrder
    deliveryOtp?: SortOrder
    deliveryQrCode?: SortOrder
    otpExpiresAt?: SortOrder
    verifiedAt?: SortOrder
    verificationMethod?: SortOrder
  }

  export type OrderSumOrderByAggregateInput = {
    pickupLat?: SortOrder
    pickupLng?: SortOrder
    dropLat?: SortOrder
    dropLng?: SortOrder
    payoutAmount?: SortOrder
    orderAmount?: SortOrder
    platformFee?: SortOrder
    commissionRate?: SortOrder
    estimatedDuration?: SortOrder
    actualDuration?: SortOrder
  }

  export type EnumOrderStatusWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.OrderStatus | EnumOrderStatusFieldRefInput<$PrismaModel>
    in?: $Enums.OrderStatus[] | ListEnumOrderStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.OrderStatus[] | ListEnumOrderStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumOrderStatusWithAggregatesFilter<$PrismaModel> | $Enums.OrderStatus
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumOrderStatusFilter<$PrismaModel>
    _max?: NestedEnumOrderStatusFilter<$PrismaModel>
  }

  export type IntNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel> | null
    in?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntNullableWithAggregatesFilter<$PrismaModel> | number | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _avg?: NestedFloatNullableFilter<$PrismaModel>
    _sum?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedIntNullableFilter<$PrismaModel>
    _max?: NestedIntNullableFilter<$PrismaModel>
  }

  export type NotificationTokenCountOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    fcmToken?: SortOrder
    deviceType?: SortOrder
    isActive?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type NotificationTokenMaxOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    fcmToken?: SortOrder
    deviceType?: SortOrder
    isActive?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type NotificationTokenMinOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    fcmToken?: SortOrder
    deviceType?: SortOrder
    isActive?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type EnumTicketStatusFilter<$PrismaModel = never> = {
    equals?: $Enums.TicketStatus | EnumTicketStatusFieldRefInput<$PrismaModel>
    in?: $Enums.TicketStatus[] | ListEnumTicketStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.TicketStatus[] | ListEnumTicketStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumTicketStatusFilter<$PrismaModel> | $Enums.TicketStatus
  }

  export type SupportTicketCountOrderByAggregateInput = {
    id?: SortOrder
    orderId?: SortOrder
    agentId?: SortOrder
    partnerId?: SortOrder
    userId?: SortOrder
    issueType?: SortOrder
    description?: SortOrder
    status?: SortOrder
    resolvedAt?: SortOrder
    adminNotes?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type SupportTicketMaxOrderByAggregateInput = {
    id?: SortOrder
    orderId?: SortOrder
    agentId?: SortOrder
    partnerId?: SortOrder
    userId?: SortOrder
    issueType?: SortOrder
    description?: SortOrder
    status?: SortOrder
    resolvedAt?: SortOrder
    adminNotes?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type SupportTicketMinOrderByAggregateInput = {
    id?: SortOrder
    orderId?: SortOrder
    agentId?: SortOrder
    partnerId?: SortOrder
    userId?: SortOrder
    issueType?: SortOrder
    description?: SortOrder
    status?: SortOrder
    resolvedAt?: SortOrder
    adminNotes?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type EnumTicketStatusWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.TicketStatus | EnumTicketStatusFieldRefInput<$PrismaModel>
    in?: $Enums.TicketStatus[] | ListEnumTicketStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.TicketStatus[] | ListEnumTicketStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumTicketStatusWithAggregatesFilter<$PrismaModel> | $Enums.TicketStatus
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumTicketStatusFilter<$PrismaModel>
    _max?: NestedEnumTicketStatusFilter<$PrismaModel>
  }

  export type EnumActorTypeFilter<$PrismaModel = never> = {
    equals?: $Enums.ActorType | EnumActorTypeFieldRefInput<$PrismaModel>
    in?: $Enums.ActorType[] | ListEnumActorTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.ActorType[] | ListEnumActorTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumActorTypeFilter<$PrismaModel> | $Enums.ActorType
  }

  export type EnumEventTypeFilter<$PrismaModel = never> = {
    equals?: $Enums.EventType | EnumEventTypeFieldRefInput<$PrismaModel>
    in?: $Enums.EventType[] | ListEnumEventTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.EventType[] | ListEnumEventTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumEventTypeFilter<$PrismaModel> | $Enums.EventType
  }
  export type JsonNullableFilter<$PrismaModel = never> =
    | PatchUndefined<
        Either<Required<JsonNullableFilterBase<$PrismaModel>>, Exclude<keyof Required<JsonNullableFilterBase<$PrismaModel>>, 'path'>>,
        Required<JsonNullableFilterBase<$PrismaModel>>
      >
    | OptionalFlat<Omit<Required<JsonNullableFilterBase<$PrismaModel>>, 'path'>>

  export type JsonNullableFilterBase<$PrismaModel = never> = {
    equals?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
    path?: string[]
    mode?: QueryMode | EnumQueryModeFieldRefInput<$PrismaModel>
    string_contains?: string | StringFieldRefInput<$PrismaModel>
    string_starts_with?: string | StringFieldRefInput<$PrismaModel>
    string_ends_with?: string | StringFieldRefInput<$PrismaModel>
    array_starts_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_ends_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_contains?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    lt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    lte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    not?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
  }

  export type AppEventCountOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    actorType?: SortOrder
    eventType?: SortOrder
    entityType?: SortOrder
    entityId?: SortOrder
    metadata?: SortOrder
    createdAt?: SortOrder
  }

  export type AppEventMaxOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    actorType?: SortOrder
    eventType?: SortOrder
    entityType?: SortOrder
    entityId?: SortOrder
    createdAt?: SortOrder
  }

  export type AppEventMinOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    actorType?: SortOrder
    eventType?: SortOrder
    entityType?: SortOrder
    entityId?: SortOrder
    createdAt?: SortOrder
  }

  export type EnumActorTypeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.ActorType | EnumActorTypeFieldRefInput<$PrismaModel>
    in?: $Enums.ActorType[] | ListEnumActorTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.ActorType[] | ListEnumActorTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumActorTypeWithAggregatesFilter<$PrismaModel> | $Enums.ActorType
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumActorTypeFilter<$PrismaModel>
    _max?: NestedEnumActorTypeFilter<$PrismaModel>
  }

  export type EnumEventTypeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.EventType | EnumEventTypeFieldRefInput<$PrismaModel>
    in?: $Enums.EventType[] | ListEnumEventTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.EventType[] | ListEnumEventTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumEventTypeWithAggregatesFilter<$PrismaModel> | $Enums.EventType
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumEventTypeFilter<$PrismaModel>
    _max?: NestedEnumEventTypeFilter<$PrismaModel>
  }
  export type JsonNullableWithAggregatesFilter<$PrismaModel = never> =
    | PatchUndefined<
        Either<Required<JsonNullableWithAggregatesFilterBase<$PrismaModel>>, Exclude<keyof Required<JsonNullableWithAggregatesFilterBase<$PrismaModel>>, 'path'>>,
        Required<JsonNullableWithAggregatesFilterBase<$PrismaModel>>
      >
    | OptionalFlat<Omit<Required<JsonNullableWithAggregatesFilterBase<$PrismaModel>>, 'path'>>

  export type JsonNullableWithAggregatesFilterBase<$PrismaModel = never> = {
    equals?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
    path?: string[]
    mode?: QueryMode | EnumQueryModeFieldRefInput<$PrismaModel>
    string_contains?: string | StringFieldRefInput<$PrismaModel>
    string_starts_with?: string | StringFieldRefInput<$PrismaModel>
    string_ends_with?: string | StringFieldRefInput<$PrismaModel>
    array_starts_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_ends_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_contains?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    lt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    lte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    not?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedJsonNullableFilter<$PrismaModel>
    _max?: NestedJsonNullableFilter<$PrismaModel>
  }

  export type DailyStatsCountOrderByAggregateInput = {
    id?: SortOrder
    date?: SortOrder
    totalOrders?: SortOrder
    completedOrders?: SortOrder
    cancelledOrders?: SortOrder
    activeAgents?: SortOrder
    avgAssignmentTime?: SortOrder
    totalPayout?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type DailyStatsAvgOrderByAggregateInput = {
    totalOrders?: SortOrder
    completedOrders?: SortOrder
    cancelledOrders?: SortOrder
    activeAgents?: SortOrder
    avgAssignmentTime?: SortOrder
    totalPayout?: SortOrder
  }

  export type DailyStatsMaxOrderByAggregateInput = {
    id?: SortOrder
    date?: SortOrder
    totalOrders?: SortOrder
    completedOrders?: SortOrder
    cancelledOrders?: SortOrder
    activeAgents?: SortOrder
    avgAssignmentTime?: SortOrder
    totalPayout?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type DailyStatsMinOrderByAggregateInput = {
    id?: SortOrder
    date?: SortOrder
    totalOrders?: SortOrder
    completedOrders?: SortOrder
    cancelledOrders?: SortOrder
    activeAgents?: SortOrder
    avgAssignmentTime?: SortOrder
    totalPayout?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type DailyStatsSumOrderByAggregateInput = {
    totalOrders?: SortOrder
    completedOrders?: SortOrder
    cancelledOrders?: SortOrder
    activeAgents?: SortOrder
    avgAssignmentTime?: SortOrder
    totalPayout?: SortOrder
  }

  export type PartnerDailyStatsPartnerIdDateCompoundUniqueInput = {
    partnerId: string
    date: Date | string
  }

  export type PartnerDailyStatsCountOrderByAggregateInput = {
    id?: SortOrder
    partnerId?: SortOrder
    date?: SortOrder
    totalOrders?: SortOrder
    completedOrders?: SortOrder
    cancelledOrders?: SortOrder
    avgAssignmentTime?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type PartnerDailyStatsAvgOrderByAggregateInput = {
    totalOrders?: SortOrder
    completedOrders?: SortOrder
    cancelledOrders?: SortOrder
    avgAssignmentTime?: SortOrder
  }

  export type PartnerDailyStatsMaxOrderByAggregateInput = {
    id?: SortOrder
    partnerId?: SortOrder
    date?: SortOrder
    totalOrders?: SortOrder
    completedOrders?: SortOrder
    cancelledOrders?: SortOrder
    avgAssignmentTime?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type PartnerDailyStatsMinOrderByAggregateInput = {
    id?: SortOrder
    partnerId?: SortOrder
    date?: SortOrder
    totalOrders?: SortOrder
    completedOrders?: SortOrder
    cancelledOrders?: SortOrder
    avgAssignmentTime?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type PartnerDailyStatsSumOrderByAggregateInput = {
    totalOrders?: SortOrder
    completedOrders?: SortOrder
    cancelledOrders?: SortOrder
    avgAssignmentTime?: SortOrder
  }

  export type OrderScalarRelationFilter = {
    is?: OrderWhereInput
    isNot?: OrderWhereInput
  }

  export type PartnerRevenueCountOrderByAggregateInput = {
    id?: SortOrder
    partnerId?: SortOrder
    orderId?: SortOrder
    orderAmount?: SortOrder
    deliveryFee?: SortOrder
    platformFee?: SortOrder
    netRevenue?: SortOrder
    status?: SortOrder
    processedAt?: SortOrder
    periodStart?: SortOrder
    periodEnd?: SortOrder
    periodType?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type PartnerRevenueAvgOrderByAggregateInput = {
    orderAmount?: SortOrder
    deliveryFee?: SortOrder
    platformFee?: SortOrder
    netRevenue?: SortOrder
  }

  export type PartnerRevenueMaxOrderByAggregateInput = {
    id?: SortOrder
    partnerId?: SortOrder
    orderId?: SortOrder
    orderAmount?: SortOrder
    deliveryFee?: SortOrder
    platformFee?: SortOrder
    netRevenue?: SortOrder
    status?: SortOrder
    processedAt?: SortOrder
    periodStart?: SortOrder
    periodEnd?: SortOrder
    periodType?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type PartnerRevenueMinOrderByAggregateInput = {
    id?: SortOrder
    partnerId?: SortOrder
    orderId?: SortOrder
    orderAmount?: SortOrder
    deliveryFee?: SortOrder
    platformFee?: SortOrder
    netRevenue?: SortOrder
    status?: SortOrder
    processedAt?: SortOrder
    periodStart?: SortOrder
    periodEnd?: SortOrder
    periodType?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type PartnerRevenueSumOrderByAggregateInput = {
    orderAmount?: SortOrder
    deliveryFee?: SortOrder
    platformFee?: SortOrder
    netRevenue?: SortOrder
  }

  export type PlatformRevenueCountOrderByAggregateInput = {
    id?: SortOrder
    orderId?: SortOrder
    partnerId?: SortOrder
    agentId?: SortOrder
    orderAmount?: SortOrder
    platformFee?: SortOrder
    agentPayout?: SortOrder
    netRevenue?: SortOrder
    revenueType?: SortOrder
    status?: SortOrder
    processedAt?: SortOrder
    periodStart?: SortOrder
    periodEnd?: SortOrder
    periodType?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type PlatformRevenueAvgOrderByAggregateInput = {
    orderAmount?: SortOrder
    platformFee?: SortOrder
    agentPayout?: SortOrder
    netRevenue?: SortOrder
  }

  export type PlatformRevenueMaxOrderByAggregateInput = {
    id?: SortOrder
    orderId?: SortOrder
    partnerId?: SortOrder
    agentId?: SortOrder
    orderAmount?: SortOrder
    platformFee?: SortOrder
    agentPayout?: SortOrder
    netRevenue?: SortOrder
    revenueType?: SortOrder
    status?: SortOrder
    processedAt?: SortOrder
    periodStart?: SortOrder
    periodEnd?: SortOrder
    periodType?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type PlatformRevenueMinOrderByAggregateInput = {
    id?: SortOrder
    orderId?: SortOrder
    partnerId?: SortOrder
    agentId?: SortOrder
    orderAmount?: SortOrder
    platformFee?: SortOrder
    agentPayout?: SortOrder
    netRevenue?: SortOrder
    revenueType?: SortOrder
    status?: SortOrder
    processedAt?: SortOrder
    periodStart?: SortOrder
    periodEnd?: SortOrder
    periodType?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type PlatformRevenueSumOrderByAggregateInput = {
    orderAmount?: SortOrder
    platformFee?: SortOrder
    agentPayout?: SortOrder
    netRevenue?: SortOrder
  }

  export type AdminWalletCountOrderByAggregateInput = {
    id?: SortOrder
    balance?: SortOrder
    totalDeposited?: SortOrder
    totalPaidOut?: SortOrder
    lastUpdated?: SortOrder
    createdAt?: SortOrder
  }

  export type AdminWalletAvgOrderByAggregateInput = {
    balance?: SortOrder
    totalDeposited?: SortOrder
    totalPaidOut?: SortOrder
  }

  export type AdminWalletMaxOrderByAggregateInput = {
    id?: SortOrder
    balance?: SortOrder
    totalDeposited?: SortOrder
    totalPaidOut?: SortOrder
    lastUpdated?: SortOrder
    createdAt?: SortOrder
  }

  export type AdminWalletMinOrderByAggregateInput = {
    id?: SortOrder
    balance?: SortOrder
    totalDeposited?: SortOrder
    totalPaidOut?: SortOrder
    lastUpdated?: SortOrder
    createdAt?: SortOrder
  }

  export type AdminWalletSumOrderByAggregateInput = {
    balance?: SortOrder
    totalDeposited?: SortOrder
    totalPaidOut?: SortOrder
  }

  export type AgentWalletCountOrderByAggregateInput = {
    id?: SortOrder
    agentId?: SortOrder
    balance?: SortOrder
    totalEarned?: SortOrder
    totalPaidOut?: SortOrder
    lastPayoutDate?: SortOrder
    nextPayoutDate?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type AgentWalletAvgOrderByAggregateInput = {
    balance?: SortOrder
    totalEarned?: SortOrder
    totalPaidOut?: SortOrder
  }

  export type AgentWalletMaxOrderByAggregateInput = {
    id?: SortOrder
    agentId?: SortOrder
    balance?: SortOrder
    totalEarned?: SortOrder
    totalPaidOut?: SortOrder
    lastPayoutDate?: SortOrder
    nextPayoutDate?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type AgentWalletMinOrderByAggregateInput = {
    id?: SortOrder
    agentId?: SortOrder
    balance?: SortOrder
    totalEarned?: SortOrder
    totalPaidOut?: SortOrder
    lastPayoutDate?: SortOrder
    nextPayoutDate?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type AgentWalletSumOrderByAggregateInput = {
    balance?: SortOrder
    totalEarned?: SortOrder
    totalPaidOut?: SortOrder
  }

  export type AdminWalletNullableScalarRelationFilter = {
    is?: AdminWalletWhereInput | null
    isNot?: AdminWalletWhereInput | null
  }

  export type WalletTransactionCountOrderByAggregateInput = {
    id?: SortOrder
    walletType?: SortOrder
    adminWalletId?: SortOrder
    agentWalletId?: SortOrder
    orderId?: SortOrder
    amount?: SortOrder
    type?: SortOrder
    description?: SortOrder
    balanceBefore?: SortOrder
    balanceAfter?: SortOrder
    status?: SortOrder
    createdAt?: SortOrder
  }

  export type WalletTransactionAvgOrderByAggregateInput = {
    amount?: SortOrder
    balanceBefore?: SortOrder
    balanceAfter?: SortOrder
  }

  export type WalletTransactionMaxOrderByAggregateInput = {
    id?: SortOrder
    walletType?: SortOrder
    adminWalletId?: SortOrder
    agentWalletId?: SortOrder
    orderId?: SortOrder
    amount?: SortOrder
    type?: SortOrder
    description?: SortOrder
    balanceBefore?: SortOrder
    balanceAfter?: SortOrder
    status?: SortOrder
    createdAt?: SortOrder
  }

  export type WalletTransactionMinOrderByAggregateInput = {
    id?: SortOrder
    walletType?: SortOrder
    adminWalletId?: SortOrder
    agentWalletId?: SortOrder
    orderId?: SortOrder
    amount?: SortOrder
    type?: SortOrder
    description?: SortOrder
    balanceBefore?: SortOrder
    balanceAfter?: SortOrder
    status?: SortOrder
    createdAt?: SortOrder
  }

  export type WalletTransactionSumOrderByAggregateInput = {
    amount?: SortOrder
    balanceBefore?: SortOrder
    balanceAfter?: SortOrder
  }

  export type AgentWalletScalarRelationFilter = {
    is?: AgentWalletWhereInput
    isNot?: AgentWalletWhereInput
  }

  export type WalletPayoutAgentIdPeriodStartPeriodEndCompoundUniqueInput = {
    agentId: string
    periodStart: Date | string
    periodEnd: Date | string
  }

  export type WalletPayoutCountOrderByAggregateInput = {
    id?: SortOrder
    agentWalletId?: SortOrder
    agentId?: SortOrder
    amount?: SortOrder
    periodStart?: SortOrder
    periodEnd?: SortOrder
    status?: SortOrder
    paymentMethod?: SortOrder
    transactionId?: SortOrder
    bankAccount?: SortOrder
    upiId?: SortOrder
    processedAt?: SortOrder
    failedAt?: SortOrder
    failureReason?: SortOrder
    notes?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type WalletPayoutAvgOrderByAggregateInput = {
    amount?: SortOrder
  }

  export type WalletPayoutMaxOrderByAggregateInput = {
    id?: SortOrder
    agentWalletId?: SortOrder
    agentId?: SortOrder
    amount?: SortOrder
    periodStart?: SortOrder
    periodEnd?: SortOrder
    status?: SortOrder
    paymentMethod?: SortOrder
    transactionId?: SortOrder
    bankAccount?: SortOrder
    upiId?: SortOrder
    processedAt?: SortOrder
    failedAt?: SortOrder
    failureReason?: SortOrder
    notes?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type WalletPayoutMinOrderByAggregateInput = {
    id?: SortOrder
    agentWalletId?: SortOrder
    agentId?: SortOrder
    amount?: SortOrder
    periodStart?: SortOrder
    periodEnd?: SortOrder
    status?: SortOrder
    paymentMethod?: SortOrder
    transactionId?: SortOrder
    bankAccount?: SortOrder
    upiId?: SortOrder
    processedAt?: SortOrder
    failedAt?: SortOrder
    failureReason?: SortOrder
    notes?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type WalletPayoutSumOrderByAggregateInput = {
    amount?: SortOrder
  }

  export type NotificationCountOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    title?: SortOrder
    message?: SortOrder
    type?: SortOrder
    isRead?: SortOrder
    link?: SortOrder
    metadata?: SortOrder
    createdAt?: SortOrder
    readAt?: SortOrder
  }

  export type NotificationMaxOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    title?: SortOrder
    message?: SortOrder
    type?: SortOrder
    isRead?: SortOrder
    link?: SortOrder
    createdAt?: SortOrder
    readAt?: SortOrder
  }

  export type NotificationMinOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    title?: SortOrder
    message?: SortOrder
    type?: SortOrder
    isRead?: SortOrder
    link?: SortOrder
    createdAt?: SortOrder
    readAt?: SortOrder
  }

  export type AgentRatingCountOrderByAggregateInput = {
    id?: SortOrder
    orderId?: SortOrder
    agentId?: SortOrder
    partnerId?: SortOrder
    rating?: SortOrder
    comment?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type AgentRatingAvgOrderByAggregateInput = {
    rating?: SortOrder
  }

  export type AgentRatingMaxOrderByAggregateInput = {
    id?: SortOrder
    orderId?: SortOrder
    agentId?: SortOrder
    partnerId?: SortOrder
    rating?: SortOrder
    comment?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type AgentRatingMinOrderByAggregateInput = {
    id?: SortOrder
    orderId?: SortOrder
    agentId?: SortOrder
    partnerId?: SortOrder
    rating?: SortOrder
    comment?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type AgentRatingSumOrderByAggregateInput = {
    rating?: SortOrder
  }

  export type PaymentCountOrderByAggregateInput = {
    id?: SortOrder
    agentId?: SortOrder
    orderId?: SortOrder
    amount?: SortOrder
    paymentType?: SortOrder
    status?: SortOrder
    processedAt?: SortOrder
    paymentMethod?: SortOrder
    transactionId?: SortOrder
    notes?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type PaymentAvgOrderByAggregateInput = {
    amount?: SortOrder
  }

  export type PaymentMaxOrderByAggregateInput = {
    id?: SortOrder
    agentId?: SortOrder
    orderId?: SortOrder
    amount?: SortOrder
    paymentType?: SortOrder
    status?: SortOrder
    processedAt?: SortOrder
    paymentMethod?: SortOrder
    transactionId?: SortOrder
    notes?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type PaymentMinOrderByAggregateInput = {
    id?: SortOrder
    agentId?: SortOrder
    orderId?: SortOrder
    amount?: SortOrder
    paymentType?: SortOrder
    status?: SortOrder
    processedAt?: SortOrder
    paymentMethod?: SortOrder
    transactionId?: SortOrder
    notes?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type PaymentSumOrderByAggregateInput = {
    amount?: SortOrder
  }

  export type PayrollAgentIdPeriodStartPeriodEndPeriodTypeCompoundUniqueInput = {
    agentId: string
    periodStart: Date | string
    periodEnd: Date | string
    periodType: string
  }

  export type PayrollCountOrderByAggregateInput = {
    id?: SortOrder
    agentId?: SortOrder
    periodStart?: SortOrder
    periodEnd?: SortOrder
    periodType?: SortOrder
    totalEarnings?: SortOrder
    totalOrders?: SortOrder
    basePay?: SortOrder
    bonuses?: SortOrder
    deductions?: SortOrder
    netPay?: SortOrder
    status?: SortOrder
    processedAt?: SortOrder
    paidAt?: SortOrder
    paymentMethod?: SortOrder
    transactionId?: SortOrder
    notes?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type PayrollAvgOrderByAggregateInput = {
    totalEarnings?: SortOrder
    totalOrders?: SortOrder
    basePay?: SortOrder
    bonuses?: SortOrder
    deductions?: SortOrder
    netPay?: SortOrder
  }

  export type PayrollMaxOrderByAggregateInput = {
    id?: SortOrder
    agentId?: SortOrder
    periodStart?: SortOrder
    periodEnd?: SortOrder
    periodType?: SortOrder
    totalEarnings?: SortOrder
    totalOrders?: SortOrder
    basePay?: SortOrder
    bonuses?: SortOrder
    deductions?: SortOrder
    netPay?: SortOrder
    status?: SortOrder
    processedAt?: SortOrder
    paidAt?: SortOrder
    paymentMethod?: SortOrder
    transactionId?: SortOrder
    notes?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type PayrollMinOrderByAggregateInput = {
    id?: SortOrder
    agentId?: SortOrder
    periodStart?: SortOrder
    periodEnd?: SortOrder
    periodType?: SortOrder
    totalEarnings?: SortOrder
    totalOrders?: SortOrder
    basePay?: SortOrder
    bonuses?: SortOrder
    deductions?: SortOrder
    netPay?: SortOrder
    status?: SortOrder
    processedAt?: SortOrder
    paidAt?: SortOrder
    paymentMethod?: SortOrder
    transactionId?: SortOrder
    notes?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type PayrollSumOrderByAggregateInput = {
    totalEarnings?: SortOrder
    totalOrders?: SortOrder
    basePay?: SortOrder
    bonuses?: SortOrder
    deductions?: SortOrder
    netPay?: SortOrder
  }

  export type AgentScheduleAgentIdDateCompoundUniqueInput = {
    agentId: string
    date: Date | string
  }

  export type AgentScheduleCountOrderByAggregateInput = {
    id?: SortOrder
    agentId?: SortOrder
    date?: SortOrder
    startTime?: SortOrder
    endTime?: SortOrder
    isAvailable?: SortOrder
    notes?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type AgentScheduleMaxOrderByAggregateInput = {
    id?: SortOrder
    agentId?: SortOrder
    date?: SortOrder
    startTime?: SortOrder
    endTime?: SortOrder
    isAvailable?: SortOrder
    notes?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type AgentScheduleMinOrderByAggregateInput = {
    id?: SortOrder
    agentId?: SortOrder
    date?: SortOrder
    startTime?: SortOrder
    endTime?: SortOrder
    isAvailable?: SortOrder
    notes?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type PayStructureCountOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    payType?: SortOrder
    baseRate?: SortOrder
    commissionRate?: SortOrder
    minGuarantee?: SortOrder
    maxLimit?: SortOrder
    bonusRules?: SortOrder
    deductionRules?: SortOrder
    isActive?: SortOrder
    effectiveFrom?: SortOrder
    effectiveTo?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type PayStructureAvgOrderByAggregateInput = {
    baseRate?: SortOrder
    commissionRate?: SortOrder
    minGuarantee?: SortOrder
    maxLimit?: SortOrder
  }

  export type PayStructureMaxOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    payType?: SortOrder
    baseRate?: SortOrder
    commissionRate?: SortOrder
    minGuarantee?: SortOrder
    maxLimit?: SortOrder
    isActive?: SortOrder
    effectiveFrom?: SortOrder
    effectiveTo?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type PayStructureMinOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    payType?: SortOrder
    baseRate?: SortOrder
    commissionRate?: SortOrder
    minGuarantee?: SortOrder
    maxLimit?: SortOrder
    isActive?: SortOrder
    effectiveFrom?: SortOrder
    effectiveTo?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type PayStructureSumOrderByAggregateInput = {
    baseRate?: SortOrder
    commissionRate?: SortOrder
    minGuarantee?: SortOrder
    maxLimit?: SortOrder
  }

  export type AgentCreateNestedOneWithoutUserInput = {
    create?: XOR<AgentCreateWithoutUserInput, AgentUncheckedCreateWithoutUserInput>
    connectOrCreate?: AgentCreateOrConnectWithoutUserInput
    connect?: AgentWhereUniqueInput
  }

  export type PartnerCreateNestedOneWithoutUserInput = {
    create?: XOR<PartnerCreateWithoutUserInput, PartnerUncheckedCreateWithoutUserInput>
    connectOrCreate?: PartnerCreateOrConnectWithoutUserInput
    connect?: PartnerWhereUniqueInput
  }

  export type NotificationTokenCreateNestedManyWithoutUserInput = {
    create?: XOR<NotificationTokenCreateWithoutUserInput, NotificationTokenUncheckedCreateWithoutUserInput> | NotificationTokenCreateWithoutUserInput[] | NotificationTokenUncheckedCreateWithoutUserInput[]
    connectOrCreate?: NotificationTokenCreateOrConnectWithoutUserInput | NotificationTokenCreateOrConnectWithoutUserInput[]
    createMany?: NotificationTokenCreateManyUserInputEnvelope
    connect?: NotificationTokenWhereUniqueInput | NotificationTokenWhereUniqueInput[]
  }

  export type NotificationCreateNestedManyWithoutUserInput = {
    create?: XOR<NotificationCreateWithoutUserInput, NotificationUncheckedCreateWithoutUserInput> | NotificationCreateWithoutUserInput[] | NotificationUncheckedCreateWithoutUserInput[]
    connectOrCreate?: NotificationCreateOrConnectWithoutUserInput | NotificationCreateOrConnectWithoutUserInput[]
    createMany?: NotificationCreateManyUserInputEnvelope
    connect?: NotificationWhereUniqueInput | NotificationWhereUniqueInput[]
  }

  export type SupportTicketCreateNestedManyWithoutUserInput = {
    create?: XOR<SupportTicketCreateWithoutUserInput, SupportTicketUncheckedCreateWithoutUserInput> | SupportTicketCreateWithoutUserInput[] | SupportTicketUncheckedCreateWithoutUserInput[]
    connectOrCreate?: SupportTicketCreateOrConnectWithoutUserInput | SupportTicketCreateOrConnectWithoutUserInput[]
    createMany?: SupportTicketCreateManyUserInputEnvelope
    connect?: SupportTicketWhereUniqueInput | SupportTicketWhereUniqueInput[]
  }

  export type AgentUncheckedCreateNestedOneWithoutUserInput = {
    create?: XOR<AgentCreateWithoutUserInput, AgentUncheckedCreateWithoutUserInput>
    connectOrCreate?: AgentCreateOrConnectWithoutUserInput
    connect?: AgentWhereUniqueInput
  }

  export type PartnerUncheckedCreateNestedOneWithoutUserInput = {
    create?: XOR<PartnerCreateWithoutUserInput, PartnerUncheckedCreateWithoutUserInput>
    connectOrCreate?: PartnerCreateOrConnectWithoutUserInput
    connect?: PartnerWhereUniqueInput
  }

  export type NotificationTokenUncheckedCreateNestedManyWithoutUserInput = {
    create?: XOR<NotificationTokenCreateWithoutUserInput, NotificationTokenUncheckedCreateWithoutUserInput> | NotificationTokenCreateWithoutUserInput[] | NotificationTokenUncheckedCreateWithoutUserInput[]
    connectOrCreate?: NotificationTokenCreateOrConnectWithoutUserInput | NotificationTokenCreateOrConnectWithoutUserInput[]
    createMany?: NotificationTokenCreateManyUserInputEnvelope
    connect?: NotificationTokenWhereUniqueInput | NotificationTokenWhereUniqueInput[]
  }

  export type NotificationUncheckedCreateNestedManyWithoutUserInput = {
    create?: XOR<NotificationCreateWithoutUserInput, NotificationUncheckedCreateWithoutUserInput> | NotificationCreateWithoutUserInput[] | NotificationUncheckedCreateWithoutUserInput[]
    connectOrCreate?: NotificationCreateOrConnectWithoutUserInput | NotificationCreateOrConnectWithoutUserInput[]
    createMany?: NotificationCreateManyUserInputEnvelope
    connect?: NotificationWhereUniqueInput | NotificationWhereUniqueInput[]
  }

  export type SupportTicketUncheckedCreateNestedManyWithoutUserInput = {
    create?: XOR<SupportTicketCreateWithoutUserInput, SupportTicketUncheckedCreateWithoutUserInput> | SupportTicketCreateWithoutUserInput[] | SupportTicketUncheckedCreateWithoutUserInput[]
    connectOrCreate?: SupportTicketCreateOrConnectWithoutUserInput | SupportTicketCreateOrConnectWithoutUserInput[]
    createMany?: SupportTicketCreateManyUserInputEnvelope
    connect?: SupportTicketWhereUniqueInput | SupportTicketWhereUniqueInput[]
  }

  export type StringFieldUpdateOperationsInput = {
    set?: string
  }

  export type EnumUserRoleFieldUpdateOperationsInput = {
    set?: $Enums.UserRole
  }

  export type NullableDateTimeFieldUpdateOperationsInput = {
    set?: Date | string | null
  }

  export type BoolFieldUpdateOperationsInput = {
    set?: boolean
  }

  export type NullableStringFieldUpdateOperationsInput = {
    set?: string | null
  }

  export type DateTimeFieldUpdateOperationsInput = {
    set?: Date | string
  }

  export type AgentUpdateOneWithoutUserNestedInput = {
    create?: XOR<AgentCreateWithoutUserInput, AgentUncheckedCreateWithoutUserInput>
    connectOrCreate?: AgentCreateOrConnectWithoutUserInput
    upsert?: AgentUpsertWithoutUserInput
    disconnect?: AgentWhereInput | boolean
    delete?: AgentWhereInput | boolean
    connect?: AgentWhereUniqueInput
    update?: XOR<XOR<AgentUpdateToOneWithWhereWithoutUserInput, AgentUpdateWithoutUserInput>, AgentUncheckedUpdateWithoutUserInput>
  }

  export type PartnerUpdateOneWithoutUserNestedInput = {
    create?: XOR<PartnerCreateWithoutUserInput, PartnerUncheckedCreateWithoutUserInput>
    connectOrCreate?: PartnerCreateOrConnectWithoutUserInput
    upsert?: PartnerUpsertWithoutUserInput
    disconnect?: PartnerWhereInput | boolean
    delete?: PartnerWhereInput | boolean
    connect?: PartnerWhereUniqueInput
    update?: XOR<XOR<PartnerUpdateToOneWithWhereWithoutUserInput, PartnerUpdateWithoutUserInput>, PartnerUncheckedUpdateWithoutUserInput>
  }

  export type NotificationTokenUpdateManyWithoutUserNestedInput = {
    create?: XOR<NotificationTokenCreateWithoutUserInput, NotificationTokenUncheckedCreateWithoutUserInput> | NotificationTokenCreateWithoutUserInput[] | NotificationTokenUncheckedCreateWithoutUserInput[]
    connectOrCreate?: NotificationTokenCreateOrConnectWithoutUserInput | NotificationTokenCreateOrConnectWithoutUserInput[]
    upsert?: NotificationTokenUpsertWithWhereUniqueWithoutUserInput | NotificationTokenUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: NotificationTokenCreateManyUserInputEnvelope
    set?: NotificationTokenWhereUniqueInput | NotificationTokenWhereUniqueInput[]
    disconnect?: NotificationTokenWhereUniqueInput | NotificationTokenWhereUniqueInput[]
    delete?: NotificationTokenWhereUniqueInput | NotificationTokenWhereUniqueInput[]
    connect?: NotificationTokenWhereUniqueInput | NotificationTokenWhereUniqueInput[]
    update?: NotificationTokenUpdateWithWhereUniqueWithoutUserInput | NotificationTokenUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: NotificationTokenUpdateManyWithWhereWithoutUserInput | NotificationTokenUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: NotificationTokenScalarWhereInput | NotificationTokenScalarWhereInput[]
  }

  export type NotificationUpdateManyWithoutUserNestedInput = {
    create?: XOR<NotificationCreateWithoutUserInput, NotificationUncheckedCreateWithoutUserInput> | NotificationCreateWithoutUserInput[] | NotificationUncheckedCreateWithoutUserInput[]
    connectOrCreate?: NotificationCreateOrConnectWithoutUserInput | NotificationCreateOrConnectWithoutUserInput[]
    upsert?: NotificationUpsertWithWhereUniqueWithoutUserInput | NotificationUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: NotificationCreateManyUserInputEnvelope
    set?: NotificationWhereUniqueInput | NotificationWhereUniqueInput[]
    disconnect?: NotificationWhereUniqueInput | NotificationWhereUniqueInput[]
    delete?: NotificationWhereUniqueInput | NotificationWhereUniqueInput[]
    connect?: NotificationWhereUniqueInput | NotificationWhereUniqueInput[]
    update?: NotificationUpdateWithWhereUniqueWithoutUserInput | NotificationUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: NotificationUpdateManyWithWhereWithoutUserInput | NotificationUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: NotificationScalarWhereInput | NotificationScalarWhereInput[]
  }

  export type SupportTicketUpdateManyWithoutUserNestedInput = {
    create?: XOR<SupportTicketCreateWithoutUserInput, SupportTicketUncheckedCreateWithoutUserInput> | SupportTicketCreateWithoutUserInput[] | SupportTicketUncheckedCreateWithoutUserInput[]
    connectOrCreate?: SupportTicketCreateOrConnectWithoutUserInput | SupportTicketCreateOrConnectWithoutUserInput[]
    upsert?: SupportTicketUpsertWithWhereUniqueWithoutUserInput | SupportTicketUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: SupportTicketCreateManyUserInputEnvelope
    set?: SupportTicketWhereUniqueInput | SupportTicketWhereUniqueInput[]
    disconnect?: SupportTicketWhereUniqueInput | SupportTicketWhereUniqueInput[]
    delete?: SupportTicketWhereUniqueInput | SupportTicketWhereUniqueInput[]
    connect?: SupportTicketWhereUniqueInput | SupportTicketWhereUniqueInput[]
    update?: SupportTicketUpdateWithWhereUniqueWithoutUserInput | SupportTicketUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: SupportTicketUpdateManyWithWhereWithoutUserInput | SupportTicketUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: SupportTicketScalarWhereInput | SupportTicketScalarWhereInput[]
  }

  export type AgentUncheckedUpdateOneWithoutUserNestedInput = {
    create?: XOR<AgentCreateWithoutUserInput, AgentUncheckedCreateWithoutUserInput>
    connectOrCreate?: AgentCreateOrConnectWithoutUserInput
    upsert?: AgentUpsertWithoutUserInput
    disconnect?: AgentWhereInput | boolean
    delete?: AgentWhereInput | boolean
    connect?: AgentWhereUniqueInput
    update?: XOR<XOR<AgentUpdateToOneWithWhereWithoutUserInput, AgentUpdateWithoutUserInput>, AgentUncheckedUpdateWithoutUserInput>
  }

  export type PartnerUncheckedUpdateOneWithoutUserNestedInput = {
    create?: XOR<PartnerCreateWithoutUserInput, PartnerUncheckedCreateWithoutUserInput>
    connectOrCreate?: PartnerCreateOrConnectWithoutUserInput
    upsert?: PartnerUpsertWithoutUserInput
    disconnect?: PartnerWhereInput | boolean
    delete?: PartnerWhereInput | boolean
    connect?: PartnerWhereUniqueInput
    update?: XOR<XOR<PartnerUpdateToOneWithWhereWithoutUserInput, PartnerUpdateWithoutUserInput>, PartnerUncheckedUpdateWithoutUserInput>
  }

  export type NotificationTokenUncheckedUpdateManyWithoutUserNestedInput = {
    create?: XOR<NotificationTokenCreateWithoutUserInput, NotificationTokenUncheckedCreateWithoutUserInput> | NotificationTokenCreateWithoutUserInput[] | NotificationTokenUncheckedCreateWithoutUserInput[]
    connectOrCreate?: NotificationTokenCreateOrConnectWithoutUserInput | NotificationTokenCreateOrConnectWithoutUserInput[]
    upsert?: NotificationTokenUpsertWithWhereUniqueWithoutUserInput | NotificationTokenUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: NotificationTokenCreateManyUserInputEnvelope
    set?: NotificationTokenWhereUniqueInput | NotificationTokenWhereUniqueInput[]
    disconnect?: NotificationTokenWhereUniqueInput | NotificationTokenWhereUniqueInput[]
    delete?: NotificationTokenWhereUniqueInput | NotificationTokenWhereUniqueInput[]
    connect?: NotificationTokenWhereUniqueInput | NotificationTokenWhereUniqueInput[]
    update?: NotificationTokenUpdateWithWhereUniqueWithoutUserInput | NotificationTokenUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: NotificationTokenUpdateManyWithWhereWithoutUserInput | NotificationTokenUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: NotificationTokenScalarWhereInput | NotificationTokenScalarWhereInput[]
  }

  export type NotificationUncheckedUpdateManyWithoutUserNestedInput = {
    create?: XOR<NotificationCreateWithoutUserInput, NotificationUncheckedCreateWithoutUserInput> | NotificationCreateWithoutUserInput[] | NotificationUncheckedCreateWithoutUserInput[]
    connectOrCreate?: NotificationCreateOrConnectWithoutUserInput | NotificationCreateOrConnectWithoutUserInput[]
    upsert?: NotificationUpsertWithWhereUniqueWithoutUserInput | NotificationUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: NotificationCreateManyUserInputEnvelope
    set?: NotificationWhereUniqueInput | NotificationWhereUniqueInput[]
    disconnect?: NotificationWhereUniqueInput | NotificationWhereUniqueInput[]
    delete?: NotificationWhereUniqueInput | NotificationWhereUniqueInput[]
    connect?: NotificationWhereUniqueInput | NotificationWhereUniqueInput[]
    update?: NotificationUpdateWithWhereUniqueWithoutUserInput | NotificationUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: NotificationUpdateManyWithWhereWithoutUserInput | NotificationUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: NotificationScalarWhereInput | NotificationScalarWhereInput[]
  }

  export type SupportTicketUncheckedUpdateManyWithoutUserNestedInput = {
    create?: XOR<SupportTicketCreateWithoutUserInput, SupportTicketUncheckedCreateWithoutUserInput> | SupportTicketCreateWithoutUserInput[] | SupportTicketUncheckedCreateWithoutUserInput[]
    connectOrCreate?: SupportTicketCreateOrConnectWithoutUserInput | SupportTicketCreateOrConnectWithoutUserInput[]
    upsert?: SupportTicketUpsertWithWhereUniqueWithoutUserInput | SupportTicketUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: SupportTicketCreateManyUserInputEnvelope
    set?: SupportTicketWhereUniqueInput | SupportTicketWhereUniqueInput[]
    disconnect?: SupportTicketWhereUniqueInput | SupportTicketWhereUniqueInput[]
    delete?: SupportTicketWhereUniqueInput | SupportTicketWhereUniqueInput[]
    connect?: SupportTicketWhereUniqueInput | SupportTicketWhereUniqueInput[]
    update?: SupportTicketUpdateWithWhereUniqueWithoutUserInput | SupportTicketUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: SupportTicketUpdateManyWithWhereWithoutUserInput | SupportTicketUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: SupportTicketScalarWhereInput | SupportTicketScalarWhereInput[]
  }

  export type UserCreateNestedOneWithoutAgentInput = {
    create?: XOR<UserCreateWithoutAgentInput, UserUncheckedCreateWithoutAgentInput>
    connectOrCreate?: UserCreateOrConnectWithoutAgentInput
    connect?: UserWhereUniqueInput
  }

  export type OrderCreateNestedManyWithoutAgentInput = {
    create?: XOR<OrderCreateWithoutAgentInput, OrderUncheckedCreateWithoutAgentInput> | OrderCreateWithoutAgentInput[] | OrderUncheckedCreateWithoutAgentInput[]
    connectOrCreate?: OrderCreateOrConnectWithoutAgentInput | OrderCreateOrConnectWithoutAgentInput[]
    createMany?: OrderCreateManyAgentInputEnvelope
    connect?: OrderWhereUniqueInput | OrderWhereUniqueInput[]
  }

  export type OrderCreateNestedOneWithoutCurrentAgentInput = {
    create?: XOR<OrderCreateWithoutCurrentAgentInput, OrderUncheckedCreateWithoutCurrentAgentInput>
    connectOrCreate?: OrderCreateOrConnectWithoutCurrentAgentInput
    connect?: OrderWhereUniqueInput
  }

  export type AgentDocumentCreateNestedManyWithoutAgentInput = {
    create?: XOR<AgentDocumentCreateWithoutAgentInput, AgentDocumentUncheckedCreateWithoutAgentInput> | AgentDocumentCreateWithoutAgentInput[] | AgentDocumentUncheckedCreateWithoutAgentInput[]
    connectOrCreate?: AgentDocumentCreateOrConnectWithoutAgentInput | AgentDocumentCreateOrConnectWithoutAgentInput[]
    createMany?: AgentDocumentCreateManyAgentInputEnvelope
    connect?: AgentDocumentWhereUniqueInput | AgentDocumentWhereUniqueInput[]
  }

  export type AgentLocationCreateNestedManyWithoutAgentInput = {
    create?: XOR<AgentLocationCreateWithoutAgentInput, AgentLocationUncheckedCreateWithoutAgentInput> | AgentLocationCreateWithoutAgentInput[] | AgentLocationUncheckedCreateWithoutAgentInput[]
    connectOrCreate?: AgentLocationCreateOrConnectWithoutAgentInput | AgentLocationCreateOrConnectWithoutAgentInput[]
    createMany?: AgentLocationCreateManyAgentInputEnvelope
    connect?: AgentLocationWhereUniqueInput | AgentLocationWhereUniqueInput[]
  }

  export type SupportTicketCreateNestedManyWithoutAgentInput = {
    create?: XOR<SupportTicketCreateWithoutAgentInput, SupportTicketUncheckedCreateWithoutAgentInput> | SupportTicketCreateWithoutAgentInput[] | SupportTicketUncheckedCreateWithoutAgentInput[]
    connectOrCreate?: SupportTicketCreateOrConnectWithoutAgentInput | SupportTicketCreateOrConnectWithoutAgentInput[]
    createMany?: SupportTicketCreateManyAgentInputEnvelope
    connect?: SupportTicketWhereUniqueInput | SupportTicketWhereUniqueInput[]
  }

  export type AgentRatingCreateNestedManyWithoutAgentInput = {
    create?: XOR<AgentRatingCreateWithoutAgentInput, AgentRatingUncheckedCreateWithoutAgentInput> | AgentRatingCreateWithoutAgentInput[] | AgentRatingUncheckedCreateWithoutAgentInput[]
    connectOrCreate?: AgentRatingCreateOrConnectWithoutAgentInput | AgentRatingCreateOrConnectWithoutAgentInput[]
    createMany?: AgentRatingCreateManyAgentInputEnvelope
    connect?: AgentRatingWhereUniqueInput | AgentRatingWhereUniqueInput[]
  }

  export type AgentWalletCreateNestedOneWithoutAgentInput = {
    create?: XOR<AgentWalletCreateWithoutAgentInput, AgentWalletUncheckedCreateWithoutAgentInput>
    connectOrCreate?: AgentWalletCreateOrConnectWithoutAgentInput
    connect?: AgentWalletWhereUniqueInput
  }

  export type WalletPayoutCreateNestedManyWithoutAgentInput = {
    create?: XOR<WalletPayoutCreateWithoutAgentInput, WalletPayoutUncheckedCreateWithoutAgentInput> | WalletPayoutCreateWithoutAgentInput[] | WalletPayoutUncheckedCreateWithoutAgentInput[]
    connectOrCreate?: WalletPayoutCreateOrConnectWithoutAgentInput | WalletPayoutCreateOrConnectWithoutAgentInput[]
    createMany?: WalletPayoutCreateManyAgentInputEnvelope
    connect?: WalletPayoutWhereUniqueInput | WalletPayoutWhereUniqueInput[]
  }

  export type PaymentCreateNestedManyWithoutAgentInput = {
    create?: XOR<PaymentCreateWithoutAgentInput, PaymentUncheckedCreateWithoutAgentInput> | PaymentCreateWithoutAgentInput[] | PaymentUncheckedCreateWithoutAgentInput[]
    connectOrCreate?: PaymentCreateOrConnectWithoutAgentInput | PaymentCreateOrConnectWithoutAgentInput[]
    createMany?: PaymentCreateManyAgentInputEnvelope
    connect?: PaymentWhereUniqueInput | PaymentWhereUniqueInput[]
  }

  export type PayrollCreateNestedManyWithoutAgentInput = {
    create?: XOR<PayrollCreateWithoutAgentInput, PayrollUncheckedCreateWithoutAgentInput> | PayrollCreateWithoutAgentInput[] | PayrollUncheckedCreateWithoutAgentInput[]
    connectOrCreate?: PayrollCreateOrConnectWithoutAgentInput | PayrollCreateOrConnectWithoutAgentInput[]
    createMany?: PayrollCreateManyAgentInputEnvelope
    connect?: PayrollWhereUniqueInput | PayrollWhereUniqueInput[]
  }

  export type AgentScheduleCreateNestedManyWithoutAgentInput = {
    create?: XOR<AgentScheduleCreateWithoutAgentInput, AgentScheduleUncheckedCreateWithoutAgentInput> | AgentScheduleCreateWithoutAgentInput[] | AgentScheduleUncheckedCreateWithoutAgentInput[]
    connectOrCreate?: AgentScheduleCreateOrConnectWithoutAgentInput | AgentScheduleCreateOrConnectWithoutAgentInput[]
    createMany?: AgentScheduleCreateManyAgentInputEnvelope
    connect?: AgentScheduleWhereUniqueInput | AgentScheduleWhereUniqueInput[]
  }

  export type OrderUncheckedCreateNestedManyWithoutAgentInput = {
    create?: XOR<OrderCreateWithoutAgentInput, OrderUncheckedCreateWithoutAgentInput> | OrderCreateWithoutAgentInput[] | OrderUncheckedCreateWithoutAgentInput[]
    connectOrCreate?: OrderCreateOrConnectWithoutAgentInput | OrderCreateOrConnectWithoutAgentInput[]
    createMany?: OrderCreateManyAgentInputEnvelope
    connect?: OrderWhereUniqueInput | OrderWhereUniqueInput[]
  }

  export type AgentDocumentUncheckedCreateNestedManyWithoutAgentInput = {
    create?: XOR<AgentDocumentCreateWithoutAgentInput, AgentDocumentUncheckedCreateWithoutAgentInput> | AgentDocumentCreateWithoutAgentInput[] | AgentDocumentUncheckedCreateWithoutAgentInput[]
    connectOrCreate?: AgentDocumentCreateOrConnectWithoutAgentInput | AgentDocumentCreateOrConnectWithoutAgentInput[]
    createMany?: AgentDocumentCreateManyAgentInputEnvelope
    connect?: AgentDocumentWhereUniqueInput | AgentDocumentWhereUniqueInput[]
  }

  export type AgentLocationUncheckedCreateNestedManyWithoutAgentInput = {
    create?: XOR<AgentLocationCreateWithoutAgentInput, AgentLocationUncheckedCreateWithoutAgentInput> | AgentLocationCreateWithoutAgentInput[] | AgentLocationUncheckedCreateWithoutAgentInput[]
    connectOrCreate?: AgentLocationCreateOrConnectWithoutAgentInput | AgentLocationCreateOrConnectWithoutAgentInput[]
    createMany?: AgentLocationCreateManyAgentInputEnvelope
    connect?: AgentLocationWhereUniqueInput | AgentLocationWhereUniqueInput[]
  }

  export type SupportTicketUncheckedCreateNestedManyWithoutAgentInput = {
    create?: XOR<SupportTicketCreateWithoutAgentInput, SupportTicketUncheckedCreateWithoutAgentInput> | SupportTicketCreateWithoutAgentInput[] | SupportTicketUncheckedCreateWithoutAgentInput[]
    connectOrCreate?: SupportTicketCreateOrConnectWithoutAgentInput | SupportTicketCreateOrConnectWithoutAgentInput[]
    createMany?: SupportTicketCreateManyAgentInputEnvelope
    connect?: SupportTicketWhereUniqueInput | SupportTicketWhereUniqueInput[]
  }

  export type AgentRatingUncheckedCreateNestedManyWithoutAgentInput = {
    create?: XOR<AgentRatingCreateWithoutAgentInput, AgentRatingUncheckedCreateWithoutAgentInput> | AgentRatingCreateWithoutAgentInput[] | AgentRatingUncheckedCreateWithoutAgentInput[]
    connectOrCreate?: AgentRatingCreateOrConnectWithoutAgentInput | AgentRatingCreateOrConnectWithoutAgentInput[]
    createMany?: AgentRatingCreateManyAgentInputEnvelope
    connect?: AgentRatingWhereUniqueInput | AgentRatingWhereUniqueInput[]
  }

  export type AgentWalletUncheckedCreateNestedOneWithoutAgentInput = {
    create?: XOR<AgentWalletCreateWithoutAgentInput, AgentWalletUncheckedCreateWithoutAgentInput>
    connectOrCreate?: AgentWalletCreateOrConnectWithoutAgentInput
    connect?: AgentWalletWhereUniqueInput
  }

  export type WalletPayoutUncheckedCreateNestedManyWithoutAgentInput = {
    create?: XOR<WalletPayoutCreateWithoutAgentInput, WalletPayoutUncheckedCreateWithoutAgentInput> | WalletPayoutCreateWithoutAgentInput[] | WalletPayoutUncheckedCreateWithoutAgentInput[]
    connectOrCreate?: WalletPayoutCreateOrConnectWithoutAgentInput | WalletPayoutCreateOrConnectWithoutAgentInput[]
    createMany?: WalletPayoutCreateManyAgentInputEnvelope
    connect?: WalletPayoutWhereUniqueInput | WalletPayoutWhereUniqueInput[]
  }

  export type PaymentUncheckedCreateNestedManyWithoutAgentInput = {
    create?: XOR<PaymentCreateWithoutAgentInput, PaymentUncheckedCreateWithoutAgentInput> | PaymentCreateWithoutAgentInput[] | PaymentUncheckedCreateWithoutAgentInput[]
    connectOrCreate?: PaymentCreateOrConnectWithoutAgentInput | PaymentCreateOrConnectWithoutAgentInput[]
    createMany?: PaymentCreateManyAgentInputEnvelope
    connect?: PaymentWhereUniqueInput | PaymentWhereUniqueInput[]
  }

  export type PayrollUncheckedCreateNestedManyWithoutAgentInput = {
    create?: XOR<PayrollCreateWithoutAgentInput, PayrollUncheckedCreateWithoutAgentInput> | PayrollCreateWithoutAgentInput[] | PayrollUncheckedCreateWithoutAgentInput[]
    connectOrCreate?: PayrollCreateOrConnectWithoutAgentInput | PayrollCreateOrConnectWithoutAgentInput[]
    createMany?: PayrollCreateManyAgentInputEnvelope
    connect?: PayrollWhereUniqueInput | PayrollWhereUniqueInput[]
  }

  export type AgentScheduleUncheckedCreateNestedManyWithoutAgentInput = {
    create?: XOR<AgentScheduleCreateWithoutAgentInput, AgentScheduleUncheckedCreateWithoutAgentInput> | AgentScheduleCreateWithoutAgentInput[] | AgentScheduleUncheckedCreateWithoutAgentInput[]
    connectOrCreate?: AgentScheduleCreateOrConnectWithoutAgentInput | AgentScheduleCreateOrConnectWithoutAgentInput[]
    createMany?: AgentScheduleCreateManyAgentInputEnvelope
    connect?: AgentScheduleWhereUniqueInput | AgentScheduleWhereUniqueInput[]
  }

  export type EnumVehicleTypeFieldUpdateOperationsInput = {
    set?: $Enums.VehicleType
  }

  export type EnumAgentStatusFieldUpdateOperationsInput = {
    set?: $Enums.AgentStatus
  }

  export type NullableFloatFieldUpdateOperationsInput = {
    set?: number | null
    increment?: number
    decrement?: number
    multiply?: number
    divide?: number
  }

  export type IntFieldUpdateOperationsInput = {
    set?: number
    increment?: number
    decrement?: number
    multiply?: number
    divide?: number
  }

  export type FloatFieldUpdateOperationsInput = {
    set?: number
    increment?: number
    decrement?: number
    multiply?: number
    divide?: number
  }

  export type UserUpdateOneRequiredWithoutAgentNestedInput = {
    create?: XOR<UserCreateWithoutAgentInput, UserUncheckedCreateWithoutAgentInput>
    connectOrCreate?: UserCreateOrConnectWithoutAgentInput
    upsert?: UserUpsertWithoutAgentInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutAgentInput, UserUpdateWithoutAgentInput>, UserUncheckedUpdateWithoutAgentInput>
  }

  export type OrderUpdateManyWithoutAgentNestedInput = {
    create?: XOR<OrderCreateWithoutAgentInput, OrderUncheckedCreateWithoutAgentInput> | OrderCreateWithoutAgentInput[] | OrderUncheckedCreateWithoutAgentInput[]
    connectOrCreate?: OrderCreateOrConnectWithoutAgentInput | OrderCreateOrConnectWithoutAgentInput[]
    upsert?: OrderUpsertWithWhereUniqueWithoutAgentInput | OrderUpsertWithWhereUniqueWithoutAgentInput[]
    createMany?: OrderCreateManyAgentInputEnvelope
    set?: OrderWhereUniqueInput | OrderWhereUniqueInput[]
    disconnect?: OrderWhereUniqueInput | OrderWhereUniqueInput[]
    delete?: OrderWhereUniqueInput | OrderWhereUniqueInput[]
    connect?: OrderWhereUniqueInput | OrderWhereUniqueInput[]
    update?: OrderUpdateWithWhereUniqueWithoutAgentInput | OrderUpdateWithWhereUniqueWithoutAgentInput[]
    updateMany?: OrderUpdateManyWithWhereWithoutAgentInput | OrderUpdateManyWithWhereWithoutAgentInput[]
    deleteMany?: OrderScalarWhereInput | OrderScalarWhereInput[]
  }

  export type OrderUpdateOneWithoutCurrentAgentNestedInput = {
    create?: XOR<OrderCreateWithoutCurrentAgentInput, OrderUncheckedCreateWithoutCurrentAgentInput>
    connectOrCreate?: OrderCreateOrConnectWithoutCurrentAgentInput
    upsert?: OrderUpsertWithoutCurrentAgentInput
    disconnect?: OrderWhereInput | boolean
    delete?: OrderWhereInput | boolean
    connect?: OrderWhereUniqueInput
    update?: XOR<XOR<OrderUpdateToOneWithWhereWithoutCurrentAgentInput, OrderUpdateWithoutCurrentAgentInput>, OrderUncheckedUpdateWithoutCurrentAgentInput>
  }

  export type AgentDocumentUpdateManyWithoutAgentNestedInput = {
    create?: XOR<AgentDocumentCreateWithoutAgentInput, AgentDocumentUncheckedCreateWithoutAgentInput> | AgentDocumentCreateWithoutAgentInput[] | AgentDocumentUncheckedCreateWithoutAgentInput[]
    connectOrCreate?: AgentDocumentCreateOrConnectWithoutAgentInput | AgentDocumentCreateOrConnectWithoutAgentInput[]
    upsert?: AgentDocumentUpsertWithWhereUniqueWithoutAgentInput | AgentDocumentUpsertWithWhereUniqueWithoutAgentInput[]
    createMany?: AgentDocumentCreateManyAgentInputEnvelope
    set?: AgentDocumentWhereUniqueInput | AgentDocumentWhereUniqueInput[]
    disconnect?: AgentDocumentWhereUniqueInput | AgentDocumentWhereUniqueInput[]
    delete?: AgentDocumentWhereUniqueInput | AgentDocumentWhereUniqueInput[]
    connect?: AgentDocumentWhereUniqueInput | AgentDocumentWhereUniqueInput[]
    update?: AgentDocumentUpdateWithWhereUniqueWithoutAgentInput | AgentDocumentUpdateWithWhereUniqueWithoutAgentInput[]
    updateMany?: AgentDocumentUpdateManyWithWhereWithoutAgentInput | AgentDocumentUpdateManyWithWhereWithoutAgentInput[]
    deleteMany?: AgentDocumentScalarWhereInput | AgentDocumentScalarWhereInput[]
  }

  export type AgentLocationUpdateManyWithoutAgentNestedInput = {
    create?: XOR<AgentLocationCreateWithoutAgentInput, AgentLocationUncheckedCreateWithoutAgentInput> | AgentLocationCreateWithoutAgentInput[] | AgentLocationUncheckedCreateWithoutAgentInput[]
    connectOrCreate?: AgentLocationCreateOrConnectWithoutAgentInput | AgentLocationCreateOrConnectWithoutAgentInput[]
    upsert?: AgentLocationUpsertWithWhereUniqueWithoutAgentInput | AgentLocationUpsertWithWhereUniqueWithoutAgentInput[]
    createMany?: AgentLocationCreateManyAgentInputEnvelope
    set?: AgentLocationWhereUniqueInput | AgentLocationWhereUniqueInput[]
    disconnect?: AgentLocationWhereUniqueInput | AgentLocationWhereUniqueInput[]
    delete?: AgentLocationWhereUniqueInput | AgentLocationWhereUniqueInput[]
    connect?: AgentLocationWhereUniqueInput | AgentLocationWhereUniqueInput[]
    update?: AgentLocationUpdateWithWhereUniqueWithoutAgentInput | AgentLocationUpdateWithWhereUniqueWithoutAgentInput[]
    updateMany?: AgentLocationUpdateManyWithWhereWithoutAgentInput | AgentLocationUpdateManyWithWhereWithoutAgentInput[]
    deleteMany?: AgentLocationScalarWhereInput | AgentLocationScalarWhereInput[]
  }

  export type SupportTicketUpdateManyWithoutAgentNestedInput = {
    create?: XOR<SupportTicketCreateWithoutAgentInput, SupportTicketUncheckedCreateWithoutAgentInput> | SupportTicketCreateWithoutAgentInput[] | SupportTicketUncheckedCreateWithoutAgentInput[]
    connectOrCreate?: SupportTicketCreateOrConnectWithoutAgentInput | SupportTicketCreateOrConnectWithoutAgentInput[]
    upsert?: SupportTicketUpsertWithWhereUniqueWithoutAgentInput | SupportTicketUpsertWithWhereUniqueWithoutAgentInput[]
    createMany?: SupportTicketCreateManyAgentInputEnvelope
    set?: SupportTicketWhereUniqueInput | SupportTicketWhereUniqueInput[]
    disconnect?: SupportTicketWhereUniqueInput | SupportTicketWhereUniqueInput[]
    delete?: SupportTicketWhereUniqueInput | SupportTicketWhereUniqueInput[]
    connect?: SupportTicketWhereUniqueInput | SupportTicketWhereUniqueInput[]
    update?: SupportTicketUpdateWithWhereUniqueWithoutAgentInput | SupportTicketUpdateWithWhereUniqueWithoutAgentInput[]
    updateMany?: SupportTicketUpdateManyWithWhereWithoutAgentInput | SupportTicketUpdateManyWithWhereWithoutAgentInput[]
    deleteMany?: SupportTicketScalarWhereInput | SupportTicketScalarWhereInput[]
  }

  export type AgentRatingUpdateManyWithoutAgentNestedInput = {
    create?: XOR<AgentRatingCreateWithoutAgentInput, AgentRatingUncheckedCreateWithoutAgentInput> | AgentRatingCreateWithoutAgentInput[] | AgentRatingUncheckedCreateWithoutAgentInput[]
    connectOrCreate?: AgentRatingCreateOrConnectWithoutAgentInput | AgentRatingCreateOrConnectWithoutAgentInput[]
    upsert?: AgentRatingUpsertWithWhereUniqueWithoutAgentInput | AgentRatingUpsertWithWhereUniqueWithoutAgentInput[]
    createMany?: AgentRatingCreateManyAgentInputEnvelope
    set?: AgentRatingWhereUniqueInput | AgentRatingWhereUniqueInput[]
    disconnect?: AgentRatingWhereUniqueInput | AgentRatingWhereUniqueInput[]
    delete?: AgentRatingWhereUniqueInput | AgentRatingWhereUniqueInput[]
    connect?: AgentRatingWhereUniqueInput | AgentRatingWhereUniqueInput[]
    update?: AgentRatingUpdateWithWhereUniqueWithoutAgentInput | AgentRatingUpdateWithWhereUniqueWithoutAgentInput[]
    updateMany?: AgentRatingUpdateManyWithWhereWithoutAgentInput | AgentRatingUpdateManyWithWhereWithoutAgentInput[]
    deleteMany?: AgentRatingScalarWhereInput | AgentRatingScalarWhereInput[]
  }

  export type AgentWalletUpdateOneWithoutAgentNestedInput = {
    create?: XOR<AgentWalletCreateWithoutAgentInput, AgentWalletUncheckedCreateWithoutAgentInput>
    connectOrCreate?: AgentWalletCreateOrConnectWithoutAgentInput
    upsert?: AgentWalletUpsertWithoutAgentInput
    disconnect?: AgentWalletWhereInput | boolean
    delete?: AgentWalletWhereInput | boolean
    connect?: AgentWalletWhereUniqueInput
    update?: XOR<XOR<AgentWalletUpdateToOneWithWhereWithoutAgentInput, AgentWalletUpdateWithoutAgentInput>, AgentWalletUncheckedUpdateWithoutAgentInput>
  }

  export type WalletPayoutUpdateManyWithoutAgentNestedInput = {
    create?: XOR<WalletPayoutCreateWithoutAgentInput, WalletPayoutUncheckedCreateWithoutAgentInput> | WalletPayoutCreateWithoutAgentInput[] | WalletPayoutUncheckedCreateWithoutAgentInput[]
    connectOrCreate?: WalletPayoutCreateOrConnectWithoutAgentInput | WalletPayoutCreateOrConnectWithoutAgentInput[]
    upsert?: WalletPayoutUpsertWithWhereUniqueWithoutAgentInput | WalletPayoutUpsertWithWhereUniqueWithoutAgentInput[]
    createMany?: WalletPayoutCreateManyAgentInputEnvelope
    set?: WalletPayoutWhereUniqueInput | WalletPayoutWhereUniqueInput[]
    disconnect?: WalletPayoutWhereUniqueInput | WalletPayoutWhereUniqueInput[]
    delete?: WalletPayoutWhereUniqueInput | WalletPayoutWhereUniqueInput[]
    connect?: WalletPayoutWhereUniqueInput | WalletPayoutWhereUniqueInput[]
    update?: WalletPayoutUpdateWithWhereUniqueWithoutAgentInput | WalletPayoutUpdateWithWhereUniqueWithoutAgentInput[]
    updateMany?: WalletPayoutUpdateManyWithWhereWithoutAgentInput | WalletPayoutUpdateManyWithWhereWithoutAgentInput[]
    deleteMany?: WalletPayoutScalarWhereInput | WalletPayoutScalarWhereInput[]
  }

  export type PaymentUpdateManyWithoutAgentNestedInput = {
    create?: XOR<PaymentCreateWithoutAgentInput, PaymentUncheckedCreateWithoutAgentInput> | PaymentCreateWithoutAgentInput[] | PaymentUncheckedCreateWithoutAgentInput[]
    connectOrCreate?: PaymentCreateOrConnectWithoutAgentInput | PaymentCreateOrConnectWithoutAgentInput[]
    upsert?: PaymentUpsertWithWhereUniqueWithoutAgentInput | PaymentUpsertWithWhereUniqueWithoutAgentInput[]
    createMany?: PaymentCreateManyAgentInputEnvelope
    set?: PaymentWhereUniqueInput | PaymentWhereUniqueInput[]
    disconnect?: PaymentWhereUniqueInput | PaymentWhereUniqueInput[]
    delete?: PaymentWhereUniqueInput | PaymentWhereUniqueInput[]
    connect?: PaymentWhereUniqueInput | PaymentWhereUniqueInput[]
    update?: PaymentUpdateWithWhereUniqueWithoutAgentInput | PaymentUpdateWithWhereUniqueWithoutAgentInput[]
    updateMany?: PaymentUpdateManyWithWhereWithoutAgentInput | PaymentUpdateManyWithWhereWithoutAgentInput[]
    deleteMany?: PaymentScalarWhereInput | PaymentScalarWhereInput[]
  }

  export type PayrollUpdateManyWithoutAgentNestedInput = {
    create?: XOR<PayrollCreateWithoutAgentInput, PayrollUncheckedCreateWithoutAgentInput> | PayrollCreateWithoutAgentInput[] | PayrollUncheckedCreateWithoutAgentInput[]
    connectOrCreate?: PayrollCreateOrConnectWithoutAgentInput | PayrollCreateOrConnectWithoutAgentInput[]
    upsert?: PayrollUpsertWithWhereUniqueWithoutAgentInput | PayrollUpsertWithWhereUniqueWithoutAgentInput[]
    createMany?: PayrollCreateManyAgentInputEnvelope
    set?: PayrollWhereUniqueInput | PayrollWhereUniqueInput[]
    disconnect?: PayrollWhereUniqueInput | PayrollWhereUniqueInput[]
    delete?: PayrollWhereUniqueInput | PayrollWhereUniqueInput[]
    connect?: PayrollWhereUniqueInput | PayrollWhereUniqueInput[]
    update?: PayrollUpdateWithWhereUniqueWithoutAgentInput | PayrollUpdateWithWhereUniqueWithoutAgentInput[]
    updateMany?: PayrollUpdateManyWithWhereWithoutAgentInput | PayrollUpdateManyWithWhereWithoutAgentInput[]
    deleteMany?: PayrollScalarWhereInput | PayrollScalarWhereInput[]
  }

  export type AgentScheduleUpdateManyWithoutAgentNestedInput = {
    create?: XOR<AgentScheduleCreateWithoutAgentInput, AgentScheduleUncheckedCreateWithoutAgentInput> | AgentScheduleCreateWithoutAgentInput[] | AgentScheduleUncheckedCreateWithoutAgentInput[]
    connectOrCreate?: AgentScheduleCreateOrConnectWithoutAgentInput | AgentScheduleCreateOrConnectWithoutAgentInput[]
    upsert?: AgentScheduleUpsertWithWhereUniqueWithoutAgentInput | AgentScheduleUpsertWithWhereUniqueWithoutAgentInput[]
    createMany?: AgentScheduleCreateManyAgentInputEnvelope
    set?: AgentScheduleWhereUniqueInput | AgentScheduleWhereUniqueInput[]
    disconnect?: AgentScheduleWhereUniqueInput | AgentScheduleWhereUniqueInput[]
    delete?: AgentScheduleWhereUniqueInput | AgentScheduleWhereUniqueInput[]
    connect?: AgentScheduleWhereUniqueInput | AgentScheduleWhereUniqueInput[]
    update?: AgentScheduleUpdateWithWhereUniqueWithoutAgentInput | AgentScheduleUpdateWithWhereUniqueWithoutAgentInput[]
    updateMany?: AgentScheduleUpdateManyWithWhereWithoutAgentInput | AgentScheduleUpdateManyWithWhereWithoutAgentInput[]
    deleteMany?: AgentScheduleScalarWhereInput | AgentScheduleScalarWhereInput[]
  }

  export type OrderUncheckedUpdateManyWithoutAgentNestedInput = {
    create?: XOR<OrderCreateWithoutAgentInput, OrderUncheckedCreateWithoutAgentInput> | OrderCreateWithoutAgentInput[] | OrderUncheckedCreateWithoutAgentInput[]
    connectOrCreate?: OrderCreateOrConnectWithoutAgentInput | OrderCreateOrConnectWithoutAgentInput[]
    upsert?: OrderUpsertWithWhereUniqueWithoutAgentInput | OrderUpsertWithWhereUniqueWithoutAgentInput[]
    createMany?: OrderCreateManyAgentInputEnvelope
    set?: OrderWhereUniqueInput | OrderWhereUniqueInput[]
    disconnect?: OrderWhereUniqueInput | OrderWhereUniqueInput[]
    delete?: OrderWhereUniqueInput | OrderWhereUniqueInput[]
    connect?: OrderWhereUniqueInput | OrderWhereUniqueInput[]
    update?: OrderUpdateWithWhereUniqueWithoutAgentInput | OrderUpdateWithWhereUniqueWithoutAgentInput[]
    updateMany?: OrderUpdateManyWithWhereWithoutAgentInput | OrderUpdateManyWithWhereWithoutAgentInput[]
    deleteMany?: OrderScalarWhereInput | OrderScalarWhereInput[]
  }

  export type AgentDocumentUncheckedUpdateManyWithoutAgentNestedInput = {
    create?: XOR<AgentDocumentCreateWithoutAgentInput, AgentDocumentUncheckedCreateWithoutAgentInput> | AgentDocumentCreateWithoutAgentInput[] | AgentDocumentUncheckedCreateWithoutAgentInput[]
    connectOrCreate?: AgentDocumentCreateOrConnectWithoutAgentInput | AgentDocumentCreateOrConnectWithoutAgentInput[]
    upsert?: AgentDocumentUpsertWithWhereUniqueWithoutAgentInput | AgentDocumentUpsertWithWhereUniqueWithoutAgentInput[]
    createMany?: AgentDocumentCreateManyAgentInputEnvelope
    set?: AgentDocumentWhereUniqueInput | AgentDocumentWhereUniqueInput[]
    disconnect?: AgentDocumentWhereUniqueInput | AgentDocumentWhereUniqueInput[]
    delete?: AgentDocumentWhereUniqueInput | AgentDocumentWhereUniqueInput[]
    connect?: AgentDocumentWhereUniqueInput | AgentDocumentWhereUniqueInput[]
    update?: AgentDocumentUpdateWithWhereUniqueWithoutAgentInput | AgentDocumentUpdateWithWhereUniqueWithoutAgentInput[]
    updateMany?: AgentDocumentUpdateManyWithWhereWithoutAgentInput | AgentDocumentUpdateManyWithWhereWithoutAgentInput[]
    deleteMany?: AgentDocumentScalarWhereInput | AgentDocumentScalarWhereInput[]
  }

  export type AgentLocationUncheckedUpdateManyWithoutAgentNestedInput = {
    create?: XOR<AgentLocationCreateWithoutAgentInput, AgentLocationUncheckedCreateWithoutAgentInput> | AgentLocationCreateWithoutAgentInput[] | AgentLocationUncheckedCreateWithoutAgentInput[]
    connectOrCreate?: AgentLocationCreateOrConnectWithoutAgentInput | AgentLocationCreateOrConnectWithoutAgentInput[]
    upsert?: AgentLocationUpsertWithWhereUniqueWithoutAgentInput | AgentLocationUpsertWithWhereUniqueWithoutAgentInput[]
    createMany?: AgentLocationCreateManyAgentInputEnvelope
    set?: AgentLocationWhereUniqueInput | AgentLocationWhereUniqueInput[]
    disconnect?: AgentLocationWhereUniqueInput | AgentLocationWhereUniqueInput[]
    delete?: AgentLocationWhereUniqueInput | AgentLocationWhereUniqueInput[]
    connect?: AgentLocationWhereUniqueInput | AgentLocationWhereUniqueInput[]
    update?: AgentLocationUpdateWithWhereUniqueWithoutAgentInput | AgentLocationUpdateWithWhereUniqueWithoutAgentInput[]
    updateMany?: AgentLocationUpdateManyWithWhereWithoutAgentInput | AgentLocationUpdateManyWithWhereWithoutAgentInput[]
    deleteMany?: AgentLocationScalarWhereInput | AgentLocationScalarWhereInput[]
  }

  export type SupportTicketUncheckedUpdateManyWithoutAgentNestedInput = {
    create?: XOR<SupportTicketCreateWithoutAgentInput, SupportTicketUncheckedCreateWithoutAgentInput> | SupportTicketCreateWithoutAgentInput[] | SupportTicketUncheckedCreateWithoutAgentInput[]
    connectOrCreate?: SupportTicketCreateOrConnectWithoutAgentInput | SupportTicketCreateOrConnectWithoutAgentInput[]
    upsert?: SupportTicketUpsertWithWhereUniqueWithoutAgentInput | SupportTicketUpsertWithWhereUniqueWithoutAgentInput[]
    createMany?: SupportTicketCreateManyAgentInputEnvelope
    set?: SupportTicketWhereUniqueInput | SupportTicketWhereUniqueInput[]
    disconnect?: SupportTicketWhereUniqueInput | SupportTicketWhereUniqueInput[]
    delete?: SupportTicketWhereUniqueInput | SupportTicketWhereUniqueInput[]
    connect?: SupportTicketWhereUniqueInput | SupportTicketWhereUniqueInput[]
    update?: SupportTicketUpdateWithWhereUniqueWithoutAgentInput | SupportTicketUpdateWithWhereUniqueWithoutAgentInput[]
    updateMany?: SupportTicketUpdateManyWithWhereWithoutAgentInput | SupportTicketUpdateManyWithWhereWithoutAgentInput[]
    deleteMany?: SupportTicketScalarWhereInput | SupportTicketScalarWhereInput[]
  }

  export type AgentRatingUncheckedUpdateManyWithoutAgentNestedInput = {
    create?: XOR<AgentRatingCreateWithoutAgentInput, AgentRatingUncheckedCreateWithoutAgentInput> | AgentRatingCreateWithoutAgentInput[] | AgentRatingUncheckedCreateWithoutAgentInput[]
    connectOrCreate?: AgentRatingCreateOrConnectWithoutAgentInput | AgentRatingCreateOrConnectWithoutAgentInput[]
    upsert?: AgentRatingUpsertWithWhereUniqueWithoutAgentInput | AgentRatingUpsertWithWhereUniqueWithoutAgentInput[]
    createMany?: AgentRatingCreateManyAgentInputEnvelope
    set?: AgentRatingWhereUniqueInput | AgentRatingWhereUniqueInput[]
    disconnect?: AgentRatingWhereUniqueInput | AgentRatingWhereUniqueInput[]
    delete?: AgentRatingWhereUniqueInput | AgentRatingWhereUniqueInput[]
    connect?: AgentRatingWhereUniqueInput | AgentRatingWhereUniqueInput[]
    update?: AgentRatingUpdateWithWhereUniqueWithoutAgentInput | AgentRatingUpdateWithWhereUniqueWithoutAgentInput[]
    updateMany?: AgentRatingUpdateManyWithWhereWithoutAgentInput | AgentRatingUpdateManyWithWhereWithoutAgentInput[]
    deleteMany?: AgentRatingScalarWhereInput | AgentRatingScalarWhereInput[]
  }

  export type AgentWalletUncheckedUpdateOneWithoutAgentNestedInput = {
    create?: XOR<AgentWalletCreateWithoutAgentInput, AgentWalletUncheckedCreateWithoutAgentInput>
    connectOrCreate?: AgentWalletCreateOrConnectWithoutAgentInput
    upsert?: AgentWalletUpsertWithoutAgentInput
    disconnect?: AgentWalletWhereInput | boolean
    delete?: AgentWalletWhereInput | boolean
    connect?: AgentWalletWhereUniqueInput
    update?: XOR<XOR<AgentWalletUpdateToOneWithWhereWithoutAgentInput, AgentWalletUpdateWithoutAgentInput>, AgentWalletUncheckedUpdateWithoutAgentInput>
  }

  export type WalletPayoutUncheckedUpdateManyWithoutAgentNestedInput = {
    create?: XOR<WalletPayoutCreateWithoutAgentInput, WalletPayoutUncheckedCreateWithoutAgentInput> | WalletPayoutCreateWithoutAgentInput[] | WalletPayoutUncheckedCreateWithoutAgentInput[]
    connectOrCreate?: WalletPayoutCreateOrConnectWithoutAgentInput | WalletPayoutCreateOrConnectWithoutAgentInput[]
    upsert?: WalletPayoutUpsertWithWhereUniqueWithoutAgentInput | WalletPayoutUpsertWithWhereUniqueWithoutAgentInput[]
    createMany?: WalletPayoutCreateManyAgentInputEnvelope
    set?: WalletPayoutWhereUniqueInput | WalletPayoutWhereUniqueInput[]
    disconnect?: WalletPayoutWhereUniqueInput | WalletPayoutWhereUniqueInput[]
    delete?: WalletPayoutWhereUniqueInput | WalletPayoutWhereUniqueInput[]
    connect?: WalletPayoutWhereUniqueInput | WalletPayoutWhereUniqueInput[]
    update?: WalletPayoutUpdateWithWhereUniqueWithoutAgentInput | WalletPayoutUpdateWithWhereUniqueWithoutAgentInput[]
    updateMany?: WalletPayoutUpdateManyWithWhereWithoutAgentInput | WalletPayoutUpdateManyWithWhereWithoutAgentInput[]
    deleteMany?: WalletPayoutScalarWhereInput | WalletPayoutScalarWhereInput[]
  }

  export type PaymentUncheckedUpdateManyWithoutAgentNestedInput = {
    create?: XOR<PaymentCreateWithoutAgentInput, PaymentUncheckedCreateWithoutAgentInput> | PaymentCreateWithoutAgentInput[] | PaymentUncheckedCreateWithoutAgentInput[]
    connectOrCreate?: PaymentCreateOrConnectWithoutAgentInput | PaymentCreateOrConnectWithoutAgentInput[]
    upsert?: PaymentUpsertWithWhereUniqueWithoutAgentInput | PaymentUpsertWithWhereUniqueWithoutAgentInput[]
    createMany?: PaymentCreateManyAgentInputEnvelope
    set?: PaymentWhereUniqueInput | PaymentWhereUniqueInput[]
    disconnect?: PaymentWhereUniqueInput | PaymentWhereUniqueInput[]
    delete?: PaymentWhereUniqueInput | PaymentWhereUniqueInput[]
    connect?: PaymentWhereUniqueInput | PaymentWhereUniqueInput[]
    update?: PaymentUpdateWithWhereUniqueWithoutAgentInput | PaymentUpdateWithWhereUniqueWithoutAgentInput[]
    updateMany?: PaymentUpdateManyWithWhereWithoutAgentInput | PaymentUpdateManyWithWhereWithoutAgentInput[]
    deleteMany?: PaymentScalarWhereInput | PaymentScalarWhereInput[]
  }

  export type PayrollUncheckedUpdateManyWithoutAgentNestedInput = {
    create?: XOR<PayrollCreateWithoutAgentInput, PayrollUncheckedCreateWithoutAgentInput> | PayrollCreateWithoutAgentInput[] | PayrollUncheckedCreateWithoutAgentInput[]
    connectOrCreate?: PayrollCreateOrConnectWithoutAgentInput | PayrollCreateOrConnectWithoutAgentInput[]
    upsert?: PayrollUpsertWithWhereUniqueWithoutAgentInput | PayrollUpsertWithWhereUniqueWithoutAgentInput[]
    createMany?: PayrollCreateManyAgentInputEnvelope
    set?: PayrollWhereUniqueInput | PayrollWhereUniqueInput[]
    disconnect?: PayrollWhereUniqueInput | PayrollWhereUniqueInput[]
    delete?: PayrollWhereUniqueInput | PayrollWhereUniqueInput[]
    connect?: PayrollWhereUniqueInput | PayrollWhereUniqueInput[]
    update?: PayrollUpdateWithWhereUniqueWithoutAgentInput | PayrollUpdateWithWhereUniqueWithoutAgentInput[]
    updateMany?: PayrollUpdateManyWithWhereWithoutAgentInput | PayrollUpdateManyWithWhereWithoutAgentInput[]
    deleteMany?: PayrollScalarWhereInput | PayrollScalarWhereInput[]
  }

  export type AgentScheduleUncheckedUpdateManyWithoutAgentNestedInput = {
    create?: XOR<AgentScheduleCreateWithoutAgentInput, AgentScheduleUncheckedCreateWithoutAgentInput> | AgentScheduleCreateWithoutAgentInput[] | AgentScheduleUncheckedCreateWithoutAgentInput[]
    connectOrCreate?: AgentScheduleCreateOrConnectWithoutAgentInput | AgentScheduleCreateOrConnectWithoutAgentInput[]
    upsert?: AgentScheduleUpsertWithWhereUniqueWithoutAgentInput | AgentScheduleUpsertWithWhereUniqueWithoutAgentInput[]
    createMany?: AgentScheduleCreateManyAgentInputEnvelope
    set?: AgentScheduleWhereUniqueInput | AgentScheduleWhereUniqueInput[]
    disconnect?: AgentScheduleWhereUniqueInput | AgentScheduleWhereUniqueInput[]
    delete?: AgentScheduleWhereUniqueInput | AgentScheduleWhereUniqueInput[]
    connect?: AgentScheduleWhereUniqueInput | AgentScheduleWhereUniqueInput[]
    update?: AgentScheduleUpdateWithWhereUniqueWithoutAgentInput | AgentScheduleUpdateWithWhereUniqueWithoutAgentInput[]
    updateMany?: AgentScheduleUpdateManyWithWhereWithoutAgentInput | AgentScheduleUpdateManyWithWhereWithoutAgentInput[]
    deleteMany?: AgentScheduleScalarWhereInput | AgentScheduleScalarWhereInput[]
  }

  export type AgentCreateNestedOneWithoutDocumentsInput = {
    create?: XOR<AgentCreateWithoutDocumentsInput, AgentUncheckedCreateWithoutDocumentsInput>
    connectOrCreate?: AgentCreateOrConnectWithoutDocumentsInput
    connect?: AgentWhereUniqueInput
  }

  export type AgentUpdateOneRequiredWithoutDocumentsNestedInput = {
    create?: XOR<AgentCreateWithoutDocumentsInput, AgentUncheckedCreateWithoutDocumentsInput>
    connectOrCreate?: AgentCreateOrConnectWithoutDocumentsInput
    upsert?: AgentUpsertWithoutDocumentsInput
    connect?: AgentWhereUniqueInput
    update?: XOR<XOR<AgentUpdateToOneWithWhereWithoutDocumentsInput, AgentUpdateWithoutDocumentsInput>, AgentUncheckedUpdateWithoutDocumentsInput>
  }

  export type AgentCreateNestedOneWithoutLocationHistoryInput = {
    create?: XOR<AgentCreateWithoutLocationHistoryInput, AgentUncheckedCreateWithoutLocationHistoryInput>
    connectOrCreate?: AgentCreateOrConnectWithoutLocationHistoryInput
    connect?: AgentWhereUniqueInput
  }

  export type AgentUpdateOneRequiredWithoutLocationHistoryNestedInput = {
    create?: XOR<AgentCreateWithoutLocationHistoryInput, AgentUncheckedCreateWithoutLocationHistoryInput>
    connectOrCreate?: AgentCreateOrConnectWithoutLocationHistoryInput
    upsert?: AgentUpsertWithoutLocationHistoryInput
    connect?: AgentWhereUniqueInput
    update?: XOR<XOR<AgentUpdateToOneWithWhereWithoutLocationHistoryInput, AgentUpdateWithoutLocationHistoryInput>, AgentUncheckedUpdateWithoutLocationHistoryInput>
  }

  export type UserCreateNestedOneWithoutPartnerInput = {
    create?: XOR<UserCreateWithoutPartnerInput, UserUncheckedCreateWithoutPartnerInput>
    connectOrCreate?: UserCreateOrConnectWithoutPartnerInput
    connect?: UserWhereUniqueInput
  }

  export type OrderCreateNestedManyWithoutPartnerInput = {
    create?: XOR<OrderCreateWithoutPartnerInput, OrderUncheckedCreateWithoutPartnerInput> | OrderCreateWithoutPartnerInput[] | OrderUncheckedCreateWithoutPartnerInput[]
    connectOrCreate?: OrderCreateOrConnectWithoutPartnerInput | OrderCreateOrConnectWithoutPartnerInput[]
    createMany?: OrderCreateManyPartnerInputEnvelope
    connect?: OrderWhereUniqueInput | OrderWhereUniqueInput[]
  }

  export type SupportTicketCreateNestedManyWithoutPartnerInput = {
    create?: XOR<SupportTicketCreateWithoutPartnerInput, SupportTicketUncheckedCreateWithoutPartnerInput> | SupportTicketCreateWithoutPartnerInput[] | SupportTicketUncheckedCreateWithoutPartnerInput[]
    connectOrCreate?: SupportTicketCreateOrConnectWithoutPartnerInput | SupportTicketCreateOrConnectWithoutPartnerInput[]
    createMany?: SupportTicketCreateManyPartnerInputEnvelope
    connect?: SupportTicketWhereUniqueInput | SupportTicketWhereUniqueInput[]
  }

  export type PartnerDailyStatsCreateNestedManyWithoutPartnerInput = {
    create?: XOR<PartnerDailyStatsCreateWithoutPartnerInput, PartnerDailyStatsUncheckedCreateWithoutPartnerInput> | PartnerDailyStatsCreateWithoutPartnerInput[] | PartnerDailyStatsUncheckedCreateWithoutPartnerInput[]
    connectOrCreate?: PartnerDailyStatsCreateOrConnectWithoutPartnerInput | PartnerDailyStatsCreateOrConnectWithoutPartnerInput[]
    createMany?: PartnerDailyStatsCreateManyPartnerInputEnvelope
    connect?: PartnerDailyStatsWhereUniqueInput | PartnerDailyStatsWhereUniqueInput[]
  }

  export type AgentRatingCreateNestedManyWithoutPartnerInput = {
    create?: XOR<AgentRatingCreateWithoutPartnerInput, AgentRatingUncheckedCreateWithoutPartnerInput> | AgentRatingCreateWithoutPartnerInput[] | AgentRatingUncheckedCreateWithoutPartnerInput[]
    connectOrCreate?: AgentRatingCreateOrConnectWithoutPartnerInput | AgentRatingCreateOrConnectWithoutPartnerInput[]
    createMany?: AgentRatingCreateManyPartnerInputEnvelope
    connect?: AgentRatingWhereUniqueInput | AgentRatingWhereUniqueInput[]
  }

  export type PartnerRevenueCreateNestedManyWithoutPartnerInput = {
    create?: XOR<PartnerRevenueCreateWithoutPartnerInput, PartnerRevenueUncheckedCreateWithoutPartnerInput> | PartnerRevenueCreateWithoutPartnerInput[] | PartnerRevenueUncheckedCreateWithoutPartnerInput[]
    connectOrCreate?: PartnerRevenueCreateOrConnectWithoutPartnerInput | PartnerRevenueCreateOrConnectWithoutPartnerInput[]
    createMany?: PartnerRevenueCreateManyPartnerInputEnvelope
    connect?: PartnerRevenueWhereUniqueInput | PartnerRevenueWhereUniqueInput[]
  }

  export type PlatformRevenueCreateNestedManyWithoutPartnerInput = {
    create?: XOR<PlatformRevenueCreateWithoutPartnerInput, PlatformRevenueUncheckedCreateWithoutPartnerInput> | PlatformRevenueCreateWithoutPartnerInput[] | PlatformRevenueUncheckedCreateWithoutPartnerInput[]
    connectOrCreate?: PlatformRevenueCreateOrConnectWithoutPartnerInput | PlatformRevenueCreateOrConnectWithoutPartnerInput[]
    createMany?: PlatformRevenueCreateManyPartnerInputEnvelope
    connect?: PlatformRevenueWhereUniqueInput | PlatformRevenueWhereUniqueInput[]
  }

  export type OrderUncheckedCreateNestedManyWithoutPartnerInput = {
    create?: XOR<OrderCreateWithoutPartnerInput, OrderUncheckedCreateWithoutPartnerInput> | OrderCreateWithoutPartnerInput[] | OrderUncheckedCreateWithoutPartnerInput[]
    connectOrCreate?: OrderCreateOrConnectWithoutPartnerInput | OrderCreateOrConnectWithoutPartnerInput[]
    createMany?: OrderCreateManyPartnerInputEnvelope
    connect?: OrderWhereUniqueInput | OrderWhereUniqueInput[]
  }

  export type SupportTicketUncheckedCreateNestedManyWithoutPartnerInput = {
    create?: XOR<SupportTicketCreateWithoutPartnerInput, SupportTicketUncheckedCreateWithoutPartnerInput> | SupportTicketCreateWithoutPartnerInput[] | SupportTicketUncheckedCreateWithoutPartnerInput[]
    connectOrCreate?: SupportTicketCreateOrConnectWithoutPartnerInput | SupportTicketCreateOrConnectWithoutPartnerInput[]
    createMany?: SupportTicketCreateManyPartnerInputEnvelope
    connect?: SupportTicketWhereUniqueInput | SupportTicketWhereUniqueInput[]
  }

  export type PartnerDailyStatsUncheckedCreateNestedManyWithoutPartnerInput = {
    create?: XOR<PartnerDailyStatsCreateWithoutPartnerInput, PartnerDailyStatsUncheckedCreateWithoutPartnerInput> | PartnerDailyStatsCreateWithoutPartnerInput[] | PartnerDailyStatsUncheckedCreateWithoutPartnerInput[]
    connectOrCreate?: PartnerDailyStatsCreateOrConnectWithoutPartnerInput | PartnerDailyStatsCreateOrConnectWithoutPartnerInput[]
    createMany?: PartnerDailyStatsCreateManyPartnerInputEnvelope
    connect?: PartnerDailyStatsWhereUniqueInput | PartnerDailyStatsWhereUniqueInput[]
  }

  export type AgentRatingUncheckedCreateNestedManyWithoutPartnerInput = {
    create?: XOR<AgentRatingCreateWithoutPartnerInput, AgentRatingUncheckedCreateWithoutPartnerInput> | AgentRatingCreateWithoutPartnerInput[] | AgentRatingUncheckedCreateWithoutPartnerInput[]
    connectOrCreate?: AgentRatingCreateOrConnectWithoutPartnerInput | AgentRatingCreateOrConnectWithoutPartnerInput[]
    createMany?: AgentRatingCreateManyPartnerInputEnvelope
    connect?: AgentRatingWhereUniqueInput | AgentRatingWhereUniqueInput[]
  }

  export type PartnerRevenueUncheckedCreateNestedManyWithoutPartnerInput = {
    create?: XOR<PartnerRevenueCreateWithoutPartnerInput, PartnerRevenueUncheckedCreateWithoutPartnerInput> | PartnerRevenueCreateWithoutPartnerInput[] | PartnerRevenueUncheckedCreateWithoutPartnerInput[]
    connectOrCreate?: PartnerRevenueCreateOrConnectWithoutPartnerInput | PartnerRevenueCreateOrConnectWithoutPartnerInput[]
    createMany?: PartnerRevenueCreateManyPartnerInputEnvelope
    connect?: PartnerRevenueWhereUniqueInput | PartnerRevenueWhereUniqueInput[]
  }

  export type PlatformRevenueUncheckedCreateNestedManyWithoutPartnerInput = {
    create?: XOR<PlatformRevenueCreateWithoutPartnerInput, PlatformRevenueUncheckedCreateWithoutPartnerInput> | PlatformRevenueCreateWithoutPartnerInput[] | PlatformRevenueUncheckedCreateWithoutPartnerInput[]
    connectOrCreate?: PlatformRevenueCreateOrConnectWithoutPartnerInput | PlatformRevenueCreateOrConnectWithoutPartnerInput[]
    createMany?: PlatformRevenueCreateManyPartnerInputEnvelope
    connect?: PlatformRevenueWhereUniqueInput | PlatformRevenueWhereUniqueInput[]
  }

  export type UserUpdateOneRequiredWithoutPartnerNestedInput = {
    create?: XOR<UserCreateWithoutPartnerInput, UserUncheckedCreateWithoutPartnerInput>
    connectOrCreate?: UserCreateOrConnectWithoutPartnerInput
    upsert?: UserUpsertWithoutPartnerInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutPartnerInput, UserUpdateWithoutPartnerInput>, UserUncheckedUpdateWithoutPartnerInput>
  }

  export type OrderUpdateManyWithoutPartnerNestedInput = {
    create?: XOR<OrderCreateWithoutPartnerInput, OrderUncheckedCreateWithoutPartnerInput> | OrderCreateWithoutPartnerInput[] | OrderUncheckedCreateWithoutPartnerInput[]
    connectOrCreate?: OrderCreateOrConnectWithoutPartnerInput | OrderCreateOrConnectWithoutPartnerInput[]
    upsert?: OrderUpsertWithWhereUniqueWithoutPartnerInput | OrderUpsertWithWhereUniqueWithoutPartnerInput[]
    createMany?: OrderCreateManyPartnerInputEnvelope
    set?: OrderWhereUniqueInput | OrderWhereUniqueInput[]
    disconnect?: OrderWhereUniqueInput | OrderWhereUniqueInput[]
    delete?: OrderWhereUniqueInput | OrderWhereUniqueInput[]
    connect?: OrderWhereUniqueInput | OrderWhereUniqueInput[]
    update?: OrderUpdateWithWhereUniqueWithoutPartnerInput | OrderUpdateWithWhereUniqueWithoutPartnerInput[]
    updateMany?: OrderUpdateManyWithWhereWithoutPartnerInput | OrderUpdateManyWithWhereWithoutPartnerInput[]
    deleteMany?: OrderScalarWhereInput | OrderScalarWhereInput[]
  }

  export type SupportTicketUpdateManyWithoutPartnerNestedInput = {
    create?: XOR<SupportTicketCreateWithoutPartnerInput, SupportTicketUncheckedCreateWithoutPartnerInput> | SupportTicketCreateWithoutPartnerInput[] | SupportTicketUncheckedCreateWithoutPartnerInput[]
    connectOrCreate?: SupportTicketCreateOrConnectWithoutPartnerInput | SupportTicketCreateOrConnectWithoutPartnerInput[]
    upsert?: SupportTicketUpsertWithWhereUniqueWithoutPartnerInput | SupportTicketUpsertWithWhereUniqueWithoutPartnerInput[]
    createMany?: SupportTicketCreateManyPartnerInputEnvelope
    set?: SupportTicketWhereUniqueInput | SupportTicketWhereUniqueInput[]
    disconnect?: SupportTicketWhereUniqueInput | SupportTicketWhereUniqueInput[]
    delete?: SupportTicketWhereUniqueInput | SupportTicketWhereUniqueInput[]
    connect?: SupportTicketWhereUniqueInput | SupportTicketWhereUniqueInput[]
    update?: SupportTicketUpdateWithWhereUniqueWithoutPartnerInput | SupportTicketUpdateWithWhereUniqueWithoutPartnerInput[]
    updateMany?: SupportTicketUpdateManyWithWhereWithoutPartnerInput | SupportTicketUpdateManyWithWhereWithoutPartnerInput[]
    deleteMany?: SupportTicketScalarWhereInput | SupportTicketScalarWhereInput[]
  }

  export type PartnerDailyStatsUpdateManyWithoutPartnerNestedInput = {
    create?: XOR<PartnerDailyStatsCreateWithoutPartnerInput, PartnerDailyStatsUncheckedCreateWithoutPartnerInput> | PartnerDailyStatsCreateWithoutPartnerInput[] | PartnerDailyStatsUncheckedCreateWithoutPartnerInput[]
    connectOrCreate?: PartnerDailyStatsCreateOrConnectWithoutPartnerInput | PartnerDailyStatsCreateOrConnectWithoutPartnerInput[]
    upsert?: PartnerDailyStatsUpsertWithWhereUniqueWithoutPartnerInput | PartnerDailyStatsUpsertWithWhereUniqueWithoutPartnerInput[]
    createMany?: PartnerDailyStatsCreateManyPartnerInputEnvelope
    set?: PartnerDailyStatsWhereUniqueInput | PartnerDailyStatsWhereUniqueInput[]
    disconnect?: PartnerDailyStatsWhereUniqueInput | PartnerDailyStatsWhereUniqueInput[]
    delete?: PartnerDailyStatsWhereUniqueInput | PartnerDailyStatsWhereUniqueInput[]
    connect?: PartnerDailyStatsWhereUniqueInput | PartnerDailyStatsWhereUniqueInput[]
    update?: PartnerDailyStatsUpdateWithWhereUniqueWithoutPartnerInput | PartnerDailyStatsUpdateWithWhereUniqueWithoutPartnerInput[]
    updateMany?: PartnerDailyStatsUpdateManyWithWhereWithoutPartnerInput | PartnerDailyStatsUpdateManyWithWhereWithoutPartnerInput[]
    deleteMany?: PartnerDailyStatsScalarWhereInput | PartnerDailyStatsScalarWhereInput[]
  }

  export type AgentRatingUpdateManyWithoutPartnerNestedInput = {
    create?: XOR<AgentRatingCreateWithoutPartnerInput, AgentRatingUncheckedCreateWithoutPartnerInput> | AgentRatingCreateWithoutPartnerInput[] | AgentRatingUncheckedCreateWithoutPartnerInput[]
    connectOrCreate?: AgentRatingCreateOrConnectWithoutPartnerInput | AgentRatingCreateOrConnectWithoutPartnerInput[]
    upsert?: AgentRatingUpsertWithWhereUniqueWithoutPartnerInput | AgentRatingUpsertWithWhereUniqueWithoutPartnerInput[]
    createMany?: AgentRatingCreateManyPartnerInputEnvelope
    set?: AgentRatingWhereUniqueInput | AgentRatingWhereUniqueInput[]
    disconnect?: AgentRatingWhereUniqueInput | AgentRatingWhereUniqueInput[]
    delete?: AgentRatingWhereUniqueInput | AgentRatingWhereUniqueInput[]
    connect?: AgentRatingWhereUniqueInput | AgentRatingWhereUniqueInput[]
    update?: AgentRatingUpdateWithWhereUniqueWithoutPartnerInput | AgentRatingUpdateWithWhereUniqueWithoutPartnerInput[]
    updateMany?: AgentRatingUpdateManyWithWhereWithoutPartnerInput | AgentRatingUpdateManyWithWhereWithoutPartnerInput[]
    deleteMany?: AgentRatingScalarWhereInput | AgentRatingScalarWhereInput[]
  }

  export type PartnerRevenueUpdateManyWithoutPartnerNestedInput = {
    create?: XOR<PartnerRevenueCreateWithoutPartnerInput, PartnerRevenueUncheckedCreateWithoutPartnerInput> | PartnerRevenueCreateWithoutPartnerInput[] | PartnerRevenueUncheckedCreateWithoutPartnerInput[]
    connectOrCreate?: PartnerRevenueCreateOrConnectWithoutPartnerInput | PartnerRevenueCreateOrConnectWithoutPartnerInput[]
    upsert?: PartnerRevenueUpsertWithWhereUniqueWithoutPartnerInput | PartnerRevenueUpsertWithWhereUniqueWithoutPartnerInput[]
    createMany?: PartnerRevenueCreateManyPartnerInputEnvelope
    set?: PartnerRevenueWhereUniqueInput | PartnerRevenueWhereUniqueInput[]
    disconnect?: PartnerRevenueWhereUniqueInput | PartnerRevenueWhereUniqueInput[]
    delete?: PartnerRevenueWhereUniqueInput | PartnerRevenueWhereUniqueInput[]
    connect?: PartnerRevenueWhereUniqueInput | PartnerRevenueWhereUniqueInput[]
    update?: PartnerRevenueUpdateWithWhereUniqueWithoutPartnerInput | PartnerRevenueUpdateWithWhereUniqueWithoutPartnerInput[]
    updateMany?: PartnerRevenueUpdateManyWithWhereWithoutPartnerInput | PartnerRevenueUpdateManyWithWhereWithoutPartnerInput[]
    deleteMany?: PartnerRevenueScalarWhereInput | PartnerRevenueScalarWhereInput[]
  }

  export type PlatformRevenueUpdateManyWithoutPartnerNestedInput = {
    create?: XOR<PlatformRevenueCreateWithoutPartnerInput, PlatformRevenueUncheckedCreateWithoutPartnerInput> | PlatformRevenueCreateWithoutPartnerInput[] | PlatformRevenueUncheckedCreateWithoutPartnerInput[]
    connectOrCreate?: PlatformRevenueCreateOrConnectWithoutPartnerInput | PlatformRevenueCreateOrConnectWithoutPartnerInput[]
    upsert?: PlatformRevenueUpsertWithWhereUniqueWithoutPartnerInput | PlatformRevenueUpsertWithWhereUniqueWithoutPartnerInput[]
    createMany?: PlatformRevenueCreateManyPartnerInputEnvelope
    set?: PlatformRevenueWhereUniqueInput | PlatformRevenueWhereUniqueInput[]
    disconnect?: PlatformRevenueWhereUniqueInput | PlatformRevenueWhereUniqueInput[]
    delete?: PlatformRevenueWhereUniqueInput | PlatformRevenueWhereUniqueInput[]
    connect?: PlatformRevenueWhereUniqueInput | PlatformRevenueWhereUniqueInput[]
    update?: PlatformRevenueUpdateWithWhereUniqueWithoutPartnerInput | PlatformRevenueUpdateWithWhereUniqueWithoutPartnerInput[]
    updateMany?: PlatformRevenueUpdateManyWithWhereWithoutPartnerInput | PlatformRevenueUpdateManyWithWhereWithoutPartnerInput[]
    deleteMany?: PlatformRevenueScalarWhereInput | PlatformRevenueScalarWhereInput[]
  }

  export type OrderUncheckedUpdateManyWithoutPartnerNestedInput = {
    create?: XOR<OrderCreateWithoutPartnerInput, OrderUncheckedCreateWithoutPartnerInput> | OrderCreateWithoutPartnerInput[] | OrderUncheckedCreateWithoutPartnerInput[]
    connectOrCreate?: OrderCreateOrConnectWithoutPartnerInput | OrderCreateOrConnectWithoutPartnerInput[]
    upsert?: OrderUpsertWithWhereUniqueWithoutPartnerInput | OrderUpsertWithWhereUniqueWithoutPartnerInput[]
    createMany?: OrderCreateManyPartnerInputEnvelope
    set?: OrderWhereUniqueInput | OrderWhereUniqueInput[]
    disconnect?: OrderWhereUniqueInput | OrderWhereUniqueInput[]
    delete?: OrderWhereUniqueInput | OrderWhereUniqueInput[]
    connect?: OrderWhereUniqueInput | OrderWhereUniqueInput[]
    update?: OrderUpdateWithWhereUniqueWithoutPartnerInput | OrderUpdateWithWhereUniqueWithoutPartnerInput[]
    updateMany?: OrderUpdateManyWithWhereWithoutPartnerInput | OrderUpdateManyWithWhereWithoutPartnerInput[]
    deleteMany?: OrderScalarWhereInput | OrderScalarWhereInput[]
  }

  export type SupportTicketUncheckedUpdateManyWithoutPartnerNestedInput = {
    create?: XOR<SupportTicketCreateWithoutPartnerInput, SupportTicketUncheckedCreateWithoutPartnerInput> | SupportTicketCreateWithoutPartnerInput[] | SupportTicketUncheckedCreateWithoutPartnerInput[]
    connectOrCreate?: SupportTicketCreateOrConnectWithoutPartnerInput | SupportTicketCreateOrConnectWithoutPartnerInput[]
    upsert?: SupportTicketUpsertWithWhereUniqueWithoutPartnerInput | SupportTicketUpsertWithWhereUniqueWithoutPartnerInput[]
    createMany?: SupportTicketCreateManyPartnerInputEnvelope
    set?: SupportTicketWhereUniqueInput | SupportTicketWhereUniqueInput[]
    disconnect?: SupportTicketWhereUniqueInput | SupportTicketWhereUniqueInput[]
    delete?: SupportTicketWhereUniqueInput | SupportTicketWhereUniqueInput[]
    connect?: SupportTicketWhereUniqueInput | SupportTicketWhereUniqueInput[]
    update?: SupportTicketUpdateWithWhereUniqueWithoutPartnerInput | SupportTicketUpdateWithWhereUniqueWithoutPartnerInput[]
    updateMany?: SupportTicketUpdateManyWithWhereWithoutPartnerInput | SupportTicketUpdateManyWithWhereWithoutPartnerInput[]
    deleteMany?: SupportTicketScalarWhereInput | SupportTicketScalarWhereInput[]
  }

  export type PartnerDailyStatsUncheckedUpdateManyWithoutPartnerNestedInput = {
    create?: XOR<PartnerDailyStatsCreateWithoutPartnerInput, PartnerDailyStatsUncheckedCreateWithoutPartnerInput> | PartnerDailyStatsCreateWithoutPartnerInput[] | PartnerDailyStatsUncheckedCreateWithoutPartnerInput[]
    connectOrCreate?: PartnerDailyStatsCreateOrConnectWithoutPartnerInput | PartnerDailyStatsCreateOrConnectWithoutPartnerInput[]
    upsert?: PartnerDailyStatsUpsertWithWhereUniqueWithoutPartnerInput | PartnerDailyStatsUpsertWithWhereUniqueWithoutPartnerInput[]
    createMany?: PartnerDailyStatsCreateManyPartnerInputEnvelope
    set?: PartnerDailyStatsWhereUniqueInput | PartnerDailyStatsWhereUniqueInput[]
    disconnect?: PartnerDailyStatsWhereUniqueInput | PartnerDailyStatsWhereUniqueInput[]
    delete?: PartnerDailyStatsWhereUniqueInput | PartnerDailyStatsWhereUniqueInput[]
    connect?: PartnerDailyStatsWhereUniqueInput | PartnerDailyStatsWhereUniqueInput[]
    update?: PartnerDailyStatsUpdateWithWhereUniqueWithoutPartnerInput | PartnerDailyStatsUpdateWithWhereUniqueWithoutPartnerInput[]
    updateMany?: PartnerDailyStatsUpdateManyWithWhereWithoutPartnerInput | PartnerDailyStatsUpdateManyWithWhereWithoutPartnerInput[]
    deleteMany?: PartnerDailyStatsScalarWhereInput | PartnerDailyStatsScalarWhereInput[]
  }

  export type AgentRatingUncheckedUpdateManyWithoutPartnerNestedInput = {
    create?: XOR<AgentRatingCreateWithoutPartnerInput, AgentRatingUncheckedCreateWithoutPartnerInput> | AgentRatingCreateWithoutPartnerInput[] | AgentRatingUncheckedCreateWithoutPartnerInput[]
    connectOrCreate?: AgentRatingCreateOrConnectWithoutPartnerInput | AgentRatingCreateOrConnectWithoutPartnerInput[]
    upsert?: AgentRatingUpsertWithWhereUniqueWithoutPartnerInput | AgentRatingUpsertWithWhereUniqueWithoutPartnerInput[]
    createMany?: AgentRatingCreateManyPartnerInputEnvelope
    set?: AgentRatingWhereUniqueInput | AgentRatingWhereUniqueInput[]
    disconnect?: AgentRatingWhereUniqueInput | AgentRatingWhereUniqueInput[]
    delete?: AgentRatingWhereUniqueInput | AgentRatingWhereUniqueInput[]
    connect?: AgentRatingWhereUniqueInput | AgentRatingWhereUniqueInput[]
    update?: AgentRatingUpdateWithWhereUniqueWithoutPartnerInput | AgentRatingUpdateWithWhereUniqueWithoutPartnerInput[]
    updateMany?: AgentRatingUpdateManyWithWhereWithoutPartnerInput | AgentRatingUpdateManyWithWhereWithoutPartnerInput[]
    deleteMany?: AgentRatingScalarWhereInput | AgentRatingScalarWhereInput[]
  }

  export type PartnerRevenueUncheckedUpdateManyWithoutPartnerNestedInput = {
    create?: XOR<PartnerRevenueCreateWithoutPartnerInput, PartnerRevenueUncheckedCreateWithoutPartnerInput> | PartnerRevenueCreateWithoutPartnerInput[] | PartnerRevenueUncheckedCreateWithoutPartnerInput[]
    connectOrCreate?: PartnerRevenueCreateOrConnectWithoutPartnerInput | PartnerRevenueCreateOrConnectWithoutPartnerInput[]
    upsert?: PartnerRevenueUpsertWithWhereUniqueWithoutPartnerInput | PartnerRevenueUpsertWithWhereUniqueWithoutPartnerInput[]
    createMany?: PartnerRevenueCreateManyPartnerInputEnvelope
    set?: PartnerRevenueWhereUniqueInput | PartnerRevenueWhereUniqueInput[]
    disconnect?: PartnerRevenueWhereUniqueInput | PartnerRevenueWhereUniqueInput[]
    delete?: PartnerRevenueWhereUniqueInput | PartnerRevenueWhereUniqueInput[]
    connect?: PartnerRevenueWhereUniqueInput | PartnerRevenueWhereUniqueInput[]
    update?: PartnerRevenueUpdateWithWhereUniqueWithoutPartnerInput | PartnerRevenueUpdateWithWhereUniqueWithoutPartnerInput[]
    updateMany?: PartnerRevenueUpdateManyWithWhereWithoutPartnerInput | PartnerRevenueUpdateManyWithWhereWithoutPartnerInput[]
    deleteMany?: PartnerRevenueScalarWhereInput | PartnerRevenueScalarWhereInput[]
  }

  export type PlatformRevenueUncheckedUpdateManyWithoutPartnerNestedInput = {
    create?: XOR<PlatformRevenueCreateWithoutPartnerInput, PlatformRevenueUncheckedCreateWithoutPartnerInput> | PlatformRevenueCreateWithoutPartnerInput[] | PlatformRevenueUncheckedCreateWithoutPartnerInput[]
    connectOrCreate?: PlatformRevenueCreateOrConnectWithoutPartnerInput | PlatformRevenueCreateOrConnectWithoutPartnerInput[]
    upsert?: PlatformRevenueUpsertWithWhereUniqueWithoutPartnerInput | PlatformRevenueUpsertWithWhereUniqueWithoutPartnerInput[]
    createMany?: PlatformRevenueCreateManyPartnerInputEnvelope
    set?: PlatformRevenueWhereUniqueInput | PlatformRevenueWhereUniqueInput[]
    disconnect?: PlatformRevenueWhereUniqueInput | PlatformRevenueWhereUniqueInput[]
    delete?: PlatformRevenueWhereUniqueInput | PlatformRevenueWhereUniqueInput[]
    connect?: PlatformRevenueWhereUniqueInput | PlatformRevenueWhereUniqueInput[]
    update?: PlatformRevenueUpdateWithWhereUniqueWithoutPartnerInput | PlatformRevenueUpdateWithWhereUniqueWithoutPartnerInput[]
    updateMany?: PlatformRevenueUpdateManyWithWhereWithoutPartnerInput | PlatformRevenueUpdateManyWithWhereWithoutPartnerInput[]
    deleteMany?: PlatformRevenueScalarWhereInput | PlatformRevenueScalarWhereInput[]
  }

  export type PartnerCreateNestedOneWithoutOrdersInput = {
    create?: XOR<PartnerCreateWithoutOrdersInput, PartnerUncheckedCreateWithoutOrdersInput>
    connectOrCreate?: PartnerCreateOrConnectWithoutOrdersInput
    connect?: PartnerWhereUniqueInput
  }

  export type AgentCreateNestedOneWithoutOrdersInput = {
    create?: XOR<AgentCreateWithoutOrdersInput, AgentUncheckedCreateWithoutOrdersInput>
    connectOrCreate?: AgentCreateOrConnectWithoutOrdersInput
    connect?: AgentWhereUniqueInput
  }

  export type AgentCreateNestedOneWithoutCurrentOrderInput = {
    create?: XOR<AgentCreateWithoutCurrentOrderInput, AgentUncheckedCreateWithoutCurrentOrderInput>
    connectOrCreate?: AgentCreateOrConnectWithoutCurrentOrderInput
    connect?: AgentWhereUniqueInput
  }

  export type SupportTicketCreateNestedManyWithoutOrderInput = {
    create?: XOR<SupportTicketCreateWithoutOrderInput, SupportTicketUncheckedCreateWithoutOrderInput> | SupportTicketCreateWithoutOrderInput[] | SupportTicketUncheckedCreateWithoutOrderInput[]
    connectOrCreate?: SupportTicketCreateOrConnectWithoutOrderInput | SupportTicketCreateOrConnectWithoutOrderInput[]
    createMany?: SupportTicketCreateManyOrderInputEnvelope
    connect?: SupportTicketWhereUniqueInput | SupportTicketWhereUniqueInput[]
  }

  export type AgentRatingCreateNestedOneWithoutOrderInput = {
    create?: XOR<AgentRatingCreateWithoutOrderInput, AgentRatingUncheckedCreateWithoutOrderInput>
    connectOrCreate?: AgentRatingCreateOrConnectWithoutOrderInput
    connect?: AgentRatingWhereUniqueInput
  }

  export type PaymentCreateNestedManyWithoutOrderInput = {
    create?: XOR<PaymentCreateWithoutOrderInput, PaymentUncheckedCreateWithoutOrderInput> | PaymentCreateWithoutOrderInput[] | PaymentUncheckedCreateWithoutOrderInput[]
    connectOrCreate?: PaymentCreateOrConnectWithoutOrderInput | PaymentCreateOrConnectWithoutOrderInput[]
    createMany?: PaymentCreateManyOrderInputEnvelope
    connect?: PaymentWhereUniqueInput | PaymentWhereUniqueInput[]
  }

  export type PartnerRevenueCreateNestedOneWithoutOrderInput = {
    create?: XOR<PartnerRevenueCreateWithoutOrderInput, PartnerRevenueUncheckedCreateWithoutOrderInput>
    connectOrCreate?: PartnerRevenueCreateOrConnectWithoutOrderInput
    connect?: PartnerRevenueWhereUniqueInput
  }

  export type PlatformRevenueCreateNestedOneWithoutOrderInput = {
    create?: XOR<PlatformRevenueCreateWithoutOrderInput, PlatformRevenueUncheckedCreateWithoutOrderInput>
    connectOrCreate?: PlatformRevenueCreateOrConnectWithoutOrderInput
    connect?: PlatformRevenueWhereUniqueInput
  }

  export type WalletTransactionCreateNestedManyWithoutOrderInput = {
    create?: XOR<WalletTransactionCreateWithoutOrderInput, WalletTransactionUncheckedCreateWithoutOrderInput> | WalletTransactionCreateWithoutOrderInput[] | WalletTransactionUncheckedCreateWithoutOrderInput[]
    connectOrCreate?: WalletTransactionCreateOrConnectWithoutOrderInput | WalletTransactionCreateOrConnectWithoutOrderInput[]
    createMany?: WalletTransactionCreateManyOrderInputEnvelope
    connect?: WalletTransactionWhereUniqueInput | WalletTransactionWhereUniqueInput[]
  }

  export type AgentUncheckedCreateNestedOneWithoutCurrentOrderInput = {
    create?: XOR<AgentCreateWithoutCurrentOrderInput, AgentUncheckedCreateWithoutCurrentOrderInput>
    connectOrCreate?: AgentCreateOrConnectWithoutCurrentOrderInput
    connect?: AgentWhereUniqueInput
  }

  export type SupportTicketUncheckedCreateNestedManyWithoutOrderInput = {
    create?: XOR<SupportTicketCreateWithoutOrderInput, SupportTicketUncheckedCreateWithoutOrderInput> | SupportTicketCreateWithoutOrderInput[] | SupportTicketUncheckedCreateWithoutOrderInput[]
    connectOrCreate?: SupportTicketCreateOrConnectWithoutOrderInput | SupportTicketCreateOrConnectWithoutOrderInput[]
    createMany?: SupportTicketCreateManyOrderInputEnvelope
    connect?: SupportTicketWhereUniqueInput | SupportTicketWhereUniqueInput[]
  }

  export type AgentRatingUncheckedCreateNestedOneWithoutOrderInput = {
    create?: XOR<AgentRatingCreateWithoutOrderInput, AgentRatingUncheckedCreateWithoutOrderInput>
    connectOrCreate?: AgentRatingCreateOrConnectWithoutOrderInput
    connect?: AgentRatingWhereUniqueInput
  }

  export type PaymentUncheckedCreateNestedManyWithoutOrderInput = {
    create?: XOR<PaymentCreateWithoutOrderInput, PaymentUncheckedCreateWithoutOrderInput> | PaymentCreateWithoutOrderInput[] | PaymentUncheckedCreateWithoutOrderInput[]
    connectOrCreate?: PaymentCreateOrConnectWithoutOrderInput | PaymentCreateOrConnectWithoutOrderInput[]
    createMany?: PaymentCreateManyOrderInputEnvelope
    connect?: PaymentWhereUniqueInput | PaymentWhereUniqueInput[]
  }

  export type PartnerRevenueUncheckedCreateNestedOneWithoutOrderInput = {
    create?: XOR<PartnerRevenueCreateWithoutOrderInput, PartnerRevenueUncheckedCreateWithoutOrderInput>
    connectOrCreate?: PartnerRevenueCreateOrConnectWithoutOrderInput
    connect?: PartnerRevenueWhereUniqueInput
  }

  export type PlatformRevenueUncheckedCreateNestedOneWithoutOrderInput = {
    create?: XOR<PlatformRevenueCreateWithoutOrderInput, PlatformRevenueUncheckedCreateWithoutOrderInput>
    connectOrCreate?: PlatformRevenueCreateOrConnectWithoutOrderInput
    connect?: PlatformRevenueWhereUniqueInput
  }

  export type WalletTransactionUncheckedCreateNestedManyWithoutOrderInput = {
    create?: XOR<WalletTransactionCreateWithoutOrderInput, WalletTransactionUncheckedCreateWithoutOrderInput> | WalletTransactionCreateWithoutOrderInput[] | WalletTransactionUncheckedCreateWithoutOrderInput[]
    connectOrCreate?: WalletTransactionCreateOrConnectWithoutOrderInput | WalletTransactionCreateOrConnectWithoutOrderInput[]
    createMany?: WalletTransactionCreateManyOrderInputEnvelope
    connect?: WalletTransactionWhereUniqueInput | WalletTransactionWhereUniqueInput[]
  }

  export type EnumOrderStatusFieldUpdateOperationsInput = {
    set?: $Enums.OrderStatus
  }

  export type NullableIntFieldUpdateOperationsInput = {
    set?: number | null
    increment?: number
    decrement?: number
    multiply?: number
    divide?: number
  }

  export type PartnerUpdateOneRequiredWithoutOrdersNestedInput = {
    create?: XOR<PartnerCreateWithoutOrdersInput, PartnerUncheckedCreateWithoutOrdersInput>
    connectOrCreate?: PartnerCreateOrConnectWithoutOrdersInput
    upsert?: PartnerUpsertWithoutOrdersInput
    connect?: PartnerWhereUniqueInput
    update?: XOR<XOR<PartnerUpdateToOneWithWhereWithoutOrdersInput, PartnerUpdateWithoutOrdersInput>, PartnerUncheckedUpdateWithoutOrdersInput>
  }

  export type AgentUpdateOneWithoutOrdersNestedInput = {
    create?: XOR<AgentCreateWithoutOrdersInput, AgentUncheckedCreateWithoutOrdersInput>
    connectOrCreate?: AgentCreateOrConnectWithoutOrdersInput
    upsert?: AgentUpsertWithoutOrdersInput
    disconnect?: AgentWhereInput | boolean
    delete?: AgentWhereInput | boolean
    connect?: AgentWhereUniqueInput
    update?: XOR<XOR<AgentUpdateToOneWithWhereWithoutOrdersInput, AgentUpdateWithoutOrdersInput>, AgentUncheckedUpdateWithoutOrdersInput>
  }

  export type AgentUpdateOneWithoutCurrentOrderNestedInput = {
    create?: XOR<AgentCreateWithoutCurrentOrderInput, AgentUncheckedCreateWithoutCurrentOrderInput>
    connectOrCreate?: AgentCreateOrConnectWithoutCurrentOrderInput
    upsert?: AgentUpsertWithoutCurrentOrderInput
    disconnect?: AgentWhereInput | boolean
    delete?: AgentWhereInput | boolean
    connect?: AgentWhereUniqueInput
    update?: XOR<XOR<AgentUpdateToOneWithWhereWithoutCurrentOrderInput, AgentUpdateWithoutCurrentOrderInput>, AgentUncheckedUpdateWithoutCurrentOrderInput>
  }

  export type SupportTicketUpdateManyWithoutOrderNestedInput = {
    create?: XOR<SupportTicketCreateWithoutOrderInput, SupportTicketUncheckedCreateWithoutOrderInput> | SupportTicketCreateWithoutOrderInput[] | SupportTicketUncheckedCreateWithoutOrderInput[]
    connectOrCreate?: SupportTicketCreateOrConnectWithoutOrderInput | SupportTicketCreateOrConnectWithoutOrderInput[]
    upsert?: SupportTicketUpsertWithWhereUniqueWithoutOrderInput | SupportTicketUpsertWithWhereUniqueWithoutOrderInput[]
    createMany?: SupportTicketCreateManyOrderInputEnvelope
    set?: SupportTicketWhereUniqueInput | SupportTicketWhereUniqueInput[]
    disconnect?: SupportTicketWhereUniqueInput | SupportTicketWhereUniqueInput[]
    delete?: SupportTicketWhereUniqueInput | SupportTicketWhereUniqueInput[]
    connect?: SupportTicketWhereUniqueInput | SupportTicketWhereUniqueInput[]
    update?: SupportTicketUpdateWithWhereUniqueWithoutOrderInput | SupportTicketUpdateWithWhereUniqueWithoutOrderInput[]
    updateMany?: SupportTicketUpdateManyWithWhereWithoutOrderInput | SupportTicketUpdateManyWithWhereWithoutOrderInput[]
    deleteMany?: SupportTicketScalarWhereInput | SupportTicketScalarWhereInput[]
  }

  export type AgentRatingUpdateOneWithoutOrderNestedInput = {
    create?: XOR<AgentRatingCreateWithoutOrderInput, AgentRatingUncheckedCreateWithoutOrderInput>
    connectOrCreate?: AgentRatingCreateOrConnectWithoutOrderInput
    upsert?: AgentRatingUpsertWithoutOrderInput
    disconnect?: AgentRatingWhereInput | boolean
    delete?: AgentRatingWhereInput | boolean
    connect?: AgentRatingWhereUniqueInput
    update?: XOR<XOR<AgentRatingUpdateToOneWithWhereWithoutOrderInput, AgentRatingUpdateWithoutOrderInput>, AgentRatingUncheckedUpdateWithoutOrderInput>
  }

  export type PaymentUpdateManyWithoutOrderNestedInput = {
    create?: XOR<PaymentCreateWithoutOrderInput, PaymentUncheckedCreateWithoutOrderInput> | PaymentCreateWithoutOrderInput[] | PaymentUncheckedCreateWithoutOrderInput[]
    connectOrCreate?: PaymentCreateOrConnectWithoutOrderInput | PaymentCreateOrConnectWithoutOrderInput[]
    upsert?: PaymentUpsertWithWhereUniqueWithoutOrderInput | PaymentUpsertWithWhereUniqueWithoutOrderInput[]
    createMany?: PaymentCreateManyOrderInputEnvelope
    set?: PaymentWhereUniqueInput | PaymentWhereUniqueInput[]
    disconnect?: PaymentWhereUniqueInput | PaymentWhereUniqueInput[]
    delete?: PaymentWhereUniqueInput | PaymentWhereUniqueInput[]
    connect?: PaymentWhereUniqueInput | PaymentWhereUniqueInput[]
    update?: PaymentUpdateWithWhereUniqueWithoutOrderInput | PaymentUpdateWithWhereUniqueWithoutOrderInput[]
    updateMany?: PaymentUpdateManyWithWhereWithoutOrderInput | PaymentUpdateManyWithWhereWithoutOrderInput[]
    deleteMany?: PaymentScalarWhereInput | PaymentScalarWhereInput[]
  }

  export type PartnerRevenueUpdateOneWithoutOrderNestedInput = {
    create?: XOR<PartnerRevenueCreateWithoutOrderInput, PartnerRevenueUncheckedCreateWithoutOrderInput>
    connectOrCreate?: PartnerRevenueCreateOrConnectWithoutOrderInput
    upsert?: PartnerRevenueUpsertWithoutOrderInput
    disconnect?: PartnerRevenueWhereInput | boolean
    delete?: PartnerRevenueWhereInput | boolean
    connect?: PartnerRevenueWhereUniqueInput
    update?: XOR<XOR<PartnerRevenueUpdateToOneWithWhereWithoutOrderInput, PartnerRevenueUpdateWithoutOrderInput>, PartnerRevenueUncheckedUpdateWithoutOrderInput>
  }

  export type PlatformRevenueUpdateOneWithoutOrderNestedInput = {
    create?: XOR<PlatformRevenueCreateWithoutOrderInput, PlatformRevenueUncheckedCreateWithoutOrderInput>
    connectOrCreate?: PlatformRevenueCreateOrConnectWithoutOrderInput
    upsert?: PlatformRevenueUpsertWithoutOrderInput
    disconnect?: PlatformRevenueWhereInput | boolean
    delete?: PlatformRevenueWhereInput | boolean
    connect?: PlatformRevenueWhereUniqueInput
    update?: XOR<XOR<PlatformRevenueUpdateToOneWithWhereWithoutOrderInput, PlatformRevenueUpdateWithoutOrderInput>, PlatformRevenueUncheckedUpdateWithoutOrderInput>
  }

  export type WalletTransactionUpdateManyWithoutOrderNestedInput = {
    create?: XOR<WalletTransactionCreateWithoutOrderInput, WalletTransactionUncheckedCreateWithoutOrderInput> | WalletTransactionCreateWithoutOrderInput[] | WalletTransactionUncheckedCreateWithoutOrderInput[]
    connectOrCreate?: WalletTransactionCreateOrConnectWithoutOrderInput | WalletTransactionCreateOrConnectWithoutOrderInput[]
    upsert?: WalletTransactionUpsertWithWhereUniqueWithoutOrderInput | WalletTransactionUpsertWithWhereUniqueWithoutOrderInput[]
    createMany?: WalletTransactionCreateManyOrderInputEnvelope
    set?: WalletTransactionWhereUniqueInput | WalletTransactionWhereUniqueInput[]
    disconnect?: WalletTransactionWhereUniqueInput | WalletTransactionWhereUniqueInput[]
    delete?: WalletTransactionWhereUniqueInput | WalletTransactionWhereUniqueInput[]
    connect?: WalletTransactionWhereUniqueInput | WalletTransactionWhereUniqueInput[]
    update?: WalletTransactionUpdateWithWhereUniqueWithoutOrderInput | WalletTransactionUpdateWithWhereUniqueWithoutOrderInput[]
    updateMany?: WalletTransactionUpdateManyWithWhereWithoutOrderInput | WalletTransactionUpdateManyWithWhereWithoutOrderInput[]
    deleteMany?: WalletTransactionScalarWhereInput | WalletTransactionScalarWhereInput[]
  }

  export type AgentUncheckedUpdateOneWithoutCurrentOrderNestedInput = {
    create?: XOR<AgentCreateWithoutCurrentOrderInput, AgentUncheckedCreateWithoutCurrentOrderInput>
    connectOrCreate?: AgentCreateOrConnectWithoutCurrentOrderInput
    upsert?: AgentUpsertWithoutCurrentOrderInput
    disconnect?: AgentWhereInput | boolean
    delete?: AgentWhereInput | boolean
    connect?: AgentWhereUniqueInput
    update?: XOR<XOR<AgentUpdateToOneWithWhereWithoutCurrentOrderInput, AgentUpdateWithoutCurrentOrderInput>, AgentUncheckedUpdateWithoutCurrentOrderInput>
  }

  export type SupportTicketUncheckedUpdateManyWithoutOrderNestedInput = {
    create?: XOR<SupportTicketCreateWithoutOrderInput, SupportTicketUncheckedCreateWithoutOrderInput> | SupportTicketCreateWithoutOrderInput[] | SupportTicketUncheckedCreateWithoutOrderInput[]
    connectOrCreate?: SupportTicketCreateOrConnectWithoutOrderInput | SupportTicketCreateOrConnectWithoutOrderInput[]
    upsert?: SupportTicketUpsertWithWhereUniqueWithoutOrderInput | SupportTicketUpsertWithWhereUniqueWithoutOrderInput[]
    createMany?: SupportTicketCreateManyOrderInputEnvelope
    set?: SupportTicketWhereUniqueInput | SupportTicketWhereUniqueInput[]
    disconnect?: SupportTicketWhereUniqueInput | SupportTicketWhereUniqueInput[]
    delete?: SupportTicketWhereUniqueInput | SupportTicketWhereUniqueInput[]
    connect?: SupportTicketWhereUniqueInput | SupportTicketWhereUniqueInput[]
    update?: SupportTicketUpdateWithWhereUniqueWithoutOrderInput | SupportTicketUpdateWithWhereUniqueWithoutOrderInput[]
    updateMany?: SupportTicketUpdateManyWithWhereWithoutOrderInput | SupportTicketUpdateManyWithWhereWithoutOrderInput[]
    deleteMany?: SupportTicketScalarWhereInput | SupportTicketScalarWhereInput[]
  }

  export type AgentRatingUncheckedUpdateOneWithoutOrderNestedInput = {
    create?: XOR<AgentRatingCreateWithoutOrderInput, AgentRatingUncheckedCreateWithoutOrderInput>
    connectOrCreate?: AgentRatingCreateOrConnectWithoutOrderInput
    upsert?: AgentRatingUpsertWithoutOrderInput
    disconnect?: AgentRatingWhereInput | boolean
    delete?: AgentRatingWhereInput | boolean
    connect?: AgentRatingWhereUniqueInput
    update?: XOR<XOR<AgentRatingUpdateToOneWithWhereWithoutOrderInput, AgentRatingUpdateWithoutOrderInput>, AgentRatingUncheckedUpdateWithoutOrderInput>
  }

  export type PaymentUncheckedUpdateManyWithoutOrderNestedInput = {
    create?: XOR<PaymentCreateWithoutOrderInput, PaymentUncheckedCreateWithoutOrderInput> | PaymentCreateWithoutOrderInput[] | PaymentUncheckedCreateWithoutOrderInput[]
    connectOrCreate?: PaymentCreateOrConnectWithoutOrderInput | PaymentCreateOrConnectWithoutOrderInput[]
    upsert?: PaymentUpsertWithWhereUniqueWithoutOrderInput | PaymentUpsertWithWhereUniqueWithoutOrderInput[]
    createMany?: PaymentCreateManyOrderInputEnvelope
    set?: PaymentWhereUniqueInput | PaymentWhereUniqueInput[]
    disconnect?: PaymentWhereUniqueInput | PaymentWhereUniqueInput[]
    delete?: PaymentWhereUniqueInput | PaymentWhereUniqueInput[]
    connect?: PaymentWhereUniqueInput | PaymentWhereUniqueInput[]
    update?: PaymentUpdateWithWhereUniqueWithoutOrderInput | PaymentUpdateWithWhereUniqueWithoutOrderInput[]
    updateMany?: PaymentUpdateManyWithWhereWithoutOrderInput | PaymentUpdateManyWithWhereWithoutOrderInput[]
    deleteMany?: PaymentScalarWhereInput | PaymentScalarWhereInput[]
  }

  export type PartnerRevenueUncheckedUpdateOneWithoutOrderNestedInput = {
    create?: XOR<PartnerRevenueCreateWithoutOrderInput, PartnerRevenueUncheckedCreateWithoutOrderInput>
    connectOrCreate?: PartnerRevenueCreateOrConnectWithoutOrderInput
    upsert?: PartnerRevenueUpsertWithoutOrderInput
    disconnect?: PartnerRevenueWhereInput | boolean
    delete?: PartnerRevenueWhereInput | boolean
    connect?: PartnerRevenueWhereUniqueInput
    update?: XOR<XOR<PartnerRevenueUpdateToOneWithWhereWithoutOrderInput, PartnerRevenueUpdateWithoutOrderInput>, PartnerRevenueUncheckedUpdateWithoutOrderInput>
  }

  export type PlatformRevenueUncheckedUpdateOneWithoutOrderNestedInput = {
    create?: XOR<PlatformRevenueCreateWithoutOrderInput, PlatformRevenueUncheckedCreateWithoutOrderInput>
    connectOrCreate?: PlatformRevenueCreateOrConnectWithoutOrderInput
    upsert?: PlatformRevenueUpsertWithoutOrderInput
    disconnect?: PlatformRevenueWhereInput | boolean
    delete?: PlatformRevenueWhereInput | boolean
    connect?: PlatformRevenueWhereUniqueInput
    update?: XOR<XOR<PlatformRevenueUpdateToOneWithWhereWithoutOrderInput, PlatformRevenueUpdateWithoutOrderInput>, PlatformRevenueUncheckedUpdateWithoutOrderInput>
  }

  export type WalletTransactionUncheckedUpdateManyWithoutOrderNestedInput = {
    create?: XOR<WalletTransactionCreateWithoutOrderInput, WalletTransactionUncheckedCreateWithoutOrderInput> | WalletTransactionCreateWithoutOrderInput[] | WalletTransactionUncheckedCreateWithoutOrderInput[]
    connectOrCreate?: WalletTransactionCreateOrConnectWithoutOrderInput | WalletTransactionCreateOrConnectWithoutOrderInput[]
    upsert?: WalletTransactionUpsertWithWhereUniqueWithoutOrderInput | WalletTransactionUpsertWithWhereUniqueWithoutOrderInput[]
    createMany?: WalletTransactionCreateManyOrderInputEnvelope
    set?: WalletTransactionWhereUniqueInput | WalletTransactionWhereUniqueInput[]
    disconnect?: WalletTransactionWhereUniqueInput | WalletTransactionWhereUniqueInput[]
    delete?: WalletTransactionWhereUniqueInput | WalletTransactionWhereUniqueInput[]
    connect?: WalletTransactionWhereUniqueInput | WalletTransactionWhereUniqueInput[]
    update?: WalletTransactionUpdateWithWhereUniqueWithoutOrderInput | WalletTransactionUpdateWithWhereUniqueWithoutOrderInput[]
    updateMany?: WalletTransactionUpdateManyWithWhereWithoutOrderInput | WalletTransactionUpdateManyWithWhereWithoutOrderInput[]
    deleteMany?: WalletTransactionScalarWhereInput | WalletTransactionScalarWhereInput[]
  }

  export type UserCreateNestedOneWithoutNotificationsInput = {
    create?: XOR<UserCreateWithoutNotificationsInput, UserUncheckedCreateWithoutNotificationsInput>
    connectOrCreate?: UserCreateOrConnectWithoutNotificationsInput
    connect?: UserWhereUniqueInput
  }

  export type UserUpdateOneRequiredWithoutNotificationsNestedInput = {
    create?: XOR<UserCreateWithoutNotificationsInput, UserUncheckedCreateWithoutNotificationsInput>
    connectOrCreate?: UserCreateOrConnectWithoutNotificationsInput
    upsert?: UserUpsertWithoutNotificationsInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutNotificationsInput, UserUpdateWithoutNotificationsInput>, UserUncheckedUpdateWithoutNotificationsInput>
  }

  export type OrderCreateNestedOneWithoutTicketsInput = {
    create?: XOR<OrderCreateWithoutTicketsInput, OrderUncheckedCreateWithoutTicketsInput>
    connectOrCreate?: OrderCreateOrConnectWithoutTicketsInput
    connect?: OrderWhereUniqueInput
  }

  export type AgentCreateNestedOneWithoutTicketsInput = {
    create?: XOR<AgentCreateWithoutTicketsInput, AgentUncheckedCreateWithoutTicketsInput>
    connectOrCreate?: AgentCreateOrConnectWithoutTicketsInput
    connect?: AgentWhereUniqueInput
  }

  export type PartnerCreateNestedOneWithoutTicketsInput = {
    create?: XOR<PartnerCreateWithoutTicketsInput, PartnerUncheckedCreateWithoutTicketsInput>
    connectOrCreate?: PartnerCreateOrConnectWithoutTicketsInput
    connect?: PartnerWhereUniqueInput
  }

  export type UserCreateNestedOneWithoutTicketsInput = {
    create?: XOR<UserCreateWithoutTicketsInput, UserUncheckedCreateWithoutTicketsInput>
    connectOrCreate?: UserCreateOrConnectWithoutTicketsInput
    connect?: UserWhereUniqueInput
  }

  export type EnumTicketStatusFieldUpdateOperationsInput = {
    set?: $Enums.TicketStatus
  }

  export type OrderUpdateOneWithoutTicketsNestedInput = {
    create?: XOR<OrderCreateWithoutTicketsInput, OrderUncheckedCreateWithoutTicketsInput>
    connectOrCreate?: OrderCreateOrConnectWithoutTicketsInput
    upsert?: OrderUpsertWithoutTicketsInput
    disconnect?: OrderWhereInput | boolean
    delete?: OrderWhereInput | boolean
    connect?: OrderWhereUniqueInput
    update?: XOR<XOR<OrderUpdateToOneWithWhereWithoutTicketsInput, OrderUpdateWithoutTicketsInput>, OrderUncheckedUpdateWithoutTicketsInput>
  }

  export type AgentUpdateOneWithoutTicketsNestedInput = {
    create?: XOR<AgentCreateWithoutTicketsInput, AgentUncheckedCreateWithoutTicketsInput>
    connectOrCreate?: AgentCreateOrConnectWithoutTicketsInput
    upsert?: AgentUpsertWithoutTicketsInput
    disconnect?: AgentWhereInput | boolean
    delete?: AgentWhereInput | boolean
    connect?: AgentWhereUniqueInput
    update?: XOR<XOR<AgentUpdateToOneWithWhereWithoutTicketsInput, AgentUpdateWithoutTicketsInput>, AgentUncheckedUpdateWithoutTicketsInput>
  }

  export type PartnerUpdateOneWithoutTicketsNestedInput = {
    create?: XOR<PartnerCreateWithoutTicketsInput, PartnerUncheckedCreateWithoutTicketsInput>
    connectOrCreate?: PartnerCreateOrConnectWithoutTicketsInput
    upsert?: PartnerUpsertWithoutTicketsInput
    disconnect?: PartnerWhereInput | boolean
    delete?: PartnerWhereInput | boolean
    connect?: PartnerWhereUniqueInput
    update?: XOR<XOR<PartnerUpdateToOneWithWhereWithoutTicketsInput, PartnerUpdateWithoutTicketsInput>, PartnerUncheckedUpdateWithoutTicketsInput>
  }

  export type UserUpdateOneRequiredWithoutTicketsNestedInput = {
    create?: XOR<UserCreateWithoutTicketsInput, UserUncheckedCreateWithoutTicketsInput>
    connectOrCreate?: UserCreateOrConnectWithoutTicketsInput
    upsert?: UserUpsertWithoutTicketsInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutTicketsInput, UserUpdateWithoutTicketsInput>, UserUncheckedUpdateWithoutTicketsInput>
  }

  export type EnumActorTypeFieldUpdateOperationsInput = {
    set?: $Enums.ActorType
  }

  export type EnumEventTypeFieldUpdateOperationsInput = {
    set?: $Enums.EventType
  }

  export type PartnerCreateNestedOneWithoutDailyStatsInput = {
    create?: XOR<PartnerCreateWithoutDailyStatsInput, PartnerUncheckedCreateWithoutDailyStatsInput>
    connectOrCreate?: PartnerCreateOrConnectWithoutDailyStatsInput
    connect?: PartnerWhereUniqueInput
  }

  export type PartnerUpdateOneRequiredWithoutDailyStatsNestedInput = {
    create?: XOR<PartnerCreateWithoutDailyStatsInput, PartnerUncheckedCreateWithoutDailyStatsInput>
    connectOrCreate?: PartnerCreateOrConnectWithoutDailyStatsInput
    upsert?: PartnerUpsertWithoutDailyStatsInput
    connect?: PartnerWhereUniqueInput
    update?: XOR<XOR<PartnerUpdateToOneWithWhereWithoutDailyStatsInput, PartnerUpdateWithoutDailyStatsInput>, PartnerUncheckedUpdateWithoutDailyStatsInput>
  }

  export type PartnerCreateNestedOneWithoutPartnerRevenuesInput = {
    create?: XOR<PartnerCreateWithoutPartnerRevenuesInput, PartnerUncheckedCreateWithoutPartnerRevenuesInput>
    connectOrCreate?: PartnerCreateOrConnectWithoutPartnerRevenuesInput
    connect?: PartnerWhereUniqueInput
  }

  export type OrderCreateNestedOneWithoutPartnerRevenueInput = {
    create?: XOR<OrderCreateWithoutPartnerRevenueInput, OrderUncheckedCreateWithoutPartnerRevenueInput>
    connectOrCreate?: OrderCreateOrConnectWithoutPartnerRevenueInput
    connect?: OrderWhereUniqueInput
  }

  export type PartnerUpdateOneRequiredWithoutPartnerRevenuesNestedInput = {
    create?: XOR<PartnerCreateWithoutPartnerRevenuesInput, PartnerUncheckedCreateWithoutPartnerRevenuesInput>
    connectOrCreate?: PartnerCreateOrConnectWithoutPartnerRevenuesInput
    upsert?: PartnerUpsertWithoutPartnerRevenuesInput
    connect?: PartnerWhereUniqueInput
    update?: XOR<XOR<PartnerUpdateToOneWithWhereWithoutPartnerRevenuesInput, PartnerUpdateWithoutPartnerRevenuesInput>, PartnerUncheckedUpdateWithoutPartnerRevenuesInput>
  }

  export type OrderUpdateOneRequiredWithoutPartnerRevenueNestedInput = {
    create?: XOR<OrderCreateWithoutPartnerRevenueInput, OrderUncheckedCreateWithoutPartnerRevenueInput>
    connectOrCreate?: OrderCreateOrConnectWithoutPartnerRevenueInput
    upsert?: OrderUpsertWithoutPartnerRevenueInput
    connect?: OrderWhereUniqueInput
    update?: XOR<XOR<OrderUpdateToOneWithWhereWithoutPartnerRevenueInput, OrderUpdateWithoutPartnerRevenueInput>, OrderUncheckedUpdateWithoutPartnerRevenueInput>
  }

  export type OrderCreateNestedOneWithoutPlatformRevenueInput = {
    create?: XOR<OrderCreateWithoutPlatformRevenueInput, OrderUncheckedCreateWithoutPlatformRevenueInput>
    connectOrCreate?: OrderCreateOrConnectWithoutPlatformRevenueInput
    connect?: OrderWhereUniqueInput
  }

  export type PartnerCreateNestedOneWithoutPlatformRevenuesInput = {
    create?: XOR<PartnerCreateWithoutPlatformRevenuesInput, PartnerUncheckedCreateWithoutPlatformRevenuesInput>
    connectOrCreate?: PartnerCreateOrConnectWithoutPlatformRevenuesInput
    connect?: PartnerWhereUniqueInput
  }

  export type OrderUpdateOneRequiredWithoutPlatformRevenueNestedInput = {
    create?: XOR<OrderCreateWithoutPlatformRevenueInput, OrderUncheckedCreateWithoutPlatformRevenueInput>
    connectOrCreate?: OrderCreateOrConnectWithoutPlatformRevenueInput
    upsert?: OrderUpsertWithoutPlatformRevenueInput
    connect?: OrderWhereUniqueInput
    update?: XOR<XOR<OrderUpdateToOneWithWhereWithoutPlatformRevenueInput, OrderUpdateWithoutPlatformRevenueInput>, OrderUncheckedUpdateWithoutPlatformRevenueInput>
  }

  export type PartnerUpdateOneRequiredWithoutPlatformRevenuesNestedInput = {
    create?: XOR<PartnerCreateWithoutPlatformRevenuesInput, PartnerUncheckedCreateWithoutPlatformRevenuesInput>
    connectOrCreate?: PartnerCreateOrConnectWithoutPlatformRevenuesInput
    upsert?: PartnerUpsertWithoutPlatformRevenuesInput
    connect?: PartnerWhereUniqueInput
    update?: XOR<XOR<PartnerUpdateToOneWithWhereWithoutPlatformRevenuesInput, PartnerUpdateWithoutPlatformRevenuesInput>, PartnerUncheckedUpdateWithoutPlatformRevenuesInput>
  }

  export type WalletTransactionCreateNestedManyWithoutAdminWalletInput = {
    create?: XOR<WalletTransactionCreateWithoutAdminWalletInput, WalletTransactionUncheckedCreateWithoutAdminWalletInput> | WalletTransactionCreateWithoutAdminWalletInput[] | WalletTransactionUncheckedCreateWithoutAdminWalletInput[]
    connectOrCreate?: WalletTransactionCreateOrConnectWithoutAdminWalletInput | WalletTransactionCreateOrConnectWithoutAdminWalletInput[]
    createMany?: WalletTransactionCreateManyAdminWalletInputEnvelope
    connect?: WalletTransactionWhereUniqueInput | WalletTransactionWhereUniqueInput[]
  }

  export type WalletTransactionUncheckedCreateNestedManyWithoutAdminWalletInput = {
    create?: XOR<WalletTransactionCreateWithoutAdminWalletInput, WalletTransactionUncheckedCreateWithoutAdminWalletInput> | WalletTransactionCreateWithoutAdminWalletInput[] | WalletTransactionUncheckedCreateWithoutAdminWalletInput[]
    connectOrCreate?: WalletTransactionCreateOrConnectWithoutAdminWalletInput | WalletTransactionCreateOrConnectWithoutAdminWalletInput[]
    createMany?: WalletTransactionCreateManyAdminWalletInputEnvelope
    connect?: WalletTransactionWhereUniqueInput | WalletTransactionWhereUniqueInput[]
  }

  export type WalletTransactionUpdateManyWithoutAdminWalletNestedInput = {
    create?: XOR<WalletTransactionCreateWithoutAdminWalletInput, WalletTransactionUncheckedCreateWithoutAdminWalletInput> | WalletTransactionCreateWithoutAdminWalletInput[] | WalletTransactionUncheckedCreateWithoutAdminWalletInput[]
    connectOrCreate?: WalletTransactionCreateOrConnectWithoutAdminWalletInput | WalletTransactionCreateOrConnectWithoutAdminWalletInput[]
    upsert?: WalletTransactionUpsertWithWhereUniqueWithoutAdminWalletInput | WalletTransactionUpsertWithWhereUniqueWithoutAdminWalletInput[]
    createMany?: WalletTransactionCreateManyAdminWalletInputEnvelope
    set?: WalletTransactionWhereUniqueInput | WalletTransactionWhereUniqueInput[]
    disconnect?: WalletTransactionWhereUniqueInput | WalletTransactionWhereUniqueInput[]
    delete?: WalletTransactionWhereUniqueInput | WalletTransactionWhereUniqueInput[]
    connect?: WalletTransactionWhereUniqueInput | WalletTransactionWhereUniqueInput[]
    update?: WalletTransactionUpdateWithWhereUniqueWithoutAdminWalletInput | WalletTransactionUpdateWithWhereUniqueWithoutAdminWalletInput[]
    updateMany?: WalletTransactionUpdateManyWithWhereWithoutAdminWalletInput | WalletTransactionUpdateManyWithWhereWithoutAdminWalletInput[]
    deleteMany?: WalletTransactionScalarWhereInput | WalletTransactionScalarWhereInput[]
  }

  export type WalletTransactionUncheckedUpdateManyWithoutAdminWalletNestedInput = {
    create?: XOR<WalletTransactionCreateWithoutAdminWalletInput, WalletTransactionUncheckedCreateWithoutAdminWalletInput> | WalletTransactionCreateWithoutAdminWalletInput[] | WalletTransactionUncheckedCreateWithoutAdminWalletInput[]
    connectOrCreate?: WalletTransactionCreateOrConnectWithoutAdminWalletInput | WalletTransactionCreateOrConnectWithoutAdminWalletInput[]
    upsert?: WalletTransactionUpsertWithWhereUniqueWithoutAdminWalletInput | WalletTransactionUpsertWithWhereUniqueWithoutAdminWalletInput[]
    createMany?: WalletTransactionCreateManyAdminWalletInputEnvelope
    set?: WalletTransactionWhereUniqueInput | WalletTransactionWhereUniqueInput[]
    disconnect?: WalletTransactionWhereUniqueInput | WalletTransactionWhereUniqueInput[]
    delete?: WalletTransactionWhereUniqueInput | WalletTransactionWhereUniqueInput[]
    connect?: WalletTransactionWhereUniqueInput | WalletTransactionWhereUniqueInput[]
    update?: WalletTransactionUpdateWithWhereUniqueWithoutAdminWalletInput | WalletTransactionUpdateWithWhereUniqueWithoutAdminWalletInput[]
    updateMany?: WalletTransactionUpdateManyWithWhereWithoutAdminWalletInput | WalletTransactionUpdateManyWithWhereWithoutAdminWalletInput[]
    deleteMany?: WalletTransactionScalarWhereInput | WalletTransactionScalarWhereInput[]
  }

  export type AgentCreateNestedOneWithoutWalletInput = {
    create?: XOR<AgentCreateWithoutWalletInput, AgentUncheckedCreateWithoutWalletInput>
    connectOrCreate?: AgentCreateOrConnectWithoutWalletInput
    connect?: AgentWhereUniqueInput
  }

  export type WalletTransactionCreateNestedManyWithoutAgentWalletInput = {
    create?: XOR<WalletTransactionCreateWithoutAgentWalletInput, WalletTransactionUncheckedCreateWithoutAgentWalletInput> | WalletTransactionCreateWithoutAgentWalletInput[] | WalletTransactionUncheckedCreateWithoutAgentWalletInput[]
    connectOrCreate?: WalletTransactionCreateOrConnectWithoutAgentWalletInput | WalletTransactionCreateOrConnectWithoutAgentWalletInput[]
    createMany?: WalletTransactionCreateManyAgentWalletInputEnvelope
    connect?: WalletTransactionWhereUniqueInput | WalletTransactionWhereUniqueInput[]
  }

  export type WalletPayoutCreateNestedManyWithoutAgentWalletInput = {
    create?: XOR<WalletPayoutCreateWithoutAgentWalletInput, WalletPayoutUncheckedCreateWithoutAgentWalletInput> | WalletPayoutCreateWithoutAgentWalletInput[] | WalletPayoutUncheckedCreateWithoutAgentWalletInput[]
    connectOrCreate?: WalletPayoutCreateOrConnectWithoutAgentWalletInput | WalletPayoutCreateOrConnectWithoutAgentWalletInput[]
    createMany?: WalletPayoutCreateManyAgentWalletInputEnvelope
    connect?: WalletPayoutWhereUniqueInput | WalletPayoutWhereUniqueInput[]
  }

  export type WalletTransactionUncheckedCreateNestedManyWithoutAgentWalletInput = {
    create?: XOR<WalletTransactionCreateWithoutAgentWalletInput, WalletTransactionUncheckedCreateWithoutAgentWalletInput> | WalletTransactionCreateWithoutAgentWalletInput[] | WalletTransactionUncheckedCreateWithoutAgentWalletInput[]
    connectOrCreate?: WalletTransactionCreateOrConnectWithoutAgentWalletInput | WalletTransactionCreateOrConnectWithoutAgentWalletInput[]
    createMany?: WalletTransactionCreateManyAgentWalletInputEnvelope
    connect?: WalletTransactionWhereUniqueInput | WalletTransactionWhereUniqueInput[]
  }

  export type WalletPayoutUncheckedCreateNestedManyWithoutAgentWalletInput = {
    create?: XOR<WalletPayoutCreateWithoutAgentWalletInput, WalletPayoutUncheckedCreateWithoutAgentWalletInput> | WalletPayoutCreateWithoutAgentWalletInput[] | WalletPayoutUncheckedCreateWithoutAgentWalletInput[]
    connectOrCreate?: WalletPayoutCreateOrConnectWithoutAgentWalletInput | WalletPayoutCreateOrConnectWithoutAgentWalletInput[]
    createMany?: WalletPayoutCreateManyAgentWalletInputEnvelope
    connect?: WalletPayoutWhereUniqueInput | WalletPayoutWhereUniqueInput[]
  }

  export type AgentUpdateOneRequiredWithoutWalletNestedInput = {
    create?: XOR<AgentCreateWithoutWalletInput, AgentUncheckedCreateWithoutWalletInput>
    connectOrCreate?: AgentCreateOrConnectWithoutWalletInput
    upsert?: AgentUpsertWithoutWalletInput
    connect?: AgentWhereUniqueInput
    update?: XOR<XOR<AgentUpdateToOneWithWhereWithoutWalletInput, AgentUpdateWithoutWalletInput>, AgentUncheckedUpdateWithoutWalletInput>
  }

  export type WalletTransactionUpdateManyWithoutAgentWalletNestedInput = {
    create?: XOR<WalletTransactionCreateWithoutAgentWalletInput, WalletTransactionUncheckedCreateWithoutAgentWalletInput> | WalletTransactionCreateWithoutAgentWalletInput[] | WalletTransactionUncheckedCreateWithoutAgentWalletInput[]
    connectOrCreate?: WalletTransactionCreateOrConnectWithoutAgentWalletInput | WalletTransactionCreateOrConnectWithoutAgentWalletInput[]
    upsert?: WalletTransactionUpsertWithWhereUniqueWithoutAgentWalletInput | WalletTransactionUpsertWithWhereUniqueWithoutAgentWalletInput[]
    createMany?: WalletTransactionCreateManyAgentWalletInputEnvelope
    set?: WalletTransactionWhereUniqueInput | WalletTransactionWhereUniqueInput[]
    disconnect?: WalletTransactionWhereUniqueInput | WalletTransactionWhereUniqueInput[]
    delete?: WalletTransactionWhereUniqueInput | WalletTransactionWhereUniqueInput[]
    connect?: WalletTransactionWhereUniqueInput | WalletTransactionWhereUniqueInput[]
    update?: WalletTransactionUpdateWithWhereUniqueWithoutAgentWalletInput | WalletTransactionUpdateWithWhereUniqueWithoutAgentWalletInput[]
    updateMany?: WalletTransactionUpdateManyWithWhereWithoutAgentWalletInput | WalletTransactionUpdateManyWithWhereWithoutAgentWalletInput[]
    deleteMany?: WalletTransactionScalarWhereInput | WalletTransactionScalarWhereInput[]
  }

  export type WalletPayoutUpdateManyWithoutAgentWalletNestedInput = {
    create?: XOR<WalletPayoutCreateWithoutAgentWalletInput, WalletPayoutUncheckedCreateWithoutAgentWalletInput> | WalletPayoutCreateWithoutAgentWalletInput[] | WalletPayoutUncheckedCreateWithoutAgentWalletInput[]
    connectOrCreate?: WalletPayoutCreateOrConnectWithoutAgentWalletInput | WalletPayoutCreateOrConnectWithoutAgentWalletInput[]
    upsert?: WalletPayoutUpsertWithWhereUniqueWithoutAgentWalletInput | WalletPayoutUpsertWithWhereUniqueWithoutAgentWalletInput[]
    createMany?: WalletPayoutCreateManyAgentWalletInputEnvelope
    set?: WalletPayoutWhereUniqueInput | WalletPayoutWhereUniqueInput[]
    disconnect?: WalletPayoutWhereUniqueInput | WalletPayoutWhereUniqueInput[]
    delete?: WalletPayoutWhereUniqueInput | WalletPayoutWhereUniqueInput[]
    connect?: WalletPayoutWhereUniqueInput | WalletPayoutWhereUniqueInput[]
    update?: WalletPayoutUpdateWithWhereUniqueWithoutAgentWalletInput | WalletPayoutUpdateWithWhereUniqueWithoutAgentWalletInput[]
    updateMany?: WalletPayoutUpdateManyWithWhereWithoutAgentWalletInput | WalletPayoutUpdateManyWithWhereWithoutAgentWalletInput[]
    deleteMany?: WalletPayoutScalarWhereInput | WalletPayoutScalarWhereInput[]
  }

  export type WalletTransactionUncheckedUpdateManyWithoutAgentWalletNestedInput = {
    create?: XOR<WalletTransactionCreateWithoutAgentWalletInput, WalletTransactionUncheckedCreateWithoutAgentWalletInput> | WalletTransactionCreateWithoutAgentWalletInput[] | WalletTransactionUncheckedCreateWithoutAgentWalletInput[]
    connectOrCreate?: WalletTransactionCreateOrConnectWithoutAgentWalletInput | WalletTransactionCreateOrConnectWithoutAgentWalletInput[]
    upsert?: WalletTransactionUpsertWithWhereUniqueWithoutAgentWalletInput | WalletTransactionUpsertWithWhereUniqueWithoutAgentWalletInput[]
    createMany?: WalletTransactionCreateManyAgentWalletInputEnvelope
    set?: WalletTransactionWhereUniqueInput | WalletTransactionWhereUniqueInput[]
    disconnect?: WalletTransactionWhereUniqueInput | WalletTransactionWhereUniqueInput[]
    delete?: WalletTransactionWhereUniqueInput | WalletTransactionWhereUniqueInput[]
    connect?: WalletTransactionWhereUniqueInput | WalletTransactionWhereUniqueInput[]
    update?: WalletTransactionUpdateWithWhereUniqueWithoutAgentWalletInput | WalletTransactionUpdateWithWhereUniqueWithoutAgentWalletInput[]
    updateMany?: WalletTransactionUpdateManyWithWhereWithoutAgentWalletInput | WalletTransactionUpdateManyWithWhereWithoutAgentWalletInput[]
    deleteMany?: WalletTransactionScalarWhereInput | WalletTransactionScalarWhereInput[]
  }

  export type WalletPayoutUncheckedUpdateManyWithoutAgentWalletNestedInput = {
    create?: XOR<WalletPayoutCreateWithoutAgentWalletInput, WalletPayoutUncheckedCreateWithoutAgentWalletInput> | WalletPayoutCreateWithoutAgentWalletInput[] | WalletPayoutUncheckedCreateWithoutAgentWalletInput[]
    connectOrCreate?: WalletPayoutCreateOrConnectWithoutAgentWalletInput | WalletPayoutCreateOrConnectWithoutAgentWalletInput[]
    upsert?: WalletPayoutUpsertWithWhereUniqueWithoutAgentWalletInput | WalletPayoutUpsertWithWhereUniqueWithoutAgentWalletInput[]
    createMany?: WalletPayoutCreateManyAgentWalletInputEnvelope
    set?: WalletPayoutWhereUniqueInput | WalletPayoutWhereUniqueInput[]
    disconnect?: WalletPayoutWhereUniqueInput | WalletPayoutWhereUniqueInput[]
    delete?: WalletPayoutWhereUniqueInput | WalletPayoutWhereUniqueInput[]
    connect?: WalletPayoutWhereUniqueInput | WalletPayoutWhereUniqueInput[]
    update?: WalletPayoutUpdateWithWhereUniqueWithoutAgentWalletInput | WalletPayoutUpdateWithWhereUniqueWithoutAgentWalletInput[]
    updateMany?: WalletPayoutUpdateManyWithWhereWithoutAgentWalletInput | WalletPayoutUpdateManyWithWhereWithoutAgentWalletInput[]
    deleteMany?: WalletPayoutScalarWhereInput | WalletPayoutScalarWhereInput[]
  }

  export type AdminWalletCreateNestedOneWithoutTransactionsInput = {
    create?: XOR<AdminWalletCreateWithoutTransactionsInput, AdminWalletUncheckedCreateWithoutTransactionsInput>
    connectOrCreate?: AdminWalletCreateOrConnectWithoutTransactionsInput
    connect?: AdminWalletWhereUniqueInput
  }

  export type AgentWalletCreateNestedOneWithoutTransactionsInput = {
    create?: XOR<AgentWalletCreateWithoutTransactionsInput, AgentWalletUncheckedCreateWithoutTransactionsInput>
    connectOrCreate?: AgentWalletCreateOrConnectWithoutTransactionsInput
    connect?: AgentWalletWhereUniqueInput
  }

  export type OrderCreateNestedOneWithoutWalletTransactionsInput = {
    create?: XOR<OrderCreateWithoutWalletTransactionsInput, OrderUncheckedCreateWithoutWalletTransactionsInput>
    connectOrCreate?: OrderCreateOrConnectWithoutWalletTransactionsInput
    connect?: OrderWhereUniqueInput
  }

  export type AdminWalletUpdateOneWithoutTransactionsNestedInput = {
    create?: XOR<AdminWalletCreateWithoutTransactionsInput, AdminWalletUncheckedCreateWithoutTransactionsInput>
    connectOrCreate?: AdminWalletCreateOrConnectWithoutTransactionsInput
    upsert?: AdminWalletUpsertWithoutTransactionsInput
    disconnect?: AdminWalletWhereInput | boolean
    delete?: AdminWalletWhereInput | boolean
    connect?: AdminWalletWhereUniqueInput
    update?: XOR<XOR<AdminWalletUpdateToOneWithWhereWithoutTransactionsInput, AdminWalletUpdateWithoutTransactionsInput>, AdminWalletUncheckedUpdateWithoutTransactionsInput>
  }

  export type AgentWalletUpdateOneWithoutTransactionsNestedInput = {
    create?: XOR<AgentWalletCreateWithoutTransactionsInput, AgentWalletUncheckedCreateWithoutTransactionsInput>
    connectOrCreate?: AgentWalletCreateOrConnectWithoutTransactionsInput
    upsert?: AgentWalletUpsertWithoutTransactionsInput
    disconnect?: AgentWalletWhereInput | boolean
    delete?: AgentWalletWhereInput | boolean
    connect?: AgentWalletWhereUniqueInput
    update?: XOR<XOR<AgentWalletUpdateToOneWithWhereWithoutTransactionsInput, AgentWalletUpdateWithoutTransactionsInput>, AgentWalletUncheckedUpdateWithoutTransactionsInput>
  }

  export type OrderUpdateOneWithoutWalletTransactionsNestedInput = {
    create?: XOR<OrderCreateWithoutWalletTransactionsInput, OrderUncheckedCreateWithoutWalletTransactionsInput>
    connectOrCreate?: OrderCreateOrConnectWithoutWalletTransactionsInput
    upsert?: OrderUpsertWithoutWalletTransactionsInput
    disconnect?: OrderWhereInput | boolean
    delete?: OrderWhereInput | boolean
    connect?: OrderWhereUniqueInput
    update?: XOR<XOR<OrderUpdateToOneWithWhereWithoutWalletTransactionsInput, OrderUpdateWithoutWalletTransactionsInput>, OrderUncheckedUpdateWithoutWalletTransactionsInput>
  }

  export type AgentWalletCreateNestedOneWithoutPayoutsInput = {
    create?: XOR<AgentWalletCreateWithoutPayoutsInput, AgentWalletUncheckedCreateWithoutPayoutsInput>
    connectOrCreate?: AgentWalletCreateOrConnectWithoutPayoutsInput
    connect?: AgentWalletWhereUniqueInput
  }

  export type AgentCreateNestedOneWithoutWalletPayoutsInput = {
    create?: XOR<AgentCreateWithoutWalletPayoutsInput, AgentUncheckedCreateWithoutWalletPayoutsInput>
    connectOrCreate?: AgentCreateOrConnectWithoutWalletPayoutsInput
    connect?: AgentWhereUniqueInput
  }

  export type AgentWalletUpdateOneRequiredWithoutPayoutsNestedInput = {
    create?: XOR<AgentWalletCreateWithoutPayoutsInput, AgentWalletUncheckedCreateWithoutPayoutsInput>
    connectOrCreate?: AgentWalletCreateOrConnectWithoutPayoutsInput
    upsert?: AgentWalletUpsertWithoutPayoutsInput
    connect?: AgentWalletWhereUniqueInput
    update?: XOR<XOR<AgentWalletUpdateToOneWithWhereWithoutPayoutsInput, AgentWalletUpdateWithoutPayoutsInput>, AgentWalletUncheckedUpdateWithoutPayoutsInput>
  }

  export type AgentUpdateOneRequiredWithoutWalletPayoutsNestedInput = {
    create?: XOR<AgentCreateWithoutWalletPayoutsInput, AgentUncheckedCreateWithoutWalletPayoutsInput>
    connectOrCreate?: AgentCreateOrConnectWithoutWalletPayoutsInput
    upsert?: AgentUpsertWithoutWalletPayoutsInput
    connect?: AgentWhereUniqueInput
    update?: XOR<XOR<AgentUpdateToOneWithWhereWithoutWalletPayoutsInput, AgentUpdateWithoutWalletPayoutsInput>, AgentUncheckedUpdateWithoutWalletPayoutsInput>
  }

  export type UserCreateNestedOneWithoutUserNotificationsInput = {
    create?: XOR<UserCreateWithoutUserNotificationsInput, UserUncheckedCreateWithoutUserNotificationsInput>
    connectOrCreate?: UserCreateOrConnectWithoutUserNotificationsInput
    connect?: UserWhereUniqueInput
  }

  export type UserUpdateOneRequiredWithoutUserNotificationsNestedInput = {
    create?: XOR<UserCreateWithoutUserNotificationsInput, UserUncheckedCreateWithoutUserNotificationsInput>
    connectOrCreate?: UserCreateOrConnectWithoutUserNotificationsInput
    upsert?: UserUpsertWithoutUserNotificationsInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutUserNotificationsInput, UserUpdateWithoutUserNotificationsInput>, UserUncheckedUpdateWithoutUserNotificationsInput>
  }

  export type OrderCreateNestedOneWithoutRatingInput = {
    create?: XOR<OrderCreateWithoutRatingInput, OrderUncheckedCreateWithoutRatingInput>
    connectOrCreate?: OrderCreateOrConnectWithoutRatingInput
    connect?: OrderWhereUniqueInput
  }

  export type AgentCreateNestedOneWithoutRatingsInput = {
    create?: XOR<AgentCreateWithoutRatingsInput, AgentUncheckedCreateWithoutRatingsInput>
    connectOrCreate?: AgentCreateOrConnectWithoutRatingsInput
    connect?: AgentWhereUniqueInput
  }

  export type PartnerCreateNestedOneWithoutAgentRatingsInput = {
    create?: XOR<PartnerCreateWithoutAgentRatingsInput, PartnerUncheckedCreateWithoutAgentRatingsInput>
    connectOrCreate?: PartnerCreateOrConnectWithoutAgentRatingsInput
    connect?: PartnerWhereUniqueInput
  }

  export type OrderUpdateOneRequiredWithoutRatingNestedInput = {
    create?: XOR<OrderCreateWithoutRatingInput, OrderUncheckedCreateWithoutRatingInput>
    connectOrCreate?: OrderCreateOrConnectWithoutRatingInput
    upsert?: OrderUpsertWithoutRatingInput
    connect?: OrderWhereUniqueInput
    update?: XOR<XOR<OrderUpdateToOneWithWhereWithoutRatingInput, OrderUpdateWithoutRatingInput>, OrderUncheckedUpdateWithoutRatingInput>
  }

  export type AgentUpdateOneRequiredWithoutRatingsNestedInput = {
    create?: XOR<AgentCreateWithoutRatingsInput, AgentUncheckedCreateWithoutRatingsInput>
    connectOrCreate?: AgentCreateOrConnectWithoutRatingsInput
    upsert?: AgentUpsertWithoutRatingsInput
    connect?: AgentWhereUniqueInput
    update?: XOR<XOR<AgentUpdateToOneWithWhereWithoutRatingsInput, AgentUpdateWithoutRatingsInput>, AgentUncheckedUpdateWithoutRatingsInput>
  }

  export type PartnerUpdateOneRequiredWithoutAgentRatingsNestedInput = {
    create?: XOR<PartnerCreateWithoutAgentRatingsInput, PartnerUncheckedCreateWithoutAgentRatingsInput>
    connectOrCreate?: PartnerCreateOrConnectWithoutAgentRatingsInput
    upsert?: PartnerUpsertWithoutAgentRatingsInput
    connect?: PartnerWhereUniqueInput
    update?: XOR<XOR<PartnerUpdateToOneWithWhereWithoutAgentRatingsInput, PartnerUpdateWithoutAgentRatingsInput>, PartnerUncheckedUpdateWithoutAgentRatingsInput>
  }

  export type AgentCreateNestedOneWithoutPaymentsInput = {
    create?: XOR<AgentCreateWithoutPaymentsInput, AgentUncheckedCreateWithoutPaymentsInput>
    connectOrCreate?: AgentCreateOrConnectWithoutPaymentsInput
    connect?: AgentWhereUniqueInput
  }

  export type OrderCreateNestedOneWithoutPaymentsInput = {
    create?: XOR<OrderCreateWithoutPaymentsInput, OrderUncheckedCreateWithoutPaymentsInput>
    connectOrCreate?: OrderCreateOrConnectWithoutPaymentsInput
    connect?: OrderWhereUniqueInput
  }

  export type AgentUpdateOneRequiredWithoutPaymentsNestedInput = {
    create?: XOR<AgentCreateWithoutPaymentsInput, AgentUncheckedCreateWithoutPaymentsInput>
    connectOrCreate?: AgentCreateOrConnectWithoutPaymentsInput
    upsert?: AgentUpsertWithoutPaymentsInput
    connect?: AgentWhereUniqueInput
    update?: XOR<XOR<AgentUpdateToOneWithWhereWithoutPaymentsInput, AgentUpdateWithoutPaymentsInput>, AgentUncheckedUpdateWithoutPaymentsInput>
  }

  export type OrderUpdateOneRequiredWithoutPaymentsNestedInput = {
    create?: XOR<OrderCreateWithoutPaymentsInput, OrderUncheckedCreateWithoutPaymentsInput>
    connectOrCreate?: OrderCreateOrConnectWithoutPaymentsInput
    upsert?: OrderUpsertWithoutPaymentsInput
    connect?: OrderWhereUniqueInput
    update?: XOR<XOR<OrderUpdateToOneWithWhereWithoutPaymentsInput, OrderUpdateWithoutPaymentsInput>, OrderUncheckedUpdateWithoutPaymentsInput>
  }

  export type AgentCreateNestedOneWithoutPayrollsInput = {
    create?: XOR<AgentCreateWithoutPayrollsInput, AgentUncheckedCreateWithoutPayrollsInput>
    connectOrCreate?: AgentCreateOrConnectWithoutPayrollsInput
    connect?: AgentWhereUniqueInput
  }

  export type AgentUpdateOneRequiredWithoutPayrollsNestedInput = {
    create?: XOR<AgentCreateWithoutPayrollsInput, AgentUncheckedCreateWithoutPayrollsInput>
    connectOrCreate?: AgentCreateOrConnectWithoutPayrollsInput
    upsert?: AgentUpsertWithoutPayrollsInput
    connect?: AgentWhereUniqueInput
    update?: XOR<XOR<AgentUpdateToOneWithWhereWithoutPayrollsInput, AgentUpdateWithoutPayrollsInput>, AgentUncheckedUpdateWithoutPayrollsInput>
  }

  export type AgentCreateNestedOneWithoutSchedulesInput = {
    create?: XOR<AgentCreateWithoutSchedulesInput, AgentUncheckedCreateWithoutSchedulesInput>
    connectOrCreate?: AgentCreateOrConnectWithoutSchedulesInput
    connect?: AgentWhereUniqueInput
  }

  export type AgentUpdateOneRequiredWithoutSchedulesNestedInput = {
    create?: XOR<AgentCreateWithoutSchedulesInput, AgentUncheckedCreateWithoutSchedulesInput>
    connectOrCreate?: AgentCreateOrConnectWithoutSchedulesInput
    upsert?: AgentUpsertWithoutSchedulesInput
    connect?: AgentWhereUniqueInput
    update?: XOR<XOR<AgentUpdateToOneWithWhereWithoutSchedulesInput, AgentUpdateWithoutSchedulesInput>, AgentUncheckedUpdateWithoutSchedulesInput>
  }

  export type NestedStringFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[] | ListStringFieldRefInput<$PrismaModel>
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel>
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringFilter<$PrismaModel> | string
  }

  export type NestedEnumUserRoleFilter<$PrismaModel = never> = {
    equals?: $Enums.UserRole | EnumUserRoleFieldRefInput<$PrismaModel>
    in?: $Enums.UserRole[] | ListEnumUserRoleFieldRefInput<$PrismaModel>
    notIn?: $Enums.UserRole[] | ListEnumUserRoleFieldRefInput<$PrismaModel>
    not?: NestedEnumUserRoleFilter<$PrismaModel> | $Enums.UserRole
  }

  export type NestedDateTimeNullableFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel> | null
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeNullableFilter<$PrismaModel> | Date | string | null
  }

  export type NestedBoolFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel>
    not?: NestedBoolFilter<$PrismaModel> | boolean
  }

  export type NestedStringNullableFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringNullableFilter<$PrismaModel> | string | null
  }

  export type NestedDateTimeFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeFilter<$PrismaModel> | Date | string
  }

  export type NestedStringWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[] | ListStringFieldRefInput<$PrismaModel>
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel>
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringWithAggregatesFilter<$PrismaModel> | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedStringFilter<$PrismaModel>
    _max?: NestedStringFilter<$PrismaModel>
  }

  export type NestedIntFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[] | ListIntFieldRefInput<$PrismaModel>
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel>
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntFilter<$PrismaModel> | number
  }

  export type NestedEnumUserRoleWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.UserRole | EnumUserRoleFieldRefInput<$PrismaModel>
    in?: $Enums.UserRole[] | ListEnumUserRoleFieldRefInput<$PrismaModel>
    notIn?: $Enums.UserRole[] | ListEnumUserRoleFieldRefInput<$PrismaModel>
    not?: NestedEnumUserRoleWithAggregatesFilter<$PrismaModel> | $Enums.UserRole
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumUserRoleFilter<$PrismaModel>
    _max?: NestedEnumUserRoleFilter<$PrismaModel>
  }

  export type NestedDateTimeNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel> | null
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeNullableWithAggregatesFilter<$PrismaModel> | Date | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedDateTimeNullableFilter<$PrismaModel>
    _max?: NestedDateTimeNullableFilter<$PrismaModel>
  }

  export type NestedIntNullableFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel> | null
    in?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntNullableFilter<$PrismaModel> | number | null
  }

  export type NestedBoolWithAggregatesFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel>
    not?: NestedBoolWithAggregatesFilter<$PrismaModel> | boolean
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedBoolFilter<$PrismaModel>
    _max?: NestedBoolFilter<$PrismaModel>
  }

  export type NestedStringNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringNullableWithAggregatesFilter<$PrismaModel> | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedStringNullableFilter<$PrismaModel>
    _max?: NestedStringNullableFilter<$PrismaModel>
  }

  export type NestedDateTimeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeWithAggregatesFilter<$PrismaModel> | Date | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedDateTimeFilter<$PrismaModel>
    _max?: NestedDateTimeFilter<$PrismaModel>
  }

  export type NestedEnumVehicleTypeFilter<$PrismaModel = never> = {
    equals?: $Enums.VehicleType | EnumVehicleTypeFieldRefInput<$PrismaModel>
    in?: $Enums.VehicleType[] | ListEnumVehicleTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.VehicleType[] | ListEnumVehicleTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumVehicleTypeFilter<$PrismaModel> | $Enums.VehicleType
  }

  export type NestedEnumAgentStatusFilter<$PrismaModel = never> = {
    equals?: $Enums.AgentStatus | EnumAgentStatusFieldRefInput<$PrismaModel>
    in?: $Enums.AgentStatus[] | ListEnumAgentStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.AgentStatus[] | ListEnumAgentStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumAgentStatusFilter<$PrismaModel> | $Enums.AgentStatus
  }

  export type NestedFloatNullableFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel> | null
    in?: number[] | ListFloatFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListFloatFieldRefInput<$PrismaModel> | null
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatNullableFilter<$PrismaModel> | number | null
  }

  export type NestedFloatFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel>
    in?: number[] | ListFloatFieldRefInput<$PrismaModel>
    notIn?: number[] | ListFloatFieldRefInput<$PrismaModel>
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatFilter<$PrismaModel> | number
  }

  export type NestedEnumVehicleTypeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.VehicleType | EnumVehicleTypeFieldRefInput<$PrismaModel>
    in?: $Enums.VehicleType[] | ListEnumVehicleTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.VehicleType[] | ListEnumVehicleTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumVehicleTypeWithAggregatesFilter<$PrismaModel> | $Enums.VehicleType
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumVehicleTypeFilter<$PrismaModel>
    _max?: NestedEnumVehicleTypeFilter<$PrismaModel>
  }

  export type NestedEnumAgentStatusWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.AgentStatus | EnumAgentStatusFieldRefInput<$PrismaModel>
    in?: $Enums.AgentStatus[] | ListEnumAgentStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.AgentStatus[] | ListEnumAgentStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumAgentStatusWithAggregatesFilter<$PrismaModel> | $Enums.AgentStatus
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumAgentStatusFilter<$PrismaModel>
    _max?: NestedEnumAgentStatusFilter<$PrismaModel>
  }

  export type NestedFloatNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel> | null
    in?: number[] | ListFloatFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListFloatFieldRefInput<$PrismaModel> | null
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatNullableWithAggregatesFilter<$PrismaModel> | number | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _avg?: NestedFloatNullableFilter<$PrismaModel>
    _sum?: NestedFloatNullableFilter<$PrismaModel>
    _min?: NestedFloatNullableFilter<$PrismaModel>
    _max?: NestedFloatNullableFilter<$PrismaModel>
  }

  export type NestedIntWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[] | ListIntFieldRefInput<$PrismaModel>
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel>
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntWithAggregatesFilter<$PrismaModel> | number
    _count?: NestedIntFilter<$PrismaModel>
    _avg?: NestedFloatFilter<$PrismaModel>
    _sum?: NestedIntFilter<$PrismaModel>
    _min?: NestedIntFilter<$PrismaModel>
    _max?: NestedIntFilter<$PrismaModel>
  }

  export type NestedFloatWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel>
    in?: number[] | ListFloatFieldRefInput<$PrismaModel>
    notIn?: number[] | ListFloatFieldRefInput<$PrismaModel>
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatWithAggregatesFilter<$PrismaModel> | number
    _count?: NestedIntFilter<$PrismaModel>
    _avg?: NestedFloatFilter<$PrismaModel>
    _sum?: NestedFloatFilter<$PrismaModel>
    _min?: NestedFloatFilter<$PrismaModel>
    _max?: NestedFloatFilter<$PrismaModel>
  }

  export type NestedEnumOrderStatusFilter<$PrismaModel = never> = {
    equals?: $Enums.OrderStatus | EnumOrderStatusFieldRefInput<$PrismaModel>
    in?: $Enums.OrderStatus[] | ListEnumOrderStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.OrderStatus[] | ListEnumOrderStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumOrderStatusFilter<$PrismaModel> | $Enums.OrderStatus
  }

  export type NestedEnumOrderStatusWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.OrderStatus | EnumOrderStatusFieldRefInput<$PrismaModel>
    in?: $Enums.OrderStatus[] | ListEnumOrderStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.OrderStatus[] | ListEnumOrderStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumOrderStatusWithAggregatesFilter<$PrismaModel> | $Enums.OrderStatus
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumOrderStatusFilter<$PrismaModel>
    _max?: NestedEnumOrderStatusFilter<$PrismaModel>
  }

  export type NestedIntNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel> | null
    in?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntNullableWithAggregatesFilter<$PrismaModel> | number | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _avg?: NestedFloatNullableFilter<$PrismaModel>
    _sum?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedIntNullableFilter<$PrismaModel>
    _max?: NestedIntNullableFilter<$PrismaModel>
  }

  export type NestedEnumTicketStatusFilter<$PrismaModel = never> = {
    equals?: $Enums.TicketStatus | EnumTicketStatusFieldRefInput<$PrismaModel>
    in?: $Enums.TicketStatus[] | ListEnumTicketStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.TicketStatus[] | ListEnumTicketStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumTicketStatusFilter<$PrismaModel> | $Enums.TicketStatus
  }

  export type NestedEnumTicketStatusWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.TicketStatus | EnumTicketStatusFieldRefInput<$PrismaModel>
    in?: $Enums.TicketStatus[] | ListEnumTicketStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.TicketStatus[] | ListEnumTicketStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumTicketStatusWithAggregatesFilter<$PrismaModel> | $Enums.TicketStatus
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumTicketStatusFilter<$PrismaModel>
    _max?: NestedEnumTicketStatusFilter<$PrismaModel>
  }

  export type NestedEnumActorTypeFilter<$PrismaModel = never> = {
    equals?: $Enums.ActorType | EnumActorTypeFieldRefInput<$PrismaModel>
    in?: $Enums.ActorType[] | ListEnumActorTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.ActorType[] | ListEnumActorTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumActorTypeFilter<$PrismaModel> | $Enums.ActorType
  }

  export type NestedEnumEventTypeFilter<$PrismaModel = never> = {
    equals?: $Enums.EventType | EnumEventTypeFieldRefInput<$PrismaModel>
    in?: $Enums.EventType[] | ListEnumEventTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.EventType[] | ListEnumEventTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumEventTypeFilter<$PrismaModel> | $Enums.EventType
  }

  export type NestedEnumActorTypeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.ActorType | EnumActorTypeFieldRefInput<$PrismaModel>
    in?: $Enums.ActorType[] | ListEnumActorTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.ActorType[] | ListEnumActorTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumActorTypeWithAggregatesFilter<$PrismaModel> | $Enums.ActorType
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumActorTypeFilter<$PrismaModel>
    _max?: NestedEnumActorTypeFilter<$PrismaModel>
  }

  export type NestedEnumEventTypeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.EventType | EnumEventTypeFieldRefInput<$PrismaModel>
    in?: $Enums.EventType[] | ListEnumEventTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.EventType[] | ListEnumEventTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumEventTypeWithAggregatesFilter<$PrismaModel> | $Enums.EventType
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumEventTypeFilter<$PrismaModel>
    _max?: NestedEnumEventTypeFilter<$PrismaModel>
  }
  export type NestedJsonNullableFilter<$PrismaModel = never> =
    | PatchUndefined<
        Either<Required<NestedJsonNullableFilterBase<$PrismaModel>>, Exclude<keyof Required<NestedJsonNullableFilterBase<$PrismaModel>>, 'path'>>,
        Required<NestedJsonNullableFilterBase<$PrismaModel>>
      >
    | OptionalFlat<Omit<Required<NestedJsonNullableFilterBase<$PrismaModel>>, 'path'>>

  export type NestedJsonNullableFilterBase<$PrismaModel = never> = {
    equals?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
    path?: string[]
    mode?: QueryMode | EnumQueryModeFieldRefInput<$PrismaModel>
    string_contains?: string | StringFieldRefInput<$PrismaModel>
    string_starts_with?: string | StringFieldRefInput<$PrismaModel>
    string_ends_with?: string | StringFieldRefInput<$PrismaModel>
    array_starts_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_ends_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_contains?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    lt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    lte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    not?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
  }

  export type AgentCreateWithoutUserInput = {
    id?: string
    vehicleType: $Enums.VehicleType
    status?: $Enums.AgentStatus
    rating?: number | null
    totalOrders?: number
    completedOrders?: number
    cancelledOrders?: number
    acceptanceRate?: number
    isApproved?: boolean
    isBlocked?: boolean
    blockedReason?: string | null
    city?: string | null
    state?: string | null
    pincode?: string | null
    lastOnlineAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    orders?: OrderCreateNestedManyWithoutAgentInput
    currentOrder?: OrderCreateNestedOneWithoutCurrentAgentInput
    documents?: AgentDocumentCreateNestedManyWithoutAgentInput
    locationHistory?: AgentLocationCreateNestedManyWithoutAgentInput
    tickets?: SupportTicketCreateNestedManyWithoutAgentInput
    ratings?: AgentRatingCreateNestedManyWithoutAgentInput
    wallet?: AgentWalletCreateNestedOneWithoutAgentInput
    walletPayouts?: WalletPayoutCreateNestedManyWithoutAgentInput
    payments?: PaymentCreateNestedManyWithoutAgentInput
    payrolls?: PayrollCreateNestedManyWithoutAgentInput
    schedules?: AgentScheduleCreateNestedManyWithoutAgentInput
  }

  export type AgentUncheckedCreateWithoutUserInput = {
    id?: string
    vehicleType: $Enums.VehicleType
    status?: $Enums.AgentStatus
    rating?: number | null
    totalOrders?: number
    completedOrders?: number
    cancelledOrders?: number
    acceptanceRate?: number
    currentOrderId?: string | null
    isApproved?: boolean
    isBlocked?: boolean
    blockedReason?: string | null
    city?: string | null
    state?: string | null
    pincode?: string | null
    lastOnlineAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    orders?: OrderUncheckedCreateNestedManyWithoutAgentInput
    documents?: AgentDocumentUncheckedCreateNestedManyWithoutAgentInput
    locationHistory?: AgentLocationUncheckedCreateNestedManyWithoutAgentInput
    tickets?: SupportTicketUncheckedCreateNestedManyWithoutAgentInput
    ratings?: AgentRatingUncheckedCreateNestedManyWithoutAgentInput
    wallet?: AgentWalletUncheckedCreateNestedOneWithoutAgentInput
    walletPayouts?: WalletPayoutUncheckedCreateNestedManyWithoutAgentInput
    payments?: PaymentUncheckedCreateNestedManyWithoutAgentInput
    payrolls?: PayrollUncheckedCreateNestedManyWithoutAgentInput
    schedules?: AgentScheduleUncheckedCreateNestedManyWithoutAgentInput
  }

  export type AgentCreateOrConnectWithoutUserInput = {
    where: AgentWhereUniqueInput
    create: XOR<AgentCreateWithoutUserInput, AgentUncheckedCreateWithoutUserInput>
  }

  export type PartnerCreateWithoutUserInput = {
    id?: string
    companyName: string
    apiKey: string
    webhookUrl?: string | null
    isActive?: boolean
    city?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    orders?: OrderCreateNestedManyWithoutPartnerInput
    tickets?: SupportTicketCreateNestedManyWithoutPartnerInput
    dailyStats?: PartnerDailyStatsCreateNestedManyWithoutPartnerInput
    agentRatings?: AgentRatingCreateNestedManyWithoutPartnerInput
    partnerRevenues?: PartnerRevenueCreateNestedManyWithoutPartnerInput
    platformRevenues?: PlatformRevenueCreateNestedManyWithoutPartnerInput
  }

  export type PartnerUncheckedCreateWithoutUserInput = {
    id?: string
    companyName: string
    apiKey: string
    webhookUrl?: string | null
    isActive?: boolean
    city?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    orders?: OrderUncheckedCreateNestedManyWithoutPartnerInput
    tickets?: SupportTicketUncheckedCreateNestedManyWithoutPartnerInput
    dailyStats?: PartnerDailyStatsUncheckedCreateNestedManyWithoutPartnerInput
    agentRatings?: AgentRatingUncheckedCreateNestedManyWithoutPartnerInput
    partnerRevenues?: PartnerRevenueUncheckedCreateNestedManyWithoutPartnerInput
    platformRevenues?: PlatformRevenueUncheckedCreateNestedManyWithoutPartnerInput
  }

  export type PartnerCreateOrConnectWithoutUserInput = {
    where: PartnerWhereUniqueInput
    create: XOR<PartnerCreateWithoutUserInput, PartnerUncheckedCreateWithoutUserInput>
  }

  export type NotificationTokenCreateWithoutUserInput = {
    id?: string
    fcmToken: string
    deviceType?: string | null
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type NotificationTokenUncheckedCreateWithoutUserInput = {
    id?: string
    fcmToken: string
    deviceType?: string | null
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type NotificationTokenCreateOrConnectWithoutUserInput = {
    where: NotificationTokenWhereUniqueInput
    create: XOR<NotificationTokenCreateWithoutUserInput, NotificationTokenUncheckedCreateWithoutUserInput>
  }

  export type NotificationTokenCreateManyUserInputEnvelope = {
    data: NotificationTokenCreateManyUserInput | NotificationTokenCreateManyUserInput[]
    skipDuplicates?: boolean
  }

  export type NotificationCreateWithoutUserInput = {
    id?: string
    title: string
    message: string
    type: string
    isRead?: boolean
    link?: string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    readAt?: Date | string | null
  }

  export type NotificationUncheckedCreateWithoutUserInput = {
    id?: string
    title: string
    message: string
    type: string
    isRead?: boolean
    link?: string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    readAt?: Date | string | null
  }

  export type NotificationCreateOrConnectWithoutUserInput = {
    where: NotificationWhereUniqueInput
    create: XOR<NotificationCreateWithoutUserInput, NotificationUncheckedCreateWithoutUserInput>
  }

  export type NotificationCreateManyUserInputEnvelope = {
    data: NotificationCreateManyUserInput | NotificationCreateManyUserInput[]
    skipDuplicates?: boolean
  }

  export type SupportTicketCreateWithoutUserInput = {
    id?: string
    issueType: string
    description: string
    status?: $Enums.TicketStatus
    resolvedAt?: Date | string | null
    adminNotes?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    order?: OrderCreateNestedOneWithoutTicketsInput
    agent?: AgentCreateNestedOneWithoutTicketsInput
    partner?: PartnerCreateNestedOneWithoutTicketsInput
  }

  export type SupportTicketUncheckedCreateWithoutUserInput = {
    id?: string
    orderId?: string | null
    agentId?: string | null
    partnerId?: string | null
    issueType: string
    description: string
    status?: $Enums.TicketStatus
    resolvedAt?: Date | string | null
    adminNotes?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type SupportTicketCreateOrConnectWithoutUserInput = {
    where: SupportTicketWhereUniqueInput
    create: XOR<SupportTicketCreateWithoutUserInput, SupportTicketUncheckedCreateWithoutUserInput>
  }

  export type SupportTicketCreateManyUserInputEnvelope = {
    data: SupportTicketCreateManyUserInput | SupportTicketCreateManyUserInput[]
    skipDuplicates?: boolean
  }

  export type AgentUpsertWithoutUserInput = {
    update: XOR<AgentUpdateWithoutUserInput, AgentUncheckedUpdateWithoutUserInput>
    create: XOR<AgentCreateWithoutUserInput, AgentUncheckedCreateWithoutUserInput>
    where?: AgentWhereInput
  }

  export type AgentUpdateToOneWithWhereWithoutUserInput = {
    where?: AgentWhereInput
    data: XOR<AgentUpdateWithoutUserInput, AgentUncheckedUpdateWithoutUserInput>
  }

  export type AgentUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    vehicleType?: EnumVehicleTypeFieldUpdateOperationsInput | $Enums.VehicleType
    status?: EnumAgentStatusFieldUpdateOperationsInput | $Enums.AgentStatus
    rating?: NullableFloatFieldUpdateOperationsInput | number | null
    totalOrders?: IntFieldUpdateOperationsInput | number
    completedOrders?: IntFieldUpdateOperationsInput | number
    cancelledOrders?: IntFieldUpdateOperationsInput | number
    acceptanceRate?: FloatFieldUpdateOperationsInput | number
    isApproved?: BoolFieldUpdateOperationsInput | boolean
    isBlocked?: BoolFieldUpdateOperationsInput | boolean
    blockedReason?: NullableStringFieldUpdateOperationsInput | string | null
    city?: NullableStringFieldUpdateOperationsInput | string | null
    state?: NullableStringFieldUpdateOperationsInput | string | null
    pincode?: NullableStringFieldUpdateOperationsInput | string | null
    lastOnlineAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    orders?: OrderUpdateManyWithoutAgentNestedInput
    currentOrder?: OrderUpdateOneWithoutCurrentAgentNestedInput
    documents?: AgentDocumentUpdateManyWithoutAgentNestedInput
    locationHistory?: AgentLocationUpdateManyWithoutAgentNestedInput
    tickets?: SupportTicketUpdateManyWithoutAgentNestedInput
    ratings?: AgentRatingUpdateManyWithoutAgentNestedInput
    wallet?: AgentWalletUpdateOneWithoutAgentNestedInput
    walletPayouts?: WalletPayoutUpdateManyWithoutAgentNestedInput
    payments?: PaymentUpdateManyWithoutAgentNestedInput
    payrolls?: PayrollUpdateManyWithoutAgentNestedInput
    schedules?: AgentScheduleUpdateManyWithoutAgentNestedInput
  }

  export type AgentUncheckedUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    vehicleType?: EnumVehicleTypeFieldUpdateOperationsInput | $Enums.VehicleType
    status?: EnumAgentStatusFieldUpdateOperationsInput | $Enums.AgentStatus
    rating?: NullableFloatFieldUpdateOperationsInput | number | null
    totalOrders?: IntFieldUpdateOperationsInput | number
    completedOrders?: IntFieldUpdateOperationsInput | number
    cancelledOrders?: IntFieldUpdateOperationsInput | number
    acceptanceRate?: FloatFieldUpdateOperationsInput | number
    currentOrderId?: NullableStringFieldUpdateOperationsInput | string | null
    isApproved?: BoolFieldUpdateOperationsInput | boolean
    isBlocked?: BoolFieldUpdateOperationsInput | boolean
    blockedReason?: NullableStringFieldUpdateOperationsInput | string | null
    city?: NullableStringFieldUpdateOperationsInput | string | null
    state?: NullableStringFieldUpdateOperationsInput | string | null
    pincode?: NullableStringFieldUpdateOperationsInput | string | null
    lastOnlineAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    orders?: OrderUncheckedUpdateManyWithoutAgentNestedInput
    documents?: AgentDocumentUncheckedUpdateManyWithoutAgentNestedInput
    locationHistory?: AgentLocationUncheckedUpdateManyWithoutAgentNestedInput
    tickets?: SupportTicketUncheckedUpdateManyWithoutAgentNestedInput
    ratings?: AgentRatingUncheckedUpdateManyWithoutAgentNestedInput
    wallet?: AgentWalletUncheckedUpdateOneWithoutAgentNestedInput
    walletPayouts?: WalletPayoutUncheckedUpdateManyWithoutAgentNestedInput
    payments?: PaymentUncheckedUpdateManyWithoutAgentNestedInput
    payrolls?: PayrollUncheckedUpdateManyWithoutAgentNestedInput
    schedules?: AgentScheduleUncheckedUpdateManyWithoutAgentNestedInput
  }

  export type PartnerUpsertWithoutUserInput = {
    update: XOR<PartnerUpdateWithoutUserInput, PartnerUncheckedUpdateWithoutUserInput>
    create: XOR<PartnerCreateWithoutUserInput, PartnerUncheckedCreateWithoutUserInput>
    where?: PartnerWhereInput
  }

  export type PartnerUpdateToOneWithWhereWithoutUserInput = {
    where?: PartnerWhereInput
    data: XOR<PartnerUpdateWithoutUserInput, PartnerUncheckedUpdateWithoutUserInput>
  }

  export type PartnerUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    companyName?: StringFieldUpdateOperationsInput | string
    apiKey?: StringFieldUpdateOperationsInput | string
    webhookUrl?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    city?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    orders?: OrderUpdateManyWithoutPartnerNestedInput
    tickets?: SupportTicketUpdateManyWithoutPartnerNestedInput
    dailyStats?: PartnerDailyStatsUpdateManyWithoutPartnerNestedInput
    agentRatings?: AgentRatingUpdateManyWithoutPartnerNestedInput
    partnerRevenues?: PartnerRevenueUpdateManyWithoutPartnerNestedInput
    platformRevenues?: PlatformRevenueUpdateManyWithoutPartnerNestedInput
  }

  export type PartnerUncheckedUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    companyName?: StringFieldUpdateOperationsInput | string
    apiKey?: StringFieldUpdateOperationsInput | string
    webhookUrl?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    city?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    orders?: OrderUncheckedUpdateManyWithoutPartnerNestedInput
    tickets?: SupportTicketUncheckedUpdateManyWithoutPartnerNestedInput
    dailyStats?: PartnerDailyStatsUncheckedUpdateManyWithoutPartnerNestedInput
    agentRatings?: AgentRatingUncheckedUpdateManyWithoutPartnerNestedInput
    partnerRevenues?: PartnerRevenueUncheckedUpdateManyWithoutPartnerNestedInput
    platformRevenues?: PlatformRevenueUncheckedUpdateManyWithoutPartnerNestedInput
  }

  export type NotificationTokenUpsertWithWhereUniqueWithoutUserInput = {
    where: NotificationTokenWhereUniqueInput
    update: XOR<NotificationTokenUpdateWithoutUserInput, NotificationTokenUncheckedUpdateWithoutUserInput>
    create: XOR<NotificationTokenCreateWithoutUserInput, NotificationTokenUncheckedCreateWithoutUserInput>
  }

  export type NotificationTokenUpdateWithWhereUniqueWithoutUserInput = {
    where: NotificationTokenWhereUniqueInput
    data: XOR<NotificationTokenUpdateWithoutUserInput, NotificationTokenUncheckedUpdateWithoutUserInput>
  }

  export type NotificationTokenUpdateManyWithWhereWithoutUserInput = {
    where: NotificationTokenScalarWhereInput
    data: XOR<NotificationTokenUpdateManyMutationInput, NotificationTokenUncheckedUpdateManyWithoutUserInput>
  }

  export type NotificationTokenScalarWhereInput = {
    AND?: NotificationTokenScalarWhereInput | NotificationTokenScalarWhereInput[]
    OR?: NotificationTokenScalarWhereInput[]
    NOT?: NotificationTokenScalarWhereInput | NotificationTokenScalarWhereInput[]
    id?: StringFilter<"NotificationToken"> | string
    userId?: StringFilter<"NotificationToken"> | string
    fcmToken?: StringFilter<"NotificationToken"> | string
    deviceType?: StringNullableFilter<"NotificationToken"> | string | null
    isActive?: BoolFilter<"NotificationToken"> | boolean
    createdAt?: DateTimeFilter<"NotificationToken"> | Date | string
    updatedAt?: DateTimeFilter<"NotificationToken"> | Date | string
  }

  export type NotificationUpsertWithWhereUniqueWithoutUserInput = {
    where: NotificationWhereUniqueInput
    update: XOR<NotificationUpdateWithoutUserInput, NotificationUncheckedUpdateWithoutUserInput>
    create: XOR<NotificationCreateWithoutUserInput, NotificationUncheckedCreateWithoutUserInput>
  }

  export type NotificationUpdateWithWhereUniqueWithoutUserInput = {
    where: NotificationWhereUniqueInput
    data: XOR<NotificationUpdateWithoutUserInput, NotificationUncheckedUpdateWithoutUserInput>
  }

  export type NotificationUpdateManyWithWhereWithoutUserInput = {
    where: NotificationScalarWhereInput
    data: XOR<NotificationUpdateManyMutationInput, NotificationUncheckedUpdateManyWithoutUserInput>
  }

  export type NotificationScalarWhereInput = {
    AND?: NotificationScalarWhereInput | NotificationScalarWhereInput[]
    OR?: NotificationScalarWhereInput[]
    NOT?: NotificationScalarWhereInput | NotificationScalarWhereInput[]
    id?: StringFilter<"Notification"> | string
    userId?: StringFilter<"Notification"> | string
    title?: StringFilter<"Notification"> | string
    message?: StringFilter<"Notification"> | string
    type?: StringFilter<"Notification"> | string
    isRead?: BoolFilter<"Notification"> | boolean
    link?: StringNullableFilter<"Notification"> | string | null
    metadata?: JsonNullableFilter<"Notification">
    createdAt?: DateTimeFilter<"Notification"> | Date | string
    readAt?: DateTimeNullableFilter<"Notification"> | Date | string | null
  }

  export type SupportTicketUpsertWithWhereUniqueWithoutUserInput = {
    where: SupportTicketWhereUniqueInput
    update: XOR<SupportTicketUpdateWithoutUserInput, SupportTicketUncheckedUpdateWithoutUserInput>
    create: XOR<SupportTicketCreateWithoutUserInput, SupportTicketUncheckedCreateWithoutUserInput>
  }

  export type SupportTicketUpdateWithWhereUniqueWithoutUserInput = {
    where: SupportTicketWhereUniqueInput
    data: XOR<SupportTicketUpdateWithoutUserInput, SupportTicketUncheckedUpdateWithoutUserInput>
  }

  export type SupportTicketUpdateManyWithWhereWithoutUserInput = {
    where: SupportTicketScalarWhereInput
    data: XOR<SupportTicketUpdateManyMutationInput, SupportTicketUncheckedUpdateManyWithoutUserInput>
  }

  export type SupportTicketScalarWhereInput = {
    AND?: SupportTicketScalarWhereInput | SupportTicketScalarWhereInput[]
    OR?: SupportTicketScalarWhereInput[]
    NOT?: SupportTicketScalarWhereInput | SupportTicketScalarWhereInput[]
    id?: StringFilter<"SupportTicket"> | string
    orderId?: StringNullableFilter<"SupportTicket"> | string | null
    agentId?: StringNullableFilter<"SupportTicket"> | string | null
    partnerId?: StringNullableFilter<"SupportTicket"> | string | null
    userId?: StringFilter<"SupportTicket"> | string
    issueType?: StringFilter<"SupportTicket"> | string
    description?: StringFilter<"SupportTicket"> | string
    status?: EnumTicketStatusFilter<"SupportTicket"> | $Enums.TicketStatus
    resolvedAt?: DateTimeNullableFilter<"SupportTicket"> | Date | string | null
    adminNotes?: StringNullableFilter<"SupportTicket"> | string | null
    createdAt?: DateTimeFilter<"SupportTicket"> | Date | string
    updatedAt?: DateTimeFilter<"SupportTicket"> | Date | string
  }

  export type UserCreateWithoutAgentInput = {
    id?: string
    name: string
    email: string
    phone: string
    passwordHash: string
    role: $Enums.UserRole
    emailVerified?: Date | string | null
    phoneVerified?: boolean
    profilePicture?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    partner?: PartnerCreateNestedOneWithoutUserInput
    notifications?: NotificationTokenCreateNestedManyWithoutUserInput
    userNotifications?: NotificationCreateNestedManyWithoutUserInput
    tickets?: SupportTicketCreateNestedManyWithoutUserInput
  }

  export type UserUncheckedCreateWithoutAgentInput = {
    id?: string
    name: string
    email: string
    phone: string
    passwordHash: string
    role: $Enums.UserRole
    emailVerified?: Date | string | null
    phoneVerified?: boolean
    profilePicture?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    partner?: PartnerUncheckedCreateNestedOneWithoutUserInput
    notifications?: NotificationTokenUncheckedCreateNestedManyWithoutUserInput
    userNotifications?: NotificationUncheckedCreateNestedManyWithoutUserInput
    tickets?: SupportTicketUncheckedCreateNestedManyWithoutUserInput
  }

  export type UserCreateOrConnectWithoutAgentInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutAgentInput, UserUncheckedCreateWithoutAgentInput>
  }

  export type OrderCreateWithoutAgentInput = {
    id?: string
    pickupLat: number
    pickupLng: number
    dropLat: number
    dropLng: number
    payoutAmount: number
    orderAmount?: number | null
    platformFee?: number | null
    orderType?: string | null
    commissionRate?: number | null
    priority?: string | null
    status?: $Enums.OrderStatus
    assignedAt?: Date | string | null
    pickedUpAt?: Date | string | null
    deliveredAt?: Date | string | null
    cancelledAt?: Date | string | null
    cancellationReason?: string | null
    estimatedDuration?: number | null
    actualDuration?: number | null
    createdAt?: Date | string
    updatedAt?: Date | string
    barcode?: string | null
    qrCode?: string | null
    deliveryOtp?: string | null
    deliveryQrCode?: string | null
    otpExpiresAt?: Date | string | null
    verifiedAt?: Date | string | null
    verificationMethod?: string | null
    partner: PartnerCreateNestedOneWithoutOrdersInput
    currentAgent?: AgentCreateNestedOneWithoutCurrentOrderInput
    tickets?: SupportTicketCreateNestedManyWithoutOrderInput
    rating?: AgentRatingCreateNestedOneWithoutOrderInput
    payments?: PaymentCreateNestedManyWithoutOrderInput
    partnerRevenue?: PartnerRevenueCreateNestedOneWithoutOrderInput
    platformRevenue?: PlatformRevenueCreateNestedOneWithoutOrderInput
    walletTransactions?: WalletTransactionCreateNestedManyWithoutOrderInput
  }

  export type OrderUncheckedCreateWithoutAgentInput = {
    id?: string
    partnerId: string
    pickupLat: number
    pickupLng: number
    dropLat: number
    dropLng: number
    payoutAmount: number
    orderAmount?: number | null
    platformFee?: number | null
    orderType?: string | null
    commissionRate?: number | null
    priority?: string | null
    status?: $Enums.OrderStatus
    assignedAt?: Date | string | null
    pickedUpAt?: Date | string | null
    deliveredAt?: Date | string | null
    cancelledAt?: Date | string | null
    cancellationReason?: string | null
    estimatedDuration?: number | null
    actualDuration?: number | null
    createdAt?: Date | string
    updatedAt?: Date | string
    barcode?: string | null
    qrCode?: string | null
    deliveryOtp?: string | null
    deliveryQrCode?: string | null
    otpExpiresAt?: Date | string | null
    verifiedAt?: Date | string | null
    verificationMethod?: string | null
    currentAgent?: AgentUncheckedCreateNestedOneWithoutCurrentOrderInput
    tickets?: SupportTicketUncheckedCreateNestedManyWithoutOrderInput
    rating?: AgentRatingUncheckedCreateNestedOneWithoutOrderInput
    payments?: PaymentUncheckedCreateNestedManyWithoutOrderInput
    partnerRevenue?: PartnerRevenueUncheckedCreateNestedOneWithoutOrderInput
    platformRevenue?: PlatformRevenueUncheckedCreateNestedOneWithoutOrderInput
    walletTransactions?: WalletTransactionUncheckedCreateNestedManyWithoutOrderInput
  }

  export type OrderCreateOrConnectWithoutAgentInput = {
    where: OrderWhereUniqueInput
    create: XOR<OrderCreateWithoutAgentInput, OrderUncheckedCreateWithoutAgentInput>
  }

  export type OrderCreateManyAgentInputEnvelope = {
    data: OrderCreateManyAgentInput | OrderCreateManyAgentInput[]
    skipDuplicates?: boolean
  }

  export type OrderCreateWithoutCurrentAgentInput = {
    id?: string
    pickupLat: number
    pickupLng: number
    dropLat: number
    dropLng: number
    payoutAmount: number
    orderAmount?: number | null
    platformFee?: number | null
    orderType?: string | null
    commissionRate?: number | null
    priority?: string | null
    status?: $Enums.OrderStatus
    assignedAt?: Date | string | null
    pickedUpAt?: Date | string | null
    deliveredAt?: Date | string | null
    cancelledAt?: Date | string | null
    cancellationReason?: string | null
    estimatedDuration?: number | null
    actualDuration?: number | null
    createdAt?: Date | string
    updatedAt?: Date | string
    barcode?: string | null
    qrCode?: string | null
    deliveryOtp?: string | null
    deliveryQrCode?: string | null
    otpExpiresAt?: Date | string | null
    verifiedAt?: Date | string | null
    verificationMethod?: string | null
    partner: PartnerCreateNestedOneWithoutOrdersInput
    agent?: AgentCreateNestedOneWithoutOrdersInput
    tickets?: SupportTicketCreateNestedManyWithoutOrderInput
    rating?: AgentRatingCreateNestedOneWithoutOrderInput
    payments?: PaymentCreateNestedManyWithoutOrderInput
    partnerRevenue?: PartnerRevenueCreateNestedOneWithoutOrderInput
    platformRevenue?: PlatformRevenueCreateNestedOneWithoutOrderInput
    walletTransactions?: WalletTransactionCreateNestedManyWithoutOrderInput
  }

  export type OrderUncheckedCreateWithoutCurrentAgentInput = {
    id?: string
    partnerId: string
    agentId?: string | null
    pickupLat: number
    pickupLng: number
    dropLat: number
    dropLng: number
    payoutAmount: number
    orderAmount?: number | null
    platformFee?: number | null
    orderType?: string | null
    commissionRate?: number | null
    priority?: string | null
    status?: $Enums.OrderStatus
    assignedAt?: Date | string | null
    pickedUpAt?: Date | string | null
    deliveredAt?: Date | string | null
    cancelledAt?: Date | string | null
    cancellationReason?: string | null
    estimatedDuration?: number | null
    actualDuration?: number | null
    createdAt?: Date | string
    updatedAt?: Date | string
    barcode?: string | null
    qrCode?: string | null
    deliveryOtp?: string | null
    deliveryQrCode?: string | null
    otpExpiresAt?: Date | string | null
    verifiedAt?: Date | string | null
    verificationMethod?: string | null
    tickets?: SupportTicketUncheckedCreateNestedManyWithoutOrderInput
    rating?: AgentRatingUncheckedCreateNestedOneWithoutOrderInput
    payments?: PaymentUncheckedCreateNestedManyWithoutOrderInput
    partnerRevenue?: PartnerRevenueUncheckedCreateNestedOneWithoutOrderInput
    platformRevenue?: PlatformRevenueUncheckedCreateNestedOneWithoutOrderInput
    walletTransactions?: WalletTransactionUncheckedCreateNestedManyWithoutOrderInput
  }

  export type OrderCreateOrConnectWithoutCurrentAgentInput = {
    where: OrderWhereUniqueInput
    create: XOR<OrderCreateWithoutCurrentAgentInput, OrderUncheckedCreateWithoutCurrentAgentInput>
  }

  export type AgentDocumentCreateWithoutAgentInput = {
    id?: string
    documentType: string
    fileName: string
    fileUrl: string
    verified?: boolean
    uploadedAt?: Date | string
  }

  export type AgentDocumentUncheckedCreateWithoutAgentInput = {
    id?: string
    documentType: string
    fileName: string
    fileUrl: string
    verified?: boolean
    uploadedAt?: Date | string
  }

  export type AgentDocumentCreateOrConnectWithoutAgentInput = {
    where: AgentDocumentWhereUniqueInput
    create: XOR<AgentDocumentCreateWithoutAgentInput, AgentDocumentUncheckedCreateWithoutAgentInput>
  }

  export type AgentDocumentCreateManyAgentInputEnvelope = {
    data: AgentDocumentCreateManyAgentInput | AgentDocumentCreateManyAgentInput[]
    skipDuplicates?: boolean
  }

  export type AgentLocationCreateWithoutAgentInput = {
    id?: string
    latitude: number
    longitude: number
    timestamp?: Date | string
  }

  export type AgentLocationUncheckedCreateWithoutAgentInput = {
    id?: string
    latitude: number
    longitude: number
    timestamp?: Date | string
  }

  export type AgentLocationCreateOrConnectWithoutAgentInput = {
    where: AgentLocationWhereUniqueInput
    create: XOR<AgentLocationCreateWithoutAgentInput, AgentLocationUncheckedCreateWithoutAgentInput>
  }

  export type AgentLocationCreateManyAgentInputEnvelope = {
    data: AgentLocationCreateManyAgentInput | AgentLocationCreateManyAgentInput[]
    skipDuplicates?: boolean
  }

  export type SupportTicketCreateWithoutAgentInput = {
    id?: string
    issueType: string
    description: string
    status?: $Enums.TicketStatus
    resolvedAt?: Date | string | null
    adminNotes?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    order?: OrderCreateNestedOneWithoutTicketsInput
    partner?: PartnerCreateNestedOneWithoutTicketsInput
    user: UserCreateNestedOneWithoutTicketsInput
  }

  export type SupportTicketUncheckedCreateWithoutAgentInput = {
    id?: string
    orderId?: string | null
    partnerId?: string | null
    userId: string
    issueType: string
    description: string
    status?: $Enums.TicketStatus
    resolvedAt?: Date | string | null
    adminNotes?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type SupportTicketCreateOrConnectWithoutAgentInput = {
    where: SupportTicketWhereUniqueInput
    create: XOR<SupportTicketCreateWithoutAgentInput, SupportTicketUncheckedCreateWithoutAgentInput>
  }

  export type SupportTicketCreateManyAgentInputEnvelope = {
    data: SupportTicketCreateManyAgentInput | SupportTicketCreateManyAgentInput[]
    skipDuplicates?: boolean
  }

  export type AgentRatingCreateWithoutAgentInput = {
    id?: string
    rating: number
    comment?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    order: OrderCreateNestedOneWithoutRatingInput
    partner: PartnerCreateNestedOneWithoutAgentRatingsInput
  }

  export type AgentRatingUncheckedCreateWithoutAgentInput = {
    id?: string
    orderId: string
    partnerId: string
    rating: number
    comment?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type AgentRatingCreateOrConnectWithoutAgentInput = {
    where: AgentRatingWhereUniqueInput
    create: XOR<AgentRatingCreateWithoutAgentInput, AgentRatingUncheckedCreateWithoutAgentInput>
  }

  export type AgentRatingCreateManyAgentInputEnvelope = {
    data: AgentRatingCreateManyAgentInput | AgentRatingCreateManyAgentInput[]
    skipDuplicates?: boolean
  }

  export type AgentWalletCreateWithoutAgentInput = {
    id?: string
    balance?: number
    totalEarned?: number
    totalPaidOut?: number
    lastPayoutDate?: Date | string | null
    nextPayoutDate?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    transactions?: WalletTransactionCreateNestedManyWithoutAgentWalletInput
    payouts?: WalletPayoutCreateNestedManyWithoutAgentWalletInput
  }

  export type AgentWalletUncheckedCreateWithoutAgentInput = {
    id?: string
    balance?: number
    totalEarned?: number
    totalPaidOut?: number
    lastPayoutDate?: Date | string | null
    nextPayoutDate?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    transactions?: WalletTransactionUncheckedCreateNestedManyWithoutAgentWalletInput
    payouts?: WalletPayoutUncheckedCreateNestedManyWithoutAgentWalletInput
  }

  export type AgentWalletCreateOrConnectWithoutAgentInput = {
    where: AgentWalletWhereUniqueInput
    create: XOR<AgentWalletCreateWithoutAgentInput, AgentWalletUncheckedCreateWithoutAgentInput>
  }

  export type WalletPayoutCreateWithoutAgentInput = {
    id?: string
    amount: number
    periodStart: Date | string
    periodEnd: Date | string
    status?: string
    paymentMethod?: string | null
    transactionId?: string | null
    bankAccount?: string | null
    upiId?: string | null
    processedAt?: Date | string | null
    failedAt?: Date | string | null
    failureReason?: string | null
    notes?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    agentWallet: AgentWalletCreateNestedOneWithoutPayoutsInput
  }

  export type WalletPayoutUncheckedCreateWithoutAgentInput = {
    id?: string
    agentWalletId: string
    amount: number
    periodStart: Date | string
    periodEnd: Date | string
    status?: string
    paymentMethod?: string | null
    transactionId?: string | null
    bankAccount?: string | null
    upiId?: string | null
    processedAt?: Date | string | null
    failedAt?: Date | string | null
    failureReason?: string | null
    notes?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type WalletPayoutCreateOrConnectWithoutAgentInput = {
    where: WalletPayoutWhereUniqueInput
    create: XOR<WalletPayoutCreateWithoutAgentInput, WalletPayoutUncheckedCreateWithoutAgentInput>
  }

  export type WalletPayoutCreateManyAgentInputEnvelope = {
    data: WalletPayoutCreateManyAgentInput | WalletPayoutCreateManyAgentInput[]
    skipDuplicates?: boolean
  }

  export type PaymentCreateWithoutAgentInput = {
    id?: string
    amount: number
    paymentType: string
    status?: string
    processedAt?: Date | string | null
    paymentMethod?: string | null
    transactionId?: string | null
    notes?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    order: OrderCreateNestedOneWithoutPaymentsInput
  }

  export type PaymentUncheckedCreateWithoutAgentInput = {
    id?: string
    orderId: string
    amount: number
    paymentType: string
    status?: string
    processedAt?: Date | string | null
    paymentMethod?: string | null
    transactionId?: string | null
    notes?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type PaymentCreateOrConnectWithoutAgentInput = {
    where: PaymentWhereUniqueInput
    create: XOR<PaymentCreateWithoutAgentInput, PaymentUncheckedCreateWithoutAgentInput>
  }

  export type PaymentCreateManyAgentInputEnvelope = {
    data: PaymentCreateManyAgentInput | PaymentCreateManyAgentInput[]
    skipDuplicates?: boolean
  }

  export type PayrollCreateWithoutAgentInput = {
    id?: string
    periodStart: Date | string
    periodEnd: Date | string
    periodType: string
    totalEarnings?: number
    totalOrders?: number
    basePay?: number
    bonuses?: number
    deductions?: number
    netPay?: number
    status?: string
    processedAt?: Date | string | null
    paidAt?: Date | string | null
    paymentMethod?: string | null
    transactionId?: string | null
    notes?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type PayrollUncheckedCreateWithoutAgentInput = {
    id?: string
    periodStart: Date | string
    periodEnd: Date | string
    periodType: string
    totalEarnings?: number
    totalOrders?: number
    basePay?: number
    bonuses?: number
    deductions?: number
    netPay?: number
    status?: string
    processedAt?: Date | string | null
    paidAt?: Date | string | null
    paymentMethod?: string | null
    transactionId?: string | null
    notes?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type PayrollCreateOrConnectWithoutAgentInput = {
    where: PayrollWhereUniqueInput
    create: XOR<PayrollCreateWithoutAgentInput, PayrollUncheckedCreateWithoutAgentInput>
  }

  export type PayrollCreateManyAgentInputEnvelope = {
    data: PayrollCreateManyAgentInput | PayrollCreateManyAgentInput[]
    skipDuplicates?: boolean
  }

  export type AgentScheduleCreateWithoutAgentInput = {
    id?: string
    date: Date | string
    startTime?: string | null
    endTime?: string | null
    isAvailable?: boolean
    notes?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type AgentScheduleUncheckedCreateWithoutAgentInput = {
    id?: string
    date: Date | string
    startTime?: string | null
    endTime?: string | null
    isAvailable?: boolean
    notes?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type AgentScheduleCreateOrConnectWithoutAgentInput = {
    where: AgentScheduleWhereUniqueInput
    create: XOR<AgentScheduleCreateWithoutAgentInput, AgentScheduleUncheckedCreateWithoutAgentInput>
  }

  export type AgentScheduleCreateManyAgentInputEnvelope = {
    data: AgentScheduleCreateManyAgentInput | AgentScheduleCreateManyAgentInput[]
    skipDuplicates?: boolean
  }

  export type UserUpsertWithoutAgentInput = {
    update: XOR<UserUpdateWithoutAgentInput, UserUncheckedUpdateWithoutAgentInput>
    create: XOR<UserCreateWithoutAgentInput, UserUncheckedCreateWithoutAgentInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutAgentInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutAgentInput, UserUncheckedUpdateWithoutAgentInput>
  }

  export type UserUpdateWithoutAgentInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    phone?: StringFieldUpdateOperationsInput | string
    passwordHash?: StringFieldUpdateOperationsInput | string
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    emailVerified?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    phoneVerified?: BoolFieldUpdateOperationsInput | boolean
    profilePicture?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    partner?: PartnerUpdateOneWithoutUserNestedInput
    notifications?: NotificationTokenUpdateManyWithoutUserNestedInput
    userNotifications?: NotificationUpdateManyWithoutUserNestedInput
    tickets?: SupportTicketUpdateManyWithoutUserNestedInput
  }

  export type UserUncheckedUpdateWithoutAgentInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    phone?: StringFieldUpdateOperationsInput | string
    passwordHash?: StringFieldUpdateOperationsInput | string
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    emailVerified?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    phoneVerified?: BoolFieldUpdateOperationsInput | boolean
    profilePicture?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    partner?: PartnerUncheckedUpdateOneWithoutUserNestedInput
    notifications?: NotificationTokenUncheckedUpdateManyWithoutUserNestedInput
    userNotifications?: NotificationUncheckedUpdateManyWithoutUserNestedInput
    tickets?: SupportTicketUncheckedUpdateManyWithoutUserNestedInput
  }

  export type OrderUpsertWithWhereUniqueWithoutAgentInput = {
    where: OrderWhereUniqueInput
    update: XOR<OrderUpdateWithoutAgentInput, OrderUncheckedUpdateWithoutAgentInput>
    create: XOR<OrderCreateWithoutAgentInput, OrderUncheckedCreateWithoutAgentInput>
  }

  export type OrderUpdateWithWhereUniqueWithoutAgentInput = {
    where: OrderWhereUniqueInput
    data: XOR<OrderUpdateWithoutAgentInput, OrderUncheckedUpdateWithoutAgentInput>
  }

  export type OrderUpdateManyWithWhereWithoutAgentInput = {
    where: OrderScalarWhereInput
    data: XOR<OrderUpdateManyMutationInput, OrderUncheckedUpdateManyWithoutAgentInput>
  }

  export type OrderScalarWhereInput = {
    AND?: OrderScalarWhereInput | OrderScalarWhereInput[]
    OR?: OrderScalarWhereInput[]
    NOT?: OrderScalarWhereInput | OrderScalarWhereInput[]
    id?: StringFilter<"Order"> | string
    partnerId?: StringFilter<"Order"> | string
    agentId?: StringNullableFilter<"Order"> | string | null
    pickupLat?: FloatFilter<"Order"> | number
    pickupLng?: FloatFilter<"Order"> | number
    dropLat?: FloatFilter<"Order"> | number
    dropLng?: FloatFilter<"Order"> | number
    payoutAmount?: FloatFilter<"Order"> | number
    orderAmount?: FloatNullableFilter<"Order"> | number | null
    platformFee?: FloatNullableFilter<"Order"> | number | null
    orderType?: StringNullableFilter<"Order"> | string | null
    commissionRate?: FloatNullableFilter<"Order"> | number | null
    priority?: StringNullableFilter<"Order"> | string | null
    status?: EnumOrderStatusFilter<"Order"> | $Enums.OrderStatus
    assignedAt?: DateTimeNullableFilter<"Order"> | Date | string | null
    pickedUpAt?: DateTimeNullableFilter<"Order"> | Date | string | null
    deliveredAt?: DateTimeNullableFilter<"Order"> | Date | string | null
    cancelledAt?: DateTimeNullableFilter<"Order"> | Date | string | null
    cancellationReason?: StringNullableFilter<"Order"> | string | null
    estimatedDuration?: IntNullableFilter<"Order"> | number | null
    actualDuration?: IntNullableFilter<"Order"> | number | null
    createdAt?: DateTimeFilter<"Order"> | Date | string
    updatedAt?: DateTimeFilter<"Order"> | Date | string
    barcode?: StringNullableFilter<"Order"> | string | null
    qrCode?: StringNullableFilter<"Order"> | string | null
    deliveryOtp?: StringNullableFilter<"Order"> | string | null
    deliveryQrCode?: StringNullableFilter<"Order"> | string | null
    otpExpiresAt?: DateTimeNullableFilter<"Order"> | Date | string | null
    verifiedAt?: DateTimeNullableFilter<"Order"> | Date | string | null
    verificationMethod?: StringNullableFilter<"Order"> | string | null
  }

  export type OrderUpsertWithoutCurrentAgentInput = {
    update: XOR<OrderUpdateWithoutCurrentAgentInput, OrderUncheckedUpdateWithoutCurrentAgentInput>
    create: XOR<OrderCreateWithoutCurrentAgentInput, OrderUncheckedCreateWithoutCurrentAgentInput>
    where?: OrderWhereInput
  }

  export type OrderUpdateToOneWithWhereWithoutCurrentAgentInput = {
    where?: OrderWhereInput
    data: XOR<OrderUpdateWithoutCurrentAgentInput, OrderUncheckedUpdateWithoutCurrentAgentInput>
  }

  export type OrderUpdateWithoutCurrentAgentInput = {
    id?: StringFieldUpdateOperationsInput | string
    pickupLat?: FloatFieldUpdateOperationsInput | number
    pickupLng?: FloatFieldUpdateOperationsInput | number
    dropLat?: FloatFieldUpdateOperationsInput | number
    dropLng?: FloatFieldUpdateOperationsInput | number
    payoutAmount?: FloatFieldUpdateOperationsInput | number
    orderAmount?: NullableFloatFieldUpdateOperationsInput | number | null
    platformFee?: NullableFloatFieldUpdateOperationsInput | number | null
    orderType?: NullableStringFieldUpdateOperationsInput | string | null
    commissionRate?: NullableFloatFieldUpdateOperationsInput | number | null
    priority?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumOrderStatusFieldUpdateOperationsInput | $Enums.OrderStatus
    assignedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    pickedUpAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    deliveredAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    cancelledAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    cancellationReason?: NullableStringFieldUpdateOperationsInput | string | null
    estimatedDuration?: NullableIntFieldUpdateOperationsInput | number | null
    actualDuration?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    barcode?: NullableStringFieldUpdateOperationsInput | string | null
    qrCode?: NullableStringFieldUpdateOperationsInput | string | null
    deliveryOtp?: NullableStringFieldUpdateOperationsInput | string | null
    deliveryQrCode?: NullableStringFieldUpdateOperationsInput | string | null
    otpExpiresAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    verifiedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    verificationMethod?: NullableStringFieldUpdateOperationsInput | string | null
    partner?: PartnerUpdateOneRequiredWithoutOrdersNestedInput
    agent?: AgentUpdateOneWithoutOrdersNestedInput
    tickets?: SupportTicketUpdateManyWithoutOrderNestedInput
    rating?: AgentRatingUpdateOneWithoutOrderNestedInput
    payments?: PaymentUpdateManyWithoutOrderNestedInput
    partnerRevenue?: PartnerRevenueUpdateOneWithoutOrderNestedInput
    platformRevenue?: PlatformRevenueUpdateOneWithoutOrderNestedInput
    walletTransactions?: WalletTransactionUpdateManyWithoutOrderNestedInput
  }

  export type OrderUncheckedUpdateWithoutCurrentAgentInput = {
    id?: StringFieldUpdateOperationsInput | string
    partnerId?: StringFieldUpdateOperationsInput | string
    agentId?: NullableStringFieldUpdateOperationsInput | string | null
    pickupLat?: FloatFieldUpdateOperationsInput | number
    pickupLng?: FloatFieldUpdateOperationsInput | number
    dropLat?: FloatFieldUpdateOperationsInput | number
    dropLng?: FloatFieldUpdateOperationsInput | number
    payoutAmount?: FloatFieldUpdateOperationsInput | number
    orderAmount?: NullableFloatFieldUpdateOperationsInput | number | null
    platformFee?: NullableFloatFieldUpdateOperationsInput | number | null
    orderType?: NullableStringFieldUpdateOperationsInput | string | null
    commissionRate?: NullableFloatFieldUpdateOperationsInput | number | null
    priority?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumOrderStatusFieldUpdateOperationsInput | $Enums.OrderStatus
    assignedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    pickedUpAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    deliveredAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    cancelledAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    cancellationReason?: NullableStringFieldUpdateOperationsInput | string | null
    estimatedDuration?: NullableIntFieldUpdateOperationsInput | number | null
    actualDuration?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    barcode?: NullableStringFieldUpdateOperationsInput | string | null
    qrCode?: NullableStringFieldUpdateOperationsInput | string | null
    deliveryOtp?: NullableStringFieldUpdateOperationsInput | string | null
    deliveryQrCode?: NullableStringFieldUpdateOperationsInput | string | null
    otpExpiresAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    verifiedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    verificationMethod?: NullableStringFieldUpdateOperationsInput | string | null
    tickets?: SupportTicketUncheckedUpdateManyWithoutOrderNestedInput
    rating?: AgentRatingUncheckedUpdateOneWithoutOrderNestedInput
    payments?: PaymentUncheckedUpdateManyWithoutOrderNestedInput
    partnerRevenue?: PartnerRevenueUncheckedUpdateOneWithoutOrderNestedInput
    platformRevenue?: PlatformRevenueUncheckedUpdateOneWithoutOrderNestedInput
    walletTransactions?: WalletTransactionUncheckedUpdateManyWithoutOrderNestedInput
  }

  export type AgentDocumentUpsertWithWhereUniqueWithoutAgentInput = {
    where: AgentDocumentWhereUniqueInput
    update: XOR<AgentDocumentUpdateWithoutAgentInput, AgentDocumentUncheckedUpdateWithoutAgentInput>
    create: XOR<AgentDocumentCreateWithoutAgentInput, AgentDocumentUncheckedCreateWithoutAgentInput>
  }

  export type AgentDocumentUpdateWithWhereUniqueWithoutAgentInput = {
    where: AgentDocumentWhereUniqueInput
    data: XOR<AgentDocumentUpdateWithoutAgentInput, AgentDocumentUncheckedUpdateWithoutAgentInput>
  }

  export type AgentDocumentUpdateManyWithWhereWithoutAgentInput = {
    where: AgentDocumentScalarWhereInput
    data: XOR<AgentDocumentUpdateManyMutationInput, AgentDocumentUncheckedUpdateManyWithoutAgentInput>
  }

  export type AgentDocumentScalarWhereInput = {
    AND?: AgentDocumentScalarWhereInput | AgentDocumentScalarWhereInput[]
    OR?: AgentDocumentScalarWhereInput[]
    NOT?: AgentDocumentScalarWhereInput | AgentDocumentScalarWhereInput[]
    id?: StringFilter<"AgentDocument"> | string
    agentId?: StringFilter<"AgentDocument"> | string
    documentType?: StringFilter<"AgentDocument"> | string
    fileName?: StringFilter<"AgentDocument"> | string
    fileUrl?: StringFilter<"AgentDocument"> | string
    verified?: BoolFilter<"AgentDocument"> | boolean
    uploadedAt?: DateTimeFilter<"AgentDocument"> | Date | string
  }

  export type AgentLocationUpsertWithWhereUniqueWithoutAgentInput = {
    where: AgentLocationWhereUniqueInput
    update: XOR<AgentLocationUpdateWithoutAgentInput, AgentLocationUncheckedUpdateWithoutAgentInput>
    create: XOR<AgentLocationCreateWithoutAgentInput, AgentLocationUncheckedCreateWithoutAgentInput>
  }

  export type AgentLocationUpdateWithWhereUniqueWithoutAgentInput = {
    where: AgentLocationWhereUniqueInput
    data: XOR<AgentLocationUpdateWithoutAgentInput, AgentLocationUncheckedUpdateWithoutAgentInput>
  }

  export type AgentLocationUpdateManyWithWhereWithoutAgentInput = {
    where: AgentLocationScalarWhereInput
    data: XOR<AgentLocationUpdateManyMutationInput, AgentLocationUncheckedUpdateManyWithoutAgentInput>
  }

  export type AgentLocationScalarWhereInput = {
    AND?: AgentLocationScalarWhereInput | AgentLocationScalarWhereInput[]
    OR?: AgentLocationScalarWhereInput[]
    NOT?: AgentLocationScalarWhereInput | AgentLocationScalarWhereInput[]
    id?: StringFilter<"AgentLocation"> | string
    agentId?: StringFilter<"AgentLocation"> | string
    latitude?: FloatFilter<"AgentLocation"> | number
    longitude?: FloatFilter<"AgentLocation"> | number
    timestamp?: DateTimeFilter<"AgentLocation"> | Date | string
  }

  export type SupportTicketUpsertWithWhereUniqueWithoutAgentInput = {
    where: SupportTicketWhereUniqueInput
    update: XOR<SupportTicketUpdateWithoutAgentInput, SupportTicketUncheckedUpdateWithoutAgentInput>
    create: XOR<SupportTicketCreateWithoutAgentInput, SupportTicketUncheckedCreateWithoutAgentInput>
  }

  export type SupportTicketUpdateWithWhereUniqueWithoutAgentInput = {
    where: SupportTicketWhereUniqueInput
    data: XOR<SupportTicketUpdateWithoutAgentInput, SupportTicketUncheckedUpdateWithoutAgentInput>
  }

  export type SupportTicketUpdateManyWithWhereWithoutAgentInput = {
    where: SupportTicketScalarWhereInput
    data: XOR<SupportTicketUpdateManyMutationInput, SupportTicketUncheckedUpdateManyWithoutAgentInput>
  }

  export type AgentRatingUpsertWithWhereUniqueWithoutAgentInput = {
    where: AgentRatingWhereUniqueInput
    update: XOR<AgentRatingUpdateWithoutAgentInput, AgentRatingUncheckedUpdateWithoutAgentInput>
    create: XOR<AgentRatingCreateWithoutAgentInput, AgentRatingUncheckedCreateWithoutAgentInput>
  }

  export type AgentRatingUpdateWithWhereUniqueWithoutAgentInput = {
    where: AgentRatingWhereUniqueInput
    data: XOR<AgentRatingUpdateWithoutAgentInput, AgentRatingUncheckedUpdateWithoutAgentInput>
  }

  export type AgentRatingUpdateManyWithWhereWithoutAgentInput = {
    where: AgentRatingScalarWhereInput
    data: XOR<AgentRatingUpdateManyMutationInput, AgentRatingUncheckedUpdateManyWithoutAgentInput>
  }

  export type AgentRatingScalarWhereInput = {
    AND?: AgentRatingScalarWhereInput | AgentRatingScalarWhereInput[]
    OR?: AgentRatingScalarWhereInput[]
    NOT?: AgentRatingScalarWhereInput | AgentRatingScalarWhereInput[]
    id?: StringFilter<"AgentRating"> | string
    orderId?: StringFilter<"AgentRating"> | string
    agentId?: StringFilter<"AgentRating"> | string
    partnerId?: StringFilter<"AgentRating"> | string
    rating?: IntFilter<"AgentRating"> | number
    comment?: StringNullableFilter<"AgentRating"> | string | null
    createdAt?: DateTimeFilter<"AgentRating"> | Date | string
    updatedAt?: DateTimeFilter<"AgentRating"> | Date | string
  }

  export type AgentWalletUpsertWithoutAgentInput = {
    update: XOR<AgentWalletUpdateWithoutAgentInput, AgentWalletUncheckedUpdateWithoutAgentInput>
    create: XOR<AgentWalletCreateWithoutAgentInput, AgentWalletUncheckedCreateWithoutAgentInput>
    where?: AgentWalletWhereInput
  }

  export type AgentWalletUpdateToOneWithWhereWithoutAgentInput = {
    where?: AgentWalletWhereInput
    data: XOR<AgentWalletUpdateWithoutAgentInput, AgentWalletUncheckedUpdateWithoutAgentInput>
  }

  export type AgentWalletUpdateWithoutAgentInput = {
    id?: StringFieldUpdateOperationsInput | string
    balance?: FloatFieldUpdateOperationsInput | number
    totalEarned?: FloatFieldUpdateOperationsInput | number
    totalPaidOut?: FloatFieldUpdateOperationsInput | number
    lastPayoutDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    nextPayoutDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    transactions?: WalletTransactionUpdateManyWithoutAgentWalletNestedInput
    payouts?: WalletPayoutUpdateManyWithoutAgentWalletNestedInput
  }

  export type AgentWalletUncheckedUpdateWithoutAgentInput = {
    id?: StringFieldUpdateOperationsInput | string
    balance?: FloatFieldUpdateOperationsInput | number
    totalEarned?: FloatFieldUpdateOperationsInput | number
    totalPaidOut?: FloatFieldUpdateOperationsInput | number
    lastPayoutDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    nextPayoutDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    transactions?: WalletTransactionUncheckedUpdateManyWithoutAgentWalletNestedInput
    payouts?: WalletPayoutUncheckedUpdateManyWithoutAgentWalletNestedInput
  }

  export type WalletPayoutUpsertWithWhereUniqueWithoutAgentInput = {
    where: WalletPayoutWhereUniqueInput
    update: XOR<WalletPayoutUpdateWithoutAgentInput, WalletPayoutUncheckedUpdateWithoutAgentInput>
    create: XOR<WalletPayoutCreateWithoutAgentInput, WalletPayoutUncheckedCreateWithoutAgentInput>
  }

  export type WalletPayoutUpdateWithWhereUniqueWithoutAgentInput = {
    where: WalletPayoutWhereUniqueInput
    data: XOR<WalletPayoutUpdateWithoutAgentInput, WalletPayoutUncheckedUpdateWithoutAgentInput>
  }

  export type WalletPayoutUpdateManyWithWhereWithoutAgentInput = {
    where: WalletPayoutScalarWhereInput
    data: XOR<WalletPayoutUpdateManyMutationInput, WalletPayoutUncheckedUpdateManyWithoutAgentInput>
  }

  export type WalletPayoutScalarWhereInput = {
    AND?: WalletPayoutScalarWhereInput | WalletPayoutScalarWhereInput[]
    OR?: WalletPayoutScalarWhereInput[]
    NOT?: WalletPayoutScalarWhereInput | WalletPayoutScalarWhereInput[]
    id?: StringFilter<"WalletPayout"> | string
    agentWalletId?: StringFilter<"WalletPayout"> | string
    agentId?: StringFilter<"WalletPayout"> | string
    amount?: FloatFilter<"WalletPayout"> | number
    periodStart?: DateTimeFilter<"WalletPayout"> | Date | string
    periodEnd?: DateTimeFilter<"WalletPayout"> | Date | string
    status?: StringFilter<"WalletPayout"> | string
    paymentMethod?: StringNullableFilter<"WalletPayout"> | string | null
    transactionId?: StringNullableFilter<"WalletPayout"> | string | null
    bankAccount?: StringNullableFilter<"WalletPayout"> | string | null
    upiId?: StringNullableFilter<"WalletPayout"> | string | null
    processedAt?: DateTimeNullableFilter<"WalletPayout"> | Date | string | null
    failedAt?: DateTimeNullableFilter<"WalletPayout"> | Date | string | null
    failureReason?: StringNullableFilter<"WalletPayout"> | string | null
    notes?: StringNullableFilter<"WalletPayout"> | string | null
    createdAt?: DateTimeFilter<"WalletPayout"> | Date | string
    updatedAt?: DateTimeFilter<"WalletPayout"> | Date | string
  }

  export type PaymentUpsertWithWhereUniqueWithoutAgentInput = {
    where: PaymentWhereUniqueInput
    update: XOR<PaymentUpdateWithoutAgentInput, PaymentUncheckedUpdateWithoutAgentInput>
    create: XOR<PaymentCreateWithoutAgentInput, PaymentUncheckedCreateWithoutAgentInput>
  }

  export type PaymentUpdateWithWhereUniqueWithoutAgentInput = {
    where: PaymentWhereUniqueInput
    data: XOR<PaymentUpdateWithoutAgentInput, PaymentUncheckedUpdateWithoutAgentInput>
  }

  export type PaymentUpdateManyWithWhereWithoutAgentInput = {
    where: PaymentScalarWhereInput
    data: XOR<PaymentUpdateManyMutationInput, PaymentUncheckedUpdateManyWithoutAgentInput>
  }

  export type PaymentScalarWhereInput = {
    AND?: PaymentScalarWhereInput | PaymentScalarWhereInput[]
    OR?: PaymentScalarWhereInput[]
    NOT?: PaymentScalarWhereInput | PaymentScalarWhereInput[]
    id?: StringFilter<"Payment"> | string
    agentId?: StringFilter<"Payment"> | string
    orderId?: StringFilter<"Payment"> | string
    amount?: FloatFilter<"Payment"> | number
    paymentType?: StringFilter<"Payment"> | string
    status?: StringFilter<"Payment"> | string
    processedAt?: DateTimeNullableFilter<"Payment"> | Date | string | null
    paymentMethod?: StringNullableFilter<"Payment"> | string | null
    transactionId?: StringNullableFilter<"Payment"> | string | null
    notes?: StringNullableFilter<"Payment"> | string | null
    createdAt?: DateTimeFilter<"Payment"> | Date | string
    updatedAt?: DateTimeFilter<"Payment"> | Date | string
  }

  export type PayrollUpsertWithWhereUniqueWithoutAgentInput = {
    where: PayrollWhereUniqueInput
    update: XOR<PayrollUpdateWithoutAgentInput, PayrollUncheckedUpdateWithoutAgentInput>
    create: XOR<PayrollCreateWithoutAgentInput, PayrollUncheckedCreateWithoutAgentInput>
  }

  export type PayrollUpdateWithWhereUniqueWithoutAgentInput = {
    where: PayrollWhereUniqueInput
    data: XOR<PayrollUpdateWithoutAgentInput, PayrollUncheckedUpdateWithoutAgentInput>
  }

  export type PayrollUpdateManyWithWhereWithoutAgentInput = {
    where: PayrollScalarWhereInput
    data: XOR<PayrollUpdateManyMutationInput, PayrollUncheckedUpdateManyWithoutAgentInput>
  }

  export type PayrollScalarWhereInput = {
    AND?: PayrollScalarWhereInput | PayrollScalarWhereInput[]
    OR?: PayrollScalarWhereInput[]
    NOT?: PayrollScalarWhereInput | PayrollScalarWhereInput[]
    id?: StringFilter<"Payroll"> | string
    agentId?: StringFilter<"Payroll"> | string
    periodStart?: DateTimeFilter<"Payroll"> | Date | string
    periodEnd?: DateTimeFilter<"Payroll"> | Date | string
    periodType?: StringFilter<"Payroll"> | string
    totalEarnings?: FloatFilter<"Payroll"> | number
    totalOrders?: IntFilter<"Payroll"> | number
    basePay?: FloatFilter<"Payroll"> | number
    bonuses?: FloatFilter<"Payroll"> | number
    deductions?: FloatFilter<"Payroll"> | number
    netPay?: FloatFilter<"Payroll"> | number
    status?: StringFilter<"Payroll"> | string
    processedAt?: DateTimeNullableFilter<"Payroll"> | Date | string | null
    paidAt?: DateTimeNullableFilter<"Payroll"> | Date | string | null
    paymentMethod?: StringNullableFilter<"Payroll"> | string | null
    transactionId?: StringNullableFilter<"Payroll"> | string | null
    notes?: StringNullableFilter<"Payroll"> | string | null
    createdAt?: DateTimeFilter<"Payroll"> | Date | string
    updatedAt?: DateTimeFilter<"Payroll"> | Date | string
  }

  export type AgentScheduleUpsertWithWhereUniqueWithoutAgentInput = {
    where: AgentScheduleWhereUniqueInput
    update: XOR<AgentScheduleUpdateWithoutAgentInput, AgentScheduleUncheckedUpdateWithoutAgentInput>
    create: XOR<AgentScheduleCreateWithoutAgentInput, AgentScheduleUncheckedCreateWithoutAgentInput>
  }

  export type AgentScheduleUpdateWithWhereUniqueWithoutAgentInput = {
    where: AgentScheduleWhereUniqueInput
    data: XOR<AgentScheduleUpdateWithoutAgentInput, AgentScheduleUncheckedUpdateWithoutAgentInput>
  }

  export type AgentScheduleUpdateManyWithWhereWithoutAgentInput = {
    where: AgentScheduleScalarWhereInput
    data: XOR<AgentScheduleUpdateManyMutationInput, AgentScheduleUncheckedUpdateManyWithoutAgentInput>
  }

  export type AgentScheduleScalarWhereInput = {
    AND?: AgentScheduleScalarWhereInput | AgentScheduleScalarWhereInput[]
    OR?: AgentScheduleScalarWhereInput[]
    NOT?: AgentScheduleScalarWhereInput | AgentScheduleScalarWhereInput[]
    id?: StringFilter<"AgentSchedule"> | string
    agentId?: StringFilter<"AgentSchedule"> | string
    date?: DateTimeFilter<"AgentSchedule"> | Date | string
    startTime?: StringNullableFilter<"AgentSchedule"> | string | null
    endTime?: StringNullableFilter<"AgentSchedule"> | string | null
    isAvailable?: BoolFilter<"AgentSchedule"> | boolean
    notes?: StringNullableFilter<"AgentSchedule"> | string | null
    createdAt?: DateTimeFilter<"AgentSchedule"> | Date | string
    updatedAt?: DateTimeFilter<"AgentSchedule"> | Date | string
  }

  export type AgentCreateWithoutDocumentsInput = {
    id?: string
    vehicleType: $Enums.VehicleType
    status?: $Enums.AgentStatus
    rating?: number | null
    totalOrders?: number
    completedOrders?: number
    cancelledOrders?: number
    acceptanceRate?: number
    isApproved?: boolean
    isBlocked?: boolean
    blockedReason?: string | null
    city?: string | null
    state?: string | null
    pincode?: string | null
    lastOnlineAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    user: UserCreateNestedOneWithoutAgentInput
    orders?: OrderCreateNestedManyWithoutAgentInput
    currentOrder?: OrderCreateNestedOneWithoutCurrentAgentInput
    locationHistory?: AgentLocationCreateNestedManyWithoutAgentInput
    tickets?: SupportTicketCreateNestedManyWithoutAgentInput
    ratings?: AgentRatingCreateNestedManyWithoutAgentInput
    wallet?: AgentWalletCreateNestedOneWithoutAgentInput
    walletPayouts?: WalletPayoutCreateNestedManyWithoutAgentInput
    payments?: PaymentCreateNestedManyWithoutAgentInput
    payrolls?: PayrollCreateNestedManyWithoutAgentInput
    schedules?: AgentScheduleCreateNestedManyWithoutAgentInput
  }

  export type AgentUncheckedCreateWithoutDocumentsInput = {
    id?: string
    userId: string
    vehicleType: $Enums.VehicleType
    status?: $Enums.AgentStatus
    rating?: number | null
    totalOrders?: number
    completedOrders?: number
    cancelledOrders?: number
    acceptanceRate?: number
    currentOrderId?: string | null
    isApproved?: boolean
    isBlocked?: boolean
    blockedReason?: string | null
    city?: string | null
    state?: string | null
    pincode?: string | null
    lastOnlineAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    orders?: OrderUncheckedCreateNestedManyWithoutAgentInput
    locationHistory?: AgentLocationUncheckedCreateNestedManyWithoutAgentInput
    tickets?: SupportTicketUncheckedCreateNestedManyWithoutAgentInput
    ratings?: AgentRatingUncheckedCreateNestedManyWithoutAgentInput
    wallet?: AgentWalletUncheckedCreateNestedOneWithoutAgentInput
    walletPayouts?: WalletPayoutUncheckedCreateNestedManyWithoutAgentInput
    payments?: PaymentUncheckedCreateNestedManyWithoutAgentInput
    payrolls?: PayrollUncheckedCreateNestedManyWithoutAgentInput
    schedules?: AgentScheduleUncheckedCreateNestedManyWithoutAgentInput
  }

  export type AgentCreateOrConnectWithoutDocumentsInput = {
    where: AgentWhereUniqueInput
    create: XOR<AgentCreateWithoutDocumentsInput, AgentUncheckedCreateWithoutDocumentsInput>
  }

  export type AgentUpsertWithoutDocumentsInput = {
    update: XOR<AgentUpdateWithoutDocumentsInput, AgentUncheckedUpdateWithoutDocumentsInput>
    create: XOR<AgentCreateWithoutDocumentsInput, AgentUncheckedCreateWithoutDocumentsInput>
    where?: AgentWhereInput
  }

  export type AgentUpdateToOneWithWhereWithoutDocumentsInput = {
    where?: AgentWhereInput
    data: XOR<AgentUpdateWithoutDocumentsInput, AgentUncheckedUpdateWithoutDocumentsInput>
  }

  export type AgentUpdateWithoutDocumentsInput = {
    id?: StringFieldUpdateOperationsInput | string
    vehicleType?: EnumVehicleTypeFieldUpdateOperationsInput | $Enums.VehicleType
    status?: EnumAgentStatusFieldUpdateOperationsInput | $Enums.AgentStatus
    rating?: NullableFloatFieldUpdateOperationsInput | number | null
    totalOrders?: IntFieldUpdateOperationsInput | number
    completedOrders?: IntFieldUpdateOperationsInput | number
    cancelledOrders?: IntFieldUpdateOperationsInput | number
    acceptanceRate?: FloatFieldUpdateOperationsInput | number
    isApproved?: BoolFieldUpdateOperationsInput | boolean
    isBlocked?: BoolFieldUpdateOperationsInput | boolean
    blockedReason?: NullableStringFieldUpdateOperationsInput | string | null
    city?: NullableStringFieldUpdateOperationsInput | string | null
    state?: NullableStringFieldUpdateOperationsInput | string | null
    pincode?: NullableStringFieldUpdateOperationsInput | string | null
    lastOnlineAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneRequiredWithoutAgentNestedInput
    orders?: OrderUpdateManyWithoutAgentNestedInput
    currentOrder?: OrderUpdateOneWithoutCurrentAgentNestedInput
    locationHistory?: AgentLocationUpdateManyWithoutAgentNestedInput
    tickets?: SupportTicketUpdateManyWithoutAgentNestedInput
    ratings?: AgentRatingUpdateManyWithoutAgentNestedInput
    wallet?: AgentWalletUpdateOneWithoutAgentNestedInput
    walletPayouts?: WalletPayoutUpdateManyWithoutAgentNestedInput
    payments?: PaymentUpdateManyWithoutAgentNestedInput
    payrolls?: PayrollUpdateManyWithoutAgentNestedInput
    schedules?: AgentScheduleUpdateManyWithoutAgentNestedInput
  }

  export type AgentUncheckedUpdateWithoutDocumentsInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    vehicleType?: EnumVehicleTypeFieldUpdateOperationsInput | $Enums.VehicleType
    status?: EnumAgentStatusFieldUpdateOperationsInput | $Enums.AgentStatus
    rating?: NullableFloatFieldUpdateOperationsInput | number | null
    totalOrders?: IntFieldUpdateOperationsInput | number
    completedOrders?: IntFieldUpdateOperationsInput | number
    cancelledOrders?: IntFieldUpdateOperationsInput | number
    acceptanceRate?: FloatFieldUpdateOperationsInput | number
    currentOrderId?: NullableStringFieldUpdateOperationsInput | string | null
    isApproved?: BoolFieldUpdateOperationsInput | boolean
    isBlocked?: BoolFieldUpdateOperationsInput | boolean
    blockedReason?: NullableStringFieldUpdateOperationsInput | string | null
    city?: NullableStringFieldUpdateOperationsInput | string | null
    state?: NullableStringFieldUpdateOperationsInput | string | null
    pincode?: NullableStringFieldUpdateOperationsInput | string | null
    lastOnlineAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    orders?: OrderUncheckedUpdateManyWithoutAgentNestedInput
    locationHistory?: AgentLocationUncheckedUpdateManyWithoutAgentNestedInput
    tickets?: SupportTicketUncheckedUpdateManyWithoutAgentNestedInput
    ratings?: AgentRatingUncheckedUpdateManyWithoutAgentNestedInput
    wallet?: AgentWalletUncheckedUpdateOneWithoutAgentNestedInput
    walletPayouts?: WalletPayoutUncheckedUpdateManyWithoutAgentNestedInput
    payments?: PaymentUncheckedUpdateManyWithoutAgentNestedInput
    payrolls?: PayrollUncheckedUpdateManyWithoutAgentNestedInput
    schedules?: AgentScheduleUncheckedUpdateManyWithoutAgentNestedInput
  }

  export type AgentCreateWithoutLocationHistoryInput = {
    id?: string
    vehicleType: $Enums.VehicleType
    status?: $Enums.AgentStatus
    rating?: number | null
    totalOrders?: number
    completedOrders?: number
    cancelledOrders?: number
    acceptanceRate?: number
    isApproved?: boolean
    isBlocked?: boolean
    blockedReason?: string | null
    city?: string | null
    state?: string | null
    pincode?: string | null
    lastOnlineAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    user: UserCreateNestedOneWithoutAgentInput
    orders?: OrderCreateNestedManyWithoutAgentInput
    currentOrder?: OrderCreateNestedOneWithoutCurrentAgentInput
    documents?: AgentDocumentCreateNestedManyWithoutAgentInput
    tickets?: SupportTicketCreateNestedManyWithoutAgentInput
    ratings?: AgentRatingCreateNestedManyWithoutAgentInput
    wallet?: AgentWalletCreateNestedOneWithoutAgentInput
    walletPayouts?: WalletPayoutCreateNestedManyWithoutAgentInput
    payments?: PaymentCreateNestedManyWithoutAgentInput
    payrolls?: PayrollCreateNestedManyWithoutAgentInput
    schedules?: AgentScheduleCreateNestedManyWithoutAgentInput
  }

  export type AgentUncheckedCreateWithoutLocationHistoryInput = {
    id?: string
    userId: string
    vehicleType: $Enums.VehicleType
    status?: $Enums.AgentStatus
    rating?: number | null
    totalOrders?: number
    completedOrders?: number
    cancelledOrders?: number
    acceptanceRate?: number
    currentOrderId?: string | null
    isApproved?: boolean
    isBlocked?: boolean
    blockedReason?: string | null
    city?: string | null
    state?: string | null
    pincode?: string | null
    lastOnlineAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    orders?: OrderUncheckedCreateNestedManyWithoutAgentInput
    documents?: AgentDocumentUncheckedCreateNestedManyWithoutAgentInput
    tickets?: SupportTicketUncheckedCreateNestedManyWithoutAgentInput
    ratings?: AgentRatingUncheckedCreateNestedManyWithoutAgentInput
    wallet?: AgentWalletUncheckedCreateNestedOneWithoutAgentInput
    walletPayouts?: WalletPayoutUncheckedCreateNestedManyWithoutAgentInput
    payments?: PaymentUncheckedCreateNestedManyWithoutAgentInput
    payrolls?: PayrollUncheckedCreateNestedManyWithoutAgentInput
    schedules?: AgentScheduleUncheckedCreateNestedManyWithoutAgentInput
  }

  export type AgentCreateOrConnectWithoutLocationHistoryInput = {
    where: AgentWhereUniqueInput
    create: XOR<AgentCreateWithoutLocationHistoryInput, AgentUncheckedCreateWithoutLocationHistoryInput>
  }

  export type AgentUpsertWithoutLocationHistoryInput = {
    update: XOR<AgentUpdateWithoutLocationHistoryInput, AgentUncheckedUpdateWithoutLocationHistoryInput>
    create: XOR<AgentCreateWithoutLocationHistoryInput, AgentUncheckedCreateWithoutLocationHistoryInput>
    where?: AgentWhereInput
  }

  export type AgentUpdateToOneWithWhereWithoutLocationHistoryInput = {
    where?: AgentWhereInput
    data: XOR<AgentUpdateWithoutLocationHistoryInput, AgentUncheckedUpdateWithoutLocationHistoryInput>
  }

  export type AgentUpdateWithoutLocationHistoryInput = {
    id?: StringFieldUpdateOperationsInput | string
    vehicleType?: EnumVehicleTypeFieldUpdateOperationsInput | $Enums.VehicleType
    status?: EnumAgentStatusFieldUpdateOperationsInput | $Enums.AgentStatus
    rating?: NullableFloatFieldUpdateOperationsInput | number | null
    totalOrders?: IntFieldUpdateOperationsInput | number
    completedOrders?: IntFieldUpdateOperationsInput | number
    cancelledOrders?: IntFieldUpdateOperationsInput | number
    acceptanceRate?: FloatFieldUpdateOperationsInput | number
    isApproved?: BoolFieldUpdateOperationsInput | boolean
    isBlocked?: BoolFieldUpdateOperationsInput | boolean
    blockedReason?: NullableStringFieldUpdateOperationsInput | string | null
    city?: NullableStringFieldUpdateOperationsInput | string | null
    state?: NullableStringFieldUpdateOperationsInput | string | null
    pincode?: NullableStringFieldUpdateOperationsInput | string | null
    lastOnlineAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneRequiredWithoutAgentNestedInput
    orders?: OrderUpdateManyWithoutAgentNestedInput
    currentOrder?: OrderUpdateOneWithoutCurrentAgentNestedInput
    documents?: AgentDocumentUpdateManyWithoutAgentNestedInput
    tickets?: SupportTicketUpdateManyWithoutAgentNestedInput
    ratings?: AgentRatingUpdateManyWithoutAgentNestedInput
    wallet?: AgentWalletUpdateOneWithoutAgentNestedInput
    walletPayouts?: WalletPayoutUpdateManyWithoutAgentNestedInput
    payments?: PaymentUpdateManyWithoutAgentNestedInput
    payrolls?: PayrollUpdateManyWithoutAgentNestedInput
    schedules?: AgentScheduleUpdateManyWithoutAgentNestedInput
  }

  export type AgentUncheckedUpdateWithoutLocationHistoryInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    vehicleType?: EnumVehicleTypeFieldUpdateOperationsInput | $Enums.VehicleType
    status?: EnumAgentStatusFieldUpdateOperationsInput | $Enums.AgentStatus
    rating?: NullableFloatFieldUpdateOperationsInput | number | null
    totalOrders?: IntFieldUpdateOperationsInput | number
    completedOrders?: IntFieldUpdateOperationsInput | number
    cancelledOrders?: IntFieldUpdateOperationsInput | number
    acceptanceRate?: FloatFieldUpdateOperationsInput | number
    currentOrderId?: NullableStringFieldUpdateOperationsInput | string | null
    isApproved?: BoolFieldUpdateOperationsInput | boolean
    isBlocked?: BoolFieldUpdateOperationsInput | boolean
    blockedReason?: NullableStringFieldUpdateOperationsInput | string | null
    city?: NullableStringFieldUpdateOperationsInput | string | null
    state?: NullableStringFieldUpdateOperationsInput | string | null
    pincode?: NullableStringFieldUpdateOperationsInput | string | null
    lastOnlineAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    orders?: OrderUncheckedUpdateManyWithoutAgentNestedInput
    documents?: AgentDocumentUncheckedUpdateManyWithoutAgentNestedInput
    tickets?: SupportTicketUncheckedUpdateManyWithoutAgentNestedInput
    ratings?: AgentRatingUncheckedUpdateManyWithoutAgentNestedInput
    wallet?: AgentWalletUncheckedUpdateOneWithoutAgentNestedInput
    walletPayouts?: WalletPayoutUncheckedUpdateManyWithoutAgentNestedInput
    payments?: PaymentUncheckedUpdateManyWithoutAgentNestedInput
    payrolls?: PayrollUncheckedUpdateManyWithoutAgentNestedInput
    schedules?: AgentScheduleUncheckedUpdateManyWithoutAgentNestedInput
  }

  export type UserCreateWithoutPartnerInput = {
    id?: string
    name: string
    email: string
    phone: string
    passwordHash: string
    role: $Enums.UserRole
    emailVerified?: Date | string | null
    phoneVerified?: boolean
    profilePicture?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    agent?: AgentCreateNestedOneWithoutUserInput
    notifications?: NotificationTokenCreateNestedManyWithoutUserInput
    userNotifications?: NotificationCreateNestedManyWithoutUserInput
    tickets?: SupportTicketCreateNestedManyWithoutUserInput
  }

  export type UserUncheckedCreateWithoutPartnerInput = {
    id?: string
    name: string
    email: string
    phone: string
    passwordHash: string
    role: $Enums.UserRole
    emailVerified?: Date | string | null
    phoneVerified?: boolean
    profilePicture?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    agent?: AgentUncheckedCreateNestedOneWithoutUserInput
    notifications?: NotificationTokenUncheckedCreateNestedManyWithoutUserInput
    userNotifications?: NotificationUncheckedCreateNestedManyWithoutUserInput
    tickets?: SupportTicketUncheckedCreateNestedManyWithoutUserInput
  }

  export type UserCreateOrConnectWithoutPartnerInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutPartnerInput, UserUncheckedCreateWithoutPartnerInput>
  }

  export type OrderCreateWithoutPartnerInput = {
    id?: string
    pickupLat: number
    pickupLng: number
    dropLat: number
    dropLng: number
    payoutAmount: number
    orderAmount?: number | null
    platformFee?: number | null
    orderType?: string | null
    commissionRate?: number | null
    priority?: string | null
    status?: $Enums.OrderStatus
    assignedAt?: Date | string | null
    pickedUpAt?: Date | string | null
    deliveredAt?: Date | string | null
    cancelledAt?: Date | string | null
    cancellationReason?: string | null
    estimatedDuration?: number | null
    actualDuration?: number | null
    createdAt?: Date | string
    updatedAt?: Date | string
    barcode?: string | null
    qrCode?: string | null
    deliveryOtp?: string | null
    deliveryQrCode?: string | null
    otpExpiresAt?: Date | string | null
    verifiedAt?: Date | string | null
    verificationMethod?: string | null
    agent?: AgentCreateNestedOneWithoutOrdersInput
    currentAgent?: AgentCreateNestedOneWithoutCurrentOrderInput
    tickets?: SupportTicketCreateNestedManyWithoutOrderInput
    rating?: AgentRatingCreateNestedOneWithoutOrderInput
    payments?: PaymentCreateNestedManyWithoutOrderInput
    partnerRevenue?: PartnerRevenueCreateNestedOneWithoutOrderInput
    platformRevenue?: PlatformRevenueCreateNestedOneWithoutOrderInput
    walletTransactions?: WalletTransactionCreateNestedManyWithoutOrderInput
  }

  export type OrderUncheckedCreateWithoutPartnerInput = {
    id?: string
    agentId?: string | null
    pickupLat: number
    pickupLng: number
    dropLat: number
    dropLng: number
    payoutAmount: number
    orderAmount?: number | null
    platformFee?: number | null
    orderType?: string | null
    commissionRate?: number | null
    priority?: string | null
    status?: $Enums.OrderStatus
    assignedAt?: Date | string | null
    pickedUpAt?: Date | string | null
    deliveredAt?: Date | string | null
    cancelledAt?: Date | string | null
    cancellationReason?: string | null
    estimatedDuration?: number | null
    actualDuration?: number | null
    createdAt?: Date | string
    updatedAt?: Date | string
    barcode?: string | null
    qrCode?: string | null
    deliveryOtp?: string | null
    deliveryQrCode?: string | null
    otpExpiresAt?: Date | string | null
    verifiedAt?: Date | string | null
    verificationMethod?: string | null
    currentAgent?: AgentUncheckedCreateNestedOneWithoutCurrentOrderInput
    tickets?: SupportTicketUncheckedCreateNestedManyWithoutOrderInput
    rating?: AgentRatingUncheckedCreateNestedOneWithoutOrderInput
    payments?: PaymentUncheckedCreateNestedManyWithoutOrderInput
    partnerRevenue?: PartnerRevenueUncheckedCreateNestedOneWithoutOrderInput
    platformRevenue?: PlatformRevenueUncheckedCreateNestedOneWithoutOrderInput
    walletTransactions?: WalletTransactionUncheckedCreateNestedManyWithoutOrderInput
  }

  export type OrderCreateOrConnectWithoutPartnerInput = {
    where: OrderWhereUniqueInput
    create: XOR<OrderCreateWithoutPartnerInput, OrderUncheckedCreateWithoutPartnerInput>
  }

  export type OrderCreateManyPartnerInputEnvelope = {
    data: OrderCreateManyPartnerInput | OrderCreateManyPartnerInput[]
    skipDuplicates?: boolean
  }

  export type SupportTicketCreateWithoutPartnerInput = {
    id?: string
    issueType: string
    description: string
    status?: $Enums.TicketStatus
    resolvedAt?: Date | string | null
    adminNotes?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    order?: OrderCreateNestedOneWithoutTicketsInput
    agent?: AgentCreateNestedOneWithoutTicketsInput
    user: UserCreateNestedOneWithoutTicketsInput
  }

  export type SupportTicketUncheckedCreateWithoutPartnerInput = {
    id?: string
    orderId?: string | null
    agentId?: string | null
    userId: string
    issueType: string
    description: string
    status?: $Enums.TicketStatus
    resolvedAt?: Date | string | null
    adminNotes?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type SupportTicketCreateOrConnectWithoutPartnerInput = {
    where: SupportTicketWhereUniqueInput
    create: XOR<SupportTicketCreateWithoutPartnerInput, SupportTicketUncheckedCreateWithoutPartnerInput>
  }

  export type SupportTicketCreateManyPartnerInputEnvelope = {
    data: SupportTicketCreateManyPartnerInput | SupportTicketCreateManyPartnerInput[]
    skipDuplicates?: boolean
  }

  export type PartnerDailyStatsCreateWithoutPartnerInput = {
    id?: string
    date: Date | string
    totalOrders?: number
    completedOrders?: number
    cancelledOrders?: number
    avgAssignmentTime?: number | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type PartnerDailyStatsUncheckedCreateWithoutPartnerInput = {
    id?: string
    date: Date | string
    totalOrders?: number
    completedOrders?: number
    cancelledOrders?: number
    avgAssignmentTime?: number | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type PartnerDailyStatsCreateOrConnectWithoutPartnerInput = {
    where: PartnerDailyStatsWhereUniqueInput
    create: XOR<PartnerDailyStatsCreateWithoutPartnerInput, PartnerDailyStatsUncheckedCreateWithoutPartnerInput>
  }

  export type PartnerDailyStatsCreateManyPartnerInputEnvelope = {
    data: PartnerDailyStatsCreateManyPartnerInput | PartnerDailyStatsCreateManyPartnerInput[]
    skipDuplicates?: boolean
  }

  export type AgentRatingCreateWithoutPartnerInput = {
    id?: string
    rating: number
    comment?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    order: OrderCreateNestedOneWithoutRatingInput
    agent: AgentCreateNestedOneWithoutRatingsInput
  }

  export type AgentRatingUncheckedCreateWithoutPartnerInput = {
    id?: string
    orderId: string
    agentId: string
    rating: number
    comment?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type AgentRatingCreateOrConnectWithoutPartnerInput = {
    where: AgentRatingWhereUniqueInput
    create: XOR<AgentRatingCreateWithoutPartnerInput, AgentRatingUncheckedCreateWithoutPartnerInput>
  }

  export type AgentRatingCreateManyPartnerInputEnvelope = {
    data: AgentRatingCreateManyPartnerInput | AgentRatingCreateManyPartnerInput[]
    skipDuplicates?: boolean
  }

  export type PartnerRevenueCreateWithoutPartnerInput = {
    id?: string
    orderAmount: number
    deliveryFee: number
    platformFee: number
    netRevenue: number
    status?: string
    processedAt?: Date | string | null
    periodStart: Date | string
    periodEnd: Date | string
    periodType: string
    createdAt?: Date | string
    updatedAt?: Date | string
    order: OrderCreateNestedOneWithoutPartnerRevenueInput
  }

  export type PartnerRevenueUncheckedCreateWithoutPartnerInput = {
    id?: string
    orderId: string
    orderAmount: number
    deliveryFee: number
    platformFee: number
    netRevenue: number
    status?: string
    processedAt?: Date | string | null
    periodStart: Date | string
    periodEnd: Date | string
    periodType: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type PartnerRevenueCreateOrConnectWithoutPartnerInput = {
    where: PartnerRevenueWhereUniqueInput
    create: XOR<PartnerRevenueCreateWithoutPartnerInput, PartnerRevenueUncheckedCreateWithoutPartnerInput>
  }

  export type PartnerRevenueCreateManyPartnerInputEnvelope = {
    data: PartnerRevenueCreateManyPartnerInput | PartnerRevenueCreateManyPartnerInput[]
    skipDuplicates?: boolean
  }

  export type PlatformRevenueCreateWithoutPartnerInput = {
    id?: string
    agentId?: string | null
    orderAmount: number
    platformFee: number
    agentPayout: number
    netRevenue: number
    revenueType: string
    status?: string
    processedAt?: Date | string | null
    periodStart: Date | string
    periodEnd: Date | string
    periodType: string
    createdAt?: Date | string
    updatedAt?: Date | string
    order: OrderCreateNestedOneWithoutPlatformRevenueInput
  }

  export type PlatformRevenueUncheckedCreateWithoutPartnerInput = {
    id?: string
    orderId: string
    agentId?: string | null
    orderAmount: number
    platformFee: number
    agentPayout: number
    netRevenue: number
    revenueType: string
    status?: string
    processedAt?: Date | string | null
    periodStart: Date | string
    periodEnd: Date | string
    periodType: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type PlatformRevenueCreateOrConnectWithoutPartnerInput = {
    where: PlatformRevenueWhereUniqueInput
    create: XOR<PlatformRevenueCreateWithoutPartnerInput, PlatformRevenueUncheckedCreateWithoutPartnerInput>
  }

  export type PlatformRevenueCreateManyPartnerInputEnvelope = {
    data: PlatformRevenueCreateManyPartnerInput | PlatformRevenueCreateManyPartnerInput[]
    skipDuplicates?: boolean
  }

  export type UserUpsertWithoutPartnerInput = {
    update: XOR<UserUpdateWithoutPartnerInput, UserUncheckedUpdateWithoutPartnerInput>
    create: XOR<UserCreateWithoutPartnerInput, UserUncheckedCreateWithoutPartnerInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutPartnerInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutPartnerInput, UserUncheckedUpdateWithoutPartnerInput>
  }

  export type UserUpdateWithoutPartnerInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    phone?: StringFieldUpdateOperationsInput | string
    passwordHash?: StringFieldUpdateOperationsInput | string
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    emailVerified?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    phoneVerified?: BoolFieldUpdateOperationsInput | boolean
    profilePicture?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    agent?: AgentUpdateOneWithoutUserNestedInput
    notifications?: NotificationTokenUpdateManyWithoutUserNestedInput
    userNotifications?: NotificationUpdateManyWithoutUserNestedInput
    tickets?: SupportTicketUpdateManyWithoutUserNestedInput
  }

  export type UserUncheckedUpdateWithoutPartnerInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    phone?: StringFieldUpdateOperationsInput | string
    passwordHash?: StringFieldUpdateOperationsInput | string
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    emailVerified?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    phoneVerified?: BoolFieldUpdateOperationsInput | boolean
    profilePicture?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    agent?: AgentUncheckedUpdateOneWithoutUserNestedInput
    notifications?: NotificationTokenUncheckedUpdateManyWithoutUserNestedInput
    userNotifications?: NotificationUncheckedUpdateManyWithoutUserNestedInput
    tickets?: SupportTicketUncheckedUpdateManyWithoutUserNestedInput
  }

  export type OrderUpsertWithWhereUniqueWithoutPartnerInput = {
    where: OrderWhereUniqueInput
    update: XOR<OrderUpdateWithoutPartnerInput, OrderUncheckedUpdateWithoutPartnerInput>
    create: XOR<OrderCreateWithoutPartnerInput, OrderUncheckedCreateWithoutPartnerInput>
  }

  export type OrderUpdateWithWhereUniqueWithoutPartnerInput = {
    where: OrderWhereUniqueInput
    data: XOR<OrderUpdateWithoutPartnerInput, OrderUncheckedUpdateWithoutPartnerInput>
  }

  export type OrderUpdateManyWithWhereWithoutPartnerInput = {
    where: OrderScalarWhereInput
    data: XOR<OrderUpdateManyMutationInput, OrderUncheckedUpdateManyWithoutPartnerInput>
  }

  export type SupportTicketUpsertWithWhereUniqueWithoutPartnerInput = {
    where: SupportTicketWhereUniqueInput
    update: XOR<SupportTicketUpdateWithoutPartnerInput, SupportTicketUncheckedUpdateWithoutPartnerInput>
    create: XOR<SupportTicketCreateWithoutPartnerInput, SupportTicketUncheckedCreateWithoutPartnerInput>
  }

  export type SupportTicketUpdateWithWhereUniqueWithoutPartnerInput = {
    where: SupportTicketWhereUniqueInput
    data: XOR<SupportTicketUpdateWithoutPartnerInput, SupportTicketUncheckedUpdateWithoutPartnerInput>
  }

  export type SupportTicketUpdateManyWithWhereWithoutPartnerInput = {
    where: SupportTicketScalarWhereInput
    data: XOR<SupportTicketUpdateManyMutationInput, SupportTicketUncheckedUpdateManyWithoutPartnerInput>
  }

  export type PartnerDailyStatsUpsertWithWhereUniqueWithoutPartnerInput = {
    where: PartnerDailyStatsWhereUniqueInput
    update: XOR<PartnerDailyStatsUpdateWithoutPartnerInput, PartnerDailyStatsUncheckedUpdateWithoutPartnerInput>
    create: XOR<PartnerDailyStatsCreateWithoutPartnerInput, PartnerDailyStatsUncheckedCreateWithoutPartnerInput>
  }

  export type PartnerDailyStatsUpdateWithWhereUniqueWithoutPartnerInput = {
    where: PartnerDailyStatsWhereUniqueInput
    data: XOR<PartnerDailyStatsUpdateWithoutPartnerInput, PartnerDailyStatsUncheckedUpdateWithoutPartnerInput>
  }

  export type PartnerDailyStatsUpdateManyWithWhereWithoutPartnerInput = {
    where: PartnerDailyStatsScalarWhereInput
    data: XOR<PartnerDailyStatsUpdateManyMutationInput, PartnerDailyStatsUncheckedUpdateManyWithoutPartnerInput>
  }

  export type PartnerDailyStatsScalarWhereInput = {
    AND?: PartnerDailyStatsScalarWhereInput | PartnerDailyStatsScalarWhereInput[]
    OR?: PartnerDailyStatsScalarWhereInput[]
    NOT?: PartnerDailyStatsScalarWhereInput | PartnerDailyStatsScalarWhereInput[]
    id?: StringFilter<"PartnerDailyStats"> | string
    partnerId?: StringFilter<"PartnerDailyStats"> | string
    date?: DateTimeFilter<"PartnerDailyStats"> | Date | string
    totalOrders?: IntFilter<"PartnerDailyStats"> | number
    completedOrders?: IntFilter<"PartnerDailyStats"> | number
    cancelledOrders?: IntFilter<"PartnerDailyStats"> | number
    avgAssignmentTime?: FloatNullableFilter<"PartnerDailyStats"> | number | null
    createdAt?: DateTimeFilter<"PartnerDailyStats"> | Date | string
    updatedAt?: DateTimeFilter<"PartnerDailyStats"> | Date | string
  }

  export type AgentRatingUpsertWithWhereUniqueWithoutPartnerInput = {
    where: AgentRatingWhereUniqueInput
    update: XOR<AgentRatingUpdateWithoutPartnerInput, AgentRatingUncheckedUpdateWithoutPartnerInput>
    create: XOR<AgentRatingCreateWithoutPartnerInput, AgentRatingUncheckedCreateWithoutPartnerInput>
  }

  export type AgentRatingUpdateWithWhereUniqueWithoutPartnerInput = {
    where: AgentRatingWhereUniqueInput
    data: XOR<AgentRatingUpdateWithoutPartnerInput, AgentRatingUncheckedUpdateWithoutPartnerInput>
  }

  export type AgentRatingUpdateManyWithWhereWithoutPartnerInput = {
    where: AgentRatingScalarWhereInput
    data: XOR<AgentRatingUpdateManyMutationInput, AgentRatingUncheckedUpdateManyWithoutPartnerInput>
  }

  export type PartnerRevenueUpsertWithWhereUniqueWithoutPartnerInput = {
    where: PartnerRevenueWhereUniqueInput
    update: XOR<PartnerRevenueUpdateWithoutPartnerInput, PartnerRevenueUncheckedUpdateWithoutPartnerInput>
    create: XOR<PartnerRevenueCreateWithoutPartnerInput, PartnerRevenueUncheckedCreateWithoutPartnerInput>
  }

  export type PartnerRevenueUpdateWithWhereUniqueWithoutPartnerInput = {
    where: PartnerRevenueWhereUniqueInput
    data: XOR<PartnerRevenueUpdateWithoutPartnerInput, PartnerRevenueUncheckedUpdateWithoutPartnerInput>
  }

  export type PartnerRevenueUpdateManyWithWhereWithoutPartnerInput = {
    where: PartnerRevenueScalarWhereInput
    data: XOR<PartnerRevenueUpdateManyMutationInput, PartnerRevenueUncheckedUpdateManyWithoutPartnerInput>
  }

  export type PartnerRevenueScalarWhereInput = {
    AND?: PartnerRevenueScalarWhereInput | PartnerRevenueScalarWhereInput[]
    OR?: PartnerRevenueScalarWhereInput[]
    NOT?: PartnerRevenueScalarWhereInput | PartnerRevenueScalarWhereInput[]
    id?: StringFilter<"PartnerRevenue"> | string
    partnerId?: StringFilter<"PartnerRevenue"> | string
    orderId?: StringFilter<"PartnerRevenue"> | string
    orderAmount?: FloatFilter<"PartnerRevenue"> | number
    deliveryFee?: FloatFilter<"PartnerRevenue"> | number
    platformFee?: FloatFilter<"PartnerRevenue"> | number
    netRevenue?: FloatFilter<"PartnerRevenue"> | number
    status?: StringFilter<"PartnerRevenue"> | string
    processedAt?: DateTimeNullableFilter<"PartnerRevenue"> | Date | string | null
    periodStart?: DateTimeFilter<"PartnerRevenue"> | Date | string
    periodEnd?: DateTimeFilter<"PartnerRevenue"> | Date | string
    periodType?: StringFilter<"PartnerRevenue"> | string
    createdAt?: DateTimeFilter<"PartnerRevenue"> | Date | string
    updatedAt?: DateTimeFilter<"PartnerRevenue"> | Date | string
  }

  export type PlatformRevenueUpsertWithWhereUniqueWithoutPartnerInput = {
    where: PlatformRevenueWhereUniqueInput
    update: XOR<PlatformRevenueUpdateWithoutPartnerInput, PlatformRevenueUncheckedUpdateWithoutPartnerInput>
    create: XOR<PlatformRevenueCreateWithoutPartnerInput, PlatformRevenueUncheckedCreateWithoutPartnerInput>
  }

  export type PlatformRevenueUpdateWithWhereUniqueWithoutPartnerInput = {
    where: PlatformRevenueWhereUniqueInput
    data: XOR<PlatformRevenueUpdateWithoutPartnerInput, PlatformRevenueUncheckedUpdateWithoutPartnerInput>
  }

  export type PlatformRevenueUpdateManyWithWhereWithoutPartnerInput = {
    where: PlatformRevenueScalarWhereInput
    data: XOR<PlatformRevenueUpdateManyMutationInput, PlatformRevenueUncheckedUpdateManyWithoutPartnerInput>
  }

  export type PlatformRevenueScalarWhereInput = {
    AND?: PlatformRevenueScalarWhereInput | PlatformRevenueScalarWhereInput[]
    OR?: PlatformRevenueScalarWhereInput[]
    NOT?: PlatformRevenueScalarWhereInput | PlatformRevenueScalarWhereInput[]
    id?: StringFilter<"PlatformRevenue"> | string
    orderId?: StringFilter<"PlatformRevenue"> | string
    partnerId?: StringFilter<"PlatformRevenue"> | string
    agentId?: StringNullableFilter<"PlatformRevenue"> | string | null
    orderAmount?: FloatFilter<"PlatformRevenue"> | number
    platformFee?: FloatFilter<"PlatformRevenue"> | number
    agentPayout?: FloatFilter<"PlatformRevenue"> | number
    netRevenue?: FloatFilter<"PlatformRevenue"> | number
    revenueType?: StringFilter<"PlatformRevenue"> | string
    status?: StringFilter<"PlatformRevenue"> | string
    processedAt?: DateTimeNullableFilter<"PlatformRevenue"> | Date | string | null
    periodStart?: DateTimeFilter<"PlatformRevenue"> | Date | string
    periodEnd?: DateTimeFilter<"PlatformRevenue"> | Date | string
    periodType?: StringFilter<"PlatformRevenue"> | string
    createdAt?: DateTimeFilter<"PlatformRevenue"> | Date | string
    updatedAt?: DateTimeFilter<"PlatformRevenue"> | Date | string
  }

  export type PartnerCreateWithoutOrdersInput = {
    id?: string
    companyName: string
    apiKey: string
    webhookUrl?: string | null
    isActive?: boolean
    city?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    user: UserCreateNestedOneWithoutPartnerInput
    tickets?: SupportTicketCreateNestedManyWithoutPartnerInput
    dailyStats?: PartnerDailyStatsCreateNestedManyWithoutPartnerInput
    agentRatings?: AgentRatingCreateNestedManyWithoutPartnerInput
    partnerRevenues?: PartnerRevenueCreateNestedManyWithoutPartnerInput
    platformRevenues?: PlatformRevenueCreateNestedManyWithoutPartnerInput
  }

  export type PartnerUncheckedCreateWithoutOrdersInput = {
    id?: string
    userId: string
    companyName: string
    apiKey: string
    webhookUrl?: string | null
    isActive?: boolean
    city?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    tickets?: SupportTicketUncheckedCreateNestedManyWithoutPartnerInput
    dailyStats?: PartnerDailyStatsUncheckedCreateNestedManyWithoutPartnerInput
    agentRatings?: AgentRatingUncheckedCreateNestedManyWithoutPartnerInput
    partnerRevenues?: PartnerRevenueUncheckedCreateNestedManyWithoutPartnerInput
    platformRevenues?: PlatformRevenueUncheckedCreateNestedManyWithoutPartnerInput
  }

  export type PartnerCreateOrConnectWithoutOrdersInput = {
    where: PartnerWhereUniqueInput
    create: XOR<PartnerCreateWithoutOrdersInput, PartnerUncheckedCreateWithoutOrdersInput>
  }

  export type AgentCreateWithoutOrdersInput = {
    id?: string
    vehicleType: $Enums.VehicleType
    status?: $Enums.AgentStatus
    rating?: number | null
    totalOrders?: number
    completedOrders?: number
    cancelledOrders?: number
    acceptanceRate?: number
    isApproved?: boolean
    isBlocked?: boolean
    blockedReason?: string | null
    city?: string | null
    state?: string | null
    pincode?: string | null
    lastOnlineAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    user: UserCreateNestedOneWithoutAgentInput
    currentOrder?: OrderCreateNestedOneWithoutCurrentAgentInput
    documents?: AgentDocumentCreateNestedManyWithoutAgentInput
    locationHistory?: AgentLocationCreateNestedManyWithoutAgentInput
    tickets?: SupportTicketCreateNestedManyWithoutAgentInput
    ratings?: AgentRatingCreateNestedManyWithoutAgentInput
    wallet?: AgentWalletCreateNestedOneWithoutAgentInput
    walletPayouts?: WalletPayoutCreateNestedManyWithoutAgentInput
    payments?: PaymentCreateNestedManyWithoutAgentInput
    payrolls?: PayrollCreateNestedManyWithoutAgentInput
    schedules?: AgentScheduleCreateNestedManyWithoutAgentInput
  }

  export type AgentUncheckedCreateWithoutOrdersInput = {
    id?: string
    userId: string
    vehicleType: $Enums.VehicleType
    status?: $Enums.AgentStatus
    rating?: number | null
    totalOrders?: number
    completedOrders?: number
    cancelledOrders?: number
    acceptanceRate?: number
    currentOrderId?: string | null
    isApproved?: boolean
    isBlocked?: boolean
    blockedReason?: string | null
    city?: string | null
    state?: string | null
    pincode?: string | null
    lastOnlineAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    documents?: AgentDocumentUncheckedCreateNestedManyWithoutAgentInput
    locationHistory?: AgentLocationUncheckedCreateNestedManyWithoutAgentInput
    tickets?: SupportTicketUncheckedCreateNestedManyWithoutAgentInput
    ratings?: AgentRatingUncheckedCreateNestedManyWithoutAgentInput
    wallet?: AgentWalletUncheckedCreateNestedOneWithoutAgentInput
    walletPayouts?: WalletPayoutUncheckedCreateNestedManyWithoutAgentInput
    payments?: PaymentUncheckedCreateNestedManyWithoutAgentInput
    payrolls?: PayrollUncheckedCreateNestedManyWithoutAgentInput
    schedules?: AgentScheduleUncheckedCreateNestedManyWithoutAgentInput
  }

  export type AgentCreateOrConnectWithoutOrdersInput = {
    where: AgentWhereUniqueInput
    create: XOR<AgentCreateWithoutOrdersInput, AgentUncheckedCreateWithoutOrdersInput>
  }

  export type AgentCreateWithoutCurrentOrderInput = {
    id?: string
    vehicleType: $Enums.VehicleType
    status?: $Enums.AgentStatus
    rating?: number | null
    totalOrders?: number
    completedOrders?: number
    cancelledOrders?: number
    acceptanceRate?: number
    isApproved?: boolean
    isBlocked?: boolean
    blockedReason?: string | null
    city?: string | null
    state?: string | null
    pincode?: string | null
    lastOnlineAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    user: UserCreateNestedOneWithoutAgentInput
    orders?: OrderCreateNestedManyWithoutAgentInput
    documents?: AgentDocumentCreateNestedManyWithoutAgentInput
    locationHistory?: AgentLocationCreateNestedManyWithoutAgentInput
    tickets?: SupportTicketCreateNestedManyWithoutAgentInput
    ratings?: AgentRatingCreateNestedManyWithoutAgentInput
    wallet?: AgentWalletCreateNestedOneWithoutAgentInput
    walletPayouts?: WalletPayoutCreateNestedManyWithoutAgentInput
    payments?: PaymentCreateNestedManyWithoutAgentInput
    payrolls?: PayrollCreateNestedManyWithoutAgentInput
    schedules?: AgentScheduleCreateNestedManyWithoutAgentInput
  }

  export type AgentUncheckedCreateWithoutCurrentOrderInput = {
    id?: string
    userId: string
    vehicleType: $Enums.VehicleType
    status?: $Enums.AgentStatus
    rating?: number | null
    totalOrders?: number
    completedOrders?: number
    cancelledOrders?: number
    acceptanceRate?: number
    isApproved?: boolean
    isBlocked?: boolean
    blockedReason?: string | null
    city?: string | null
    state?: string | null
    pincode?: string | null
    lastOnlineAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    orders?: OrderUncheckedCreateNestedManyWithoutAgentInput
    documents?: AgentDocumentUncheckedCreateNestedManyWithoutAgentInput
    locationHistory?: AgentLocationUncheckedCreateNestedManyWithoutAgentInput
    tickets?: SupportTicketUncheckedCreateNestedManyWithoutAgentInput
    ratings?: AgentRatingUncheckedCreateNestedManyWithoutAgentInput
    wallet?: AgentWalletUncheckedCreateNestedOneWithoutAgentInput
    walletPayouts?: WalletPayoutUncheckedCreateNestedManyWithoutAgentInput
    payments?: PaymentUncheckedCreateNestedManyWithoutAgentInput
    payrolls?: PayrollUncheckedCreateNestedManyWithoutAgentInput
    schedules?: AgentScheduleUncheckedCreateNestedManyWithoutAgentInput
  }

  export type AgentCreateOrConnectWithoutCurrentOrderInput = {
    where: AgentWhereUniqueInput
    create: XOR<AgentCreateWithoutCurrentOrderInput, AgentUncheckedCreateWithoutCurrentOrderInput>
  }

  export type SupportTicketCreateWithoutOrderInput = {
    id?: string
    issueType: string
    description: string
    status?: $Enums.TicketStatus
    resolvedAt?: Date | string | null
    adminNotes?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    agent?: AgentCreateNestedOneWithoutTicketsInput
    partner?: PartnerCreateNestedOneWithoutTicketsInput
    user: UserCreateNestedOneWithoutTicketsInput
  }

  export type SupportTicketUncheckedCreateWithoutOrderInput = {
    id?: string
    agentId?: string | null
    partnerId?: string | null
    userId: string
    issueType: string
    description: string
    status?: $Enums.TicketStatus
    resolvedAt?: Date | string | null
    adminNotes?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type SupportTicketCreateOrConnectWithoutOrderInput = {
    where: SupportTicketWhereUniqueInput
    create: XOR<SupportTicketCreateWithoutOrderInput, SupportTicketUncheckedCreateWithoutOrderInput>
  }

  export type SupportTicketCreateManyOrderInputEnvelope = {
    data: SupportTicketCreateManyOrderInput | SupportTicketCreateManyOrderInput[]
    skipDuplicates?: boolean
  }

  export type AgentRatingCreateWithoutOrderInput = {
    id?: string
    rating: number
    comment?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    agent: AgentCreateNestedOneWithoutRatingsInput
    partner: PartnerCreateNestedOneWithoutAgentRatingsInput
  }

  export type AgentRatingUncheckedCreateWithoutOrderInput = {
    id?: string
    agentId: string
    partnerId: string
    rating: number
    comment?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type AgentRatingCreateOrConnectWithoutOrderInput = {
    where: AgentRatingWhereUniqueInput
    create: XOR<AgentRatingCreateWithoutOrderInput, AgentRatingUncheckedCreateWithoutOrderInput>
  }

  export type PaymentCreateWithoutOrderInput = {
    id?: string
    amount: number
    paymentType: string
    status?: string
    processedAt?: Date | string | null
    paymentMethod?: string | null
    transactionId?: string | null
    notes?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    agent: AgentCreateNestedOneWithoutPaymentsInput
  }

  export type PaymentUncheckedCreateWithoutOrderInput = {
    id?: string
    agentId: string
    amount: number
    paymentType: string
    status?: string
    processedAt?: Date | string | null
    paymentMethod?: string | null
    transactionId?: string | null
    notes?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type PaymentCreateOrConnectWithoutOrderInput = {
    where: PaymentWhereUniqueInput
    create: XOR<PaymentCreateWithoutOrderInput, PaymentUncheckedCreateWithoutOrderInput>
  }

  export type PaymentCreateManyOrderInputEnvelope = {
    data: PaymentCreateManyOrderInput | PaymentCreateManyOrderInput[]
    skipDuplicates?: boolean
  }

  export type PartnerRevenueCreateWithoutOrderInput = {
    id?: string
    orderAmount: number
    deliveryFee: number
    platformFee: number
    netRevenue: number
    status?: string
    processedAt?: Date | string | null
    periodStart: Date | string
    periodEnd: Date | string
    periodType: string
    createdAt?: Date | string
    updatedAt?: Date | string
    partner: PartnerCreateNestedOneWithoutPartnerRevenuesInput
  }

  export type PartnerRevenueUncheckedCreateWithoutOrderInput = {
    id?: string
    partnerId: string
    orderAmount: number
    deliveryFee: number
    platformFee: number
    netRevenue: number
    status?: string
    processedAt?: Date | string | null
    periodStart: Date | string
    periodEnd: Date | string
    periodType: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type PartnerRevenueCreateOrConnectWithoutOrderInput = {
    where: PartnerRevenueWhereUniqueInput
    create: XOR<PartnerRevenueCreateWithoutOrderInput, PartnerRevenueUncheckedCreateWithoutOrderInput>
  }

  export type PlatformRevenueCreateWithoutOrderInput = {
    id?: string
    agentId?: string | null
    orderAmount: number
    platformFee: number
    agentPayout: number
    netRevenue: number
    revenueType: string
    status?: string
    processedAt?: Date | string | null
    periodStart: Date | string
    periodEnd: Date | string
    periodType: string
    createdAt?: Date | string
    updatedAt?: Date | string
    partner: PartnerCreateNestedOneWithoutPlatformRevenuesInput
  }

  export type PlatformRevenueUncheckedCreateWithoutOrderInput = {
    id?: string
    partnerId: string
    agentId?: string | null
    orderAmount: number
    platformFee: number
    agentPayout: number
    netRevenue: number
    revenueType: string
    status?: string
    processedAt?: Date | string | null
    periodStart: Date | string
    periodEnd: Date | string
    periodType: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type PlatformRevenueCreateOrConnectWithoutOrderInput = {
    where: PlatformRevenueWhereUniqueInput
    create: XOR<PlatformRevenueCreateWithoutOrderInput, PlatformRevenueUncheckedCreateWithoutOrderInput>
  }

  export type WalletTransactionCreateWithoutOrderInput = {
    id?: string
    walletType: string
    amount: number
    type: string
    description?: string | null
    balanceBefore: number
    balanceAfter: number
    status?: string
    createdAt?: Date | string
    adminWallet?: AdminWalletCreateNestedOneWithoutTransactionsInput
    agentWallet?: AgentWalletCreateNestedOneWithoutTransactionsInput
  }

  export type WalletTransactionUncheckedCreateWithoutOrderInput = {
    id?: string
    walletType: string
    adminWalletId?: string | null
    agentWalletId?: string | null
    amount: number
    type: string
    description?: string | null
    balanceBefore: number
    balanceAfter: number
    status?: string
    createdAt?: Date | string
  }

  export type WalletTransactionCreateOrConnectWithoutOrderInput = {
    where: WalletTransactionWhereUniqueInput
    create: XOR<WalletTransactionCreateWithoutOrderInput, WalletTransactionUncheckedCreateWithoutOrderInput>
  }

  export type WalletTransactionCreateManyOrderInputEnvelope = {
    data: WalletTransactionCreateManyOrderInput | WalletTransactionCreateManyOrderInput[]
    skipDuplicates?: boolean
  }

  export type PartnerUpsertWithoutOrdersInput = {
    update: XOR<PartnerUpdateWithoutOrdersInput, PartnerUncheckedUpdateWithoutOrdersInput>
    create: XOR<PartnerCreateWithoutOrdersInput, PartnerUncheckedCreateWithoutOrdersInput>
    where?: PartnerWhereInput
  }

  export type PartnerUpdateToOneWithWhereWithoutOrdersInput = {
    where?: PartnerWhereInput
    data: XOR<PartnerUpdateWithoutOrdersInput, PartnerUncheckedUpdateWithoutOrdersInput>
  }

  export type PartnerUpdateWithoutOrdersInput = {
    id?: StringFieldUpdateOperationsInput | string
    companyName?: StringFieldUpdateOperationsInput | string
    apiKey?: StringFieldUpdateOperationsInput | string
    webhookUrl?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    city?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneRequiredWithoutPartnerNestedInput
    tickets?: SupportTicketUpdateManyWithoutPartnerNestedInput
    dailyStats?: PartnerDailyStatsUpdateManyWithoutPartnerNestedInput
    agentRatings?: AgentRatingUpdateManyWithoutPartnerNestedInput
    partnerRevenues?: PartnerRevenueUpdateManyWithoutPartnerNestedInput
    platformRevenues?: PlatformRevenueUpdateManyWithoutPartnerNestedInput
  }

  export type PartnerUncheckedUpdateWithoutOrdersInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    companyName?: StringFieldUpdateOperationsInput | string
    apiKey?: StringFieldUpdateOperationsInput | string
    webhookUrl?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    city?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    tickets?: SupportTicketUncheckedUpdateManyWithoutPartnerNestedInput
    dailyStats?: PartnerDailyStatsUncheckedUpdateManyWithoutPartnerNestedInput
    agentRatings?: AgentRatingUncheckedUpdateManyWithoutPartnerNestedInput
    partnerRevenues?: PartnerRevenueUncheckedUpdateManyWithoutPartnerNestedInput
    platformRevenues?: PlatformRevenueUncheckedUpdateManyWithoutPartnerNestedInput
  }

  export type AgentUpsertWithoutOrdersInput = {
    update: XOR<AgentUpdateWithoutOrdersInput, AgentUncheckedUpdateWithoutOrdersInput>
    create: XOR<AgentCreateWithoutOrdersInput, AgentUncheckedCreateWithoutOrdersInput>
    where?: AgentWhereInput
  }

  export type AgentUpdateToOneWithWhereWithoutOrdersInput = {
    where?: AgentWhereInput
    data: XOR<AgentUpdateWithoutOrdersInput, AgentUncheckedUpdateWithoutOrdersInput>
  }

  export type AgentUpdateWithoutOrdersInput = {
    id?: StringFieldUpdateOperationsInput | string
    vehicleType?: EnumVehicleTypeFieldUpdateOperationsInput | $Enums.VehicleType
    status?: EnumAgentStatusFieldUpdateOperationsInput | $Enums.AgentStatus
    rating?: NullableFloatFieldUpdateOperationsInput | number | null
    totalOrders?: IntFieldUpdateOperationsInput | number
    completedOrders?: IntFieldUpdateOperationsInput | number
    cancelledOrders?: IntFieldUpdateOperationsInput | number
    acceptanceRate?: FloatFieldUpdateOperationsInput | number
    isApproved?: BoolFieldUpdateOperationsInput | boolean
    isBlocked?: BoolFieldUpdateOperationsInput | boolean
    blockedReason?: NullableStringFieldUpdateOperationsInput | string | null
    city?: NullableStringFieldUpdateOperationsInput | string | null
    state?: NullableStringFieldUpdateOperationsInput | string | null
    pincode?: NullableStringFieldUpdateOperationsInput | string | null
    lastOnlineAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneRequiredWithoutAgentNestedInput
    currentOrder?: OrderUpdateOneWithoutCurrentAgentNestedInput
    documents?: AgentDocumentUpdateManyWithoutAgentNestedInput
    locationHistory?: AgentLocationUpdateManyWithoutAgentNestedInput
    tickets?: SupportTicketUpdateManyWithoutAgentNestedInput
    ratings?: AgentRatingUpdateManyWithoutAgentNestedInput
    wallet?: AgentWalletUpdateOneWithoutAgentNestedInput
    walletPayouts?: WalletPayoutUpdateManyWithoutAgentNestedInput
    payments?: PaymentUpdateManyWithoutAgentNestedInput
    payrolls?: PayrollUpdateManyWithoutAgentNestedInput
    schedules?: AgentScheduleUpdateManyWithoutAgentNestedInput
  }

  export type AgentUncheckedUpdateWithoutOrdersInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    vehicleType?: EnumVehicleTypeFieldUpdateOperationsInput | $Enums.VehicleType
    status?: EnumAgentStatusFieldUpdateOperationsInput | $Enums.AgentStatus
    rating?: NullableFloatFieldUpdateOperationsInput | number | null
    totalOrders?: IntFieldUpdateOperationsInput | number
    completedOrders?: IntFieldUpdateOperationsInput | number
    cancelledOrders?: IntFieldUpdateOperationsInput | number
    acceptanceRate?: FloatFieldUpdateOperationsInput | number
    currentOrderId?: NullableStringFieldUpdateOperationsInput | string | null
    isApproved?: BoolFieldUpdateOperationsInput | boolean
    isBlocked?: BoolFieldUpdateOperationsInput | boolean
    blockedReason?: NullableStringFieldUpdateOperationsInput | string | null
    city?: NullableStringFieldUpdateOperationsInput | string | null
    state?: NullableStringFieldUpdateOperationsInput | string | null
    pincode?: NullableStringFieldUpdateOperationsInput | string | null
    lastOnlineAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    documents?: AgentDocumentUncheckedUpdateManyWithoutAgentNestedInput
    locationHistory?: AgentLocationUncheckedUpdateManyWithoutAgentNestedInput
    tickets?: SupportTicketUncheckedUpdateManyWithoutAgentNestedInput
    ratings?: AgentRatingUncheckedUpdateManyWithoutAgentNestedInput
    wallet?: AgentWalletUncheckedUpdateOneWithoutAgentNestedInput
    walletPayouts?: WalletPayoutUncheckedUpdateManyWithoutAgentNestedInput
    payments?: PaymentUncheckedUpdateManyWithoutAgentNestedInput
    payrolls?: PayrollUncheckedUpdateManyWithoutAgentNestedInput
    schedules?: AgentScheduleUncheckedUpdateManyWithoutAgentNestedInput
  }

  export type AgentUpsertWithoutCurrentOrderInput = {
    update: XOR<AgentUpdateWithoutCurrentOrderInput, AgentUncheckedUpdateWithoutCurrentOrderInput>
    create: XOR<AgentCreateWithoutCurrentOrderInput, AgentUncheckedCreateWithoutCurrentOrderInput>
    where?: AgentWhereInput
  }

  export type AgentUpdateToOneWithWhereWithoutCurrentOrderInput = {
    where?: AgentWhereInput
    data: XOR<AgentUpdateWithoutCurrentOrderInput, AgentUncheckedUpdateWithoutCurrentOrderInput>
  }

  export type AgentUpdateWithoutCurrentOrderInput = {
    id?: StringFieldUpdateOperationsInput | string
    vehicleType?: EnumVehicleTypeFieldUpdateOperationsInput | $Enums.VehicleType
    status?: EnumAgentStatusFieldUpdateOperationsInput | $Enums.AgentStatus
    rating?: NullableFloatFieldUpdateOperationsInput | number | null
    totalOrders?: IntFieldUpdateOperationsInput | number
    completedOrders?: IntFieldUpdateOperationsInput | number
    cancelledOrders?: IntFieldUpdateOperationsInput | number
    acceptanceRate?: FloatFieldUpdateOperationsInput | number
    isApproved?: BoolFieldUpdateOperationsInput | boolean
    isBlocked?: BoolFieldUpdateOperationsInput | boolean
    blockedReason?: NullableStringFieldUpdateOperationsInput | string | null
    city?: NullableStringFieldUpdateOperationsInput | string | null
    state?: NullableStringFieldUpdateOperationsInput | string | null
    pincode?: NullableStringFieldUpdateOperationsInput | string | null
    lastOnlineAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneRequiredWithoutAgentNestedInput
    orders?: OrderUpdateManyWithoutAgentNestedInput
    documents?: AgentDocumentUpdateManyWithoutAgentNestedInput
    locationHistory?: AgentLocationUpdateManyWithoutAgentNestedInput
    tickets?: SupportTicketUpdateManyWithoutAgentNestedInput
    ratings?: AgentRatingUpdateManyWithoutAgentNestedInput
    wallet?: AgentWalletUpdateOneWithoutAgentNestedInput
    walletPayouts?: WalletPayoutUpdateManyWithoutAgentNestedInput
    payments?: PaymentUpdateManyWithoutAgentNestedInput
    payrolls?: PayrollUpdateManyWithoutAgentNestedInput
    schedules?: AgentScheduleUpdateManyWithoutAgentNestedInput
  }

  export type AgentUncheckedUpdateWithoutCurrentOrderInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    vehicleType?: EnumVehicleTypeFieldUpdateOperationsInput | $Enums.VehicleType
    status?: EnumAgentStatusFieldUpdateOperationsInput | $Enums.AgentStatus
    rating?: NullableFloatFieldUpdateOperationsInput | number | null
    totalOrders?: IntFieldUpdateOperationsInput | number
    completedOrders?: IntFieldUpdateOperationsInput | number
    cancelledOrders?: IntFieldUpdateOperationsInput | number
    acceptanceRate?: FloatFieldUpdateOperationsInput | number
    isApproved?: BoolFieldUpdateOperationsInput | boolean
    isBlocked?: BoolFieldUpdateOperationsInput | boolean
    blockedReason?: NullableStringFieldUpdateOperationsInput | string | null
    city?: NullableStringFieldUpdateOperationsInput | string | null
    state?: NullableStringFieldUpdateOperationsInput | string | null
    pincode?: NullableStringFieldUpdateOperationsInput | string | null
    lastOnlineAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    orders?: OrderUncheckedUpdateManyWithoutAgentNestedInput
    documents?: AgentDocumentUncheckedUpdateManyWithoutAgentNestedInput
    locationHistory?: AgentLocationUncheckedUpdateManyWithoutAgentNestedInput
    tickets?: SupportTicketUncheckedUpdateManyWithoutAgentNestedInput
    ratings?: AgentRatingUncheckedUpdateManyWithoutAgentNestedInput
    wallet?: AgentWalletUncheckedUpdateOneWithoutAgentNestedInput
    walletPayouts?: WalletPayoutUncheckedUpdateManyWithoutAgentNestedInput
    payments?: PaymentUncheckedUpdateManyWithoutAgentNestedInput
    payrolls?: PayrollUncheckedUpdateManyWithoutAgentNestedInput
    schedules?: AgentScheduleUncheckedUpdateManyWithoutAgentNestedInput
  }

  export type SupportTicketUpsertWithWhereUniqueWithoutOrderInput = {
    where: SupportTicketWhereUniqueInput
    update: XOR<SupportTicketUpdateWithoutOrderInput, SupportTicketUncheckedUpdateWithoutOrderInput>
    create: XOR<SupportTicketCreateWithoutOrderInput, SupportTicketUncheckedCreateWithoutOrderInput>
  }

  export type SupportTicketUpdateWithWhereUniqueWithoutOrderInput = {
    where: SupportTicketWhereUniqueInput
    data: XOR<SupportTicketUpdateWithoutOrderInput, SupportTicketUncheckedUpdateWithoutOrderInput>
  }

  export type SupportTicketUpdateManyWithWhereWithoutOrderInput = {
    where: SupportTicketScalarWhereInput
    data: XOR<SupportTicketUpdateManyMutationInput, SupportTicketUncheckedUpdateManyWithoutOrderInput>
  }

  export type AgentRatingUpsertWithoutOrderInput = {
    update: XOR<AgentRatingUpdateWithoutOrderInput, AgentRatingUncheckedUpdateWithoutOrderInput>
    create: XOR<AgentRatingCreateWithoutOrderInput, AgentRatingUncheckedCreateWithoutOrderInput>
    where?: AgentRatingWhereInput
  }

  export type AgentRatingUpdateToOneWithWhereWithoutOrderInput = {
    where?: AgentRatingWhereInput
    data: XOR<AgentRatingUpdateWithoutOrderInput, AgentRatingUncheckedUpdateWithoutOrderInput>
  }

  export type AgentRatingUpdateWithoutOrderInput = {
    id?: StringFieldUpdateOperationsInput | string
    rating?: IntFieldUpdateOperationsInput | number
    comment?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    agent?: AgentUpdateOneRequiredWithoutRatingsNestedInput
    partner?: PartnerUpdateOneRequiredWithoutAgentRatingsNestedInput
  }

  export type AgentRatingUncheckedUpdateWithoutOrderInput = {
    id?: StringFieldUpdateOperationsInput | string
    agentId?: StringFieldUpdateOperationsInput | string
    partnerId?: StringFieldUpdateOperationsInput | string
    rating?: IntFieldUpdateOperationsInput | number
    comment?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PaymentUpsertWithWhereUniqueWithoutOrderInput = {
    where: PaymentWhereUniqueInput
    update: XOR<PaymentUpdateWithoutOrderInput, PaymentUncheckedUpdateWithoutOrderInput>
    create: XOR<PaymentCreateWithoutOrderInput, PaymentUncheckedCreateWithoutOrderInput>
  }

  export type PaymentUpdateWithWhereUniqueWithoutOrderInput = {
    where: PaymentWhereUniqueInput
    data: XOR<PaymentUpdateWithoutOrderInput, PaymentUncheckedUpdateWithoutOrderInput>
  }

  export type PaymentUpdateManyWithWhereWithoutOrderInput = {
    where: PaymentScalarWhereInput
    data: XOR<PaymentUpdateManyMutationInput, PaymentUncheckedUpdateManyWithoutOrderInput>
  }

  export type PartnerRevenueUpsertWithoutOrderInput = {
    update: XOR<PartnerRevenueUpdateWithoutOrderInput, PartnerRevenueUncheckedUpdateWithoutOrderInput>
    create: XOR<PartnerRevenueCreateWithoutOrderInput, PartnerRevenueUncheckedCreateWithoutOrderInput>
    where?: PartnerRevenueWhereInput
  }

  export type PartnerRevenueUpdateToOneWithWhereWithoutOrderInput = {
    where?: PartnerRevenueWhereInput
    data: XOR<PartnerRevenueUpdateWithoutOrderInput, PartnerRevenueUncheckedUpdateWithoutOrderInput>
  }

  export type PartnerRevenueUpdateWithoutOrderInput = {
    id?: StringFieldUpdateOperationsInput | string
    orderAmount?: FloatFieldUpdateOperationsInput | number
    deliveryFee?: FloatFieldUpdateOperationsInput | number
    platformFee?: FloatFieldUpdateOperationsInput | number
    netRevenue?: FloatFieldUpdateOperationsInput | number
    status?: StringFieldUpdateOperationsInput | string
    processedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    periodStart?: DateTimeFieldUpdateOperationsInput | Date | string
    periodEnd?: DateTimeFieldUpdateOperationsInput | Date | string
    periodType?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    partner?: PartnerUpdateOneRequiredWithoutPartnerRevenuesNestedInput
  }

  export type PartnerRevenueUncheckedUpdateWithoutOrderInput = {
    id?: StringFieldUpdateOperationsInput | string
    partnerId?: StringFieldUpdateOperationsInput | string
    orderAmount?: FloatFieldUpdateOperationsInput | number
    deliveryFee?: FloatFieldUpdateOperationsInput | number
    platformFee?: FloatFieldUpdateOperationsInput | number
    netRevenue?: FloatFieldUpdateOperationsInput | number
    status?: StringFieldUpdateOperationsInput | string
    processedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    periodStart?: DateTimeFieldUpdateOperationsInput | Date | string
    periodEnd?: DateTimeFieldUpdateOperationsInput | Date | string
    periodType?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PlatformRevenueUpsertWithoutOrderInput = {
    update: XOR<PlatformRevenueUpdateWithoutOrderInput, PlatformRevenueUncheckedUpdateWithoutOrderInput>
    create: XOR<PlatformRevenueCreateWithoutOrderInput, PlatformRevenueUncheckedCreateWithoutOrderInput>
    where?: PlatformRevenueWhereInput
  }

  export type PlatformRevenueUpdateToOneWithWhereWithoutOrderInput = {
    where?: PlatformRevenueWhereInput
    data: XOR<PlatformRevenueUpdateWithoutOrderInput, PlatformRevenueUncheckedUpdateWithoutOrderInput>
  }

  export type PlatformRevenueUpdateWithoutOrderInput = {
    id?: StringFieldUpdateOperationsInput | string
    agentId?: NullableStringFieldUpdateOperationsInput | string | null
    orderAmount?: FloatFieldUpdateOperationsInput | number
    platformFee?: FloatFieldUpdateOperationsInput | number
    agentPayout?: FloatFieldUpdateOperationsInput | number
    netRevenue?: FloatFieldUpdateOperationsInput | number
    revenueType?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    processedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    periodStart?: DateTimeFieldUpdateOperationsInput | Date | string
    periodEnd?: DateTimeFieldUpdateOperationsInput | Date | string
    periodType?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    partner?: PartnerUpdateOneRequiredWithoutPlatformRevenuesNestedInput
  }

  export type PlatformRevenueUncheckedUpdateWithoutOrderInput = {
    id?: StringFieldUpdateOperationsInput | string
    partnerId?: StringFieldUpdateOperationsInput | string
    agentId?: NullableStringFieldUpdateOperationsInput | string | null
    orderAmount?: FloatFieldUpdateOperationsInput | number
    platformFee?: FloatFieldUpdateOperationsInput | number
    agentPayout?: FloatFieldUpdateOperationsInput | number
    netRevenue?: FloatFieldUpdateOperationsInput | number
    revenueType?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    processedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    periodStart?: DateTimeFieldUpdateOperationsInput | Date | string
    periodEnd?: DateTimeFieldUpdateOperationsInput | Date | string
    periodType?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type WalletTransactionUpsertWithWhereUniqueWithoutOrderInput = {
    where: WalletTransactionWhereUniqueInput
    update: XOR<WalletTransactionUpdateWithoutOrderInput, WalletTransactionUncheckedUpdateWithoutOrderInput>
    create: XOR<WalletTransactionCreateWithoutOrderInput, WalletTransactionUncheckedCreateWithoutOrderInput>
  }

  export type WalletTransactionUpdateWithWhereUniqueWithoutOrderInput = {
    where: WalletTransactionWhereUniqueInput
    data: XOR<WalletTransactionUpdateWithoutOrderInput, WalletTransactionUncheckedUpdateWithoutOrderInput>
  }

  export type WalletTransactionUpdateManyWithWhereWithoutOrderInput = {
    where: WalletTransactionScalarWhereInput
    data: XOR<WalletTransactionUpdateManyMutationInput, WalletTransactionUncheckedUpdateManyWithoutOrderInput>
  }

  export type WalletTransactionScalarWhereInput = {
    AND?: WalletTransactionScalarWhereInput | WalletTransactionScalarWhereInput[]
    OR?: WalletTransactionScalarWhereInput[]
    NOT?: WalletTransactionScalarWhereInput | WalletTransactionScalarWhereInput[]
    id?: StringFilter<"WalletTransaction"> | string
    walletType?: StringFilter<"WalletTransaction"> | string
    adminWalletId?: StringNullableFilter<"WalletTransaction"> | string | null
    agentWalletId?: StringNullableFilter<"WalletTransaction"> | string | null
    orderId?: StringNullableFilter<"WalletTransaction"> | string | null
    amount?: FloatFilter<"WalletTransaction"> | number
    type?: StringFilter<"WalletTransaction"> | string
    description?: StringNullableFilter<"WalletTransaction"> | string | null
    balanceBefore?: FloatFilter<"WalletTransaction"> | number
    balanceAfter?: FloatFilter<"WalletTransaction"> | number
    status?: StringFilter<"WalletTransaction"> | string
    createdAt?: DateTimeFilter<"WalletTransaction"> | Date | string
  }

  export type UserCreateWithoutNotificationsInput = {
    id?: string
    name: string
    email: string
    phone: string
    passwordHash: string
    role: $Enums.UserRole
    emailVerified?: Date | string | null
    phoneVerified?: boolean
    profilePicture?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    agent?: AgentCreateNestedOneWithoutUserInput
    partner?: PartnerCreateNestedOneWithoutUserInput
    userNotifications?: NotificationCreateNestedManyWithoutUserInput
    tickets?: SupportTicketCreateNestedManyWithoutUserInput
  }

  export type UserUncheckedCreateWithoutNotificationsInput = {
    id?: string
    name: string
    email: string
    phone: string
    passwordHash: string
    role: $Enums.UserRole
    emailVerified?: Date | string | null
    phoneVerified?: boolean
    profilePicture?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    agent?: AgentUncheckedCreateNestedOneWithoutUserInput
    partner?: PartnerUncheckedCreateNestedOneWithoutUserInput
    userNotifications?: NotificationUncheckedCreateNestedManyWithoutUserInput
    tickets?: SupportTicketUncheckedCreateNestedManyWithoutUserInput
  }

  export type UserCreateOrConnectWithoutNotificationsInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutNotificationsInput, UserUncheckedCreateWithoutNotificationsInput>
  }

  export type UserUpsertWithoutNotificationsInput = {
    update: XOR<UserUpdateWithoutNotificationsInput, UserUncheckedUpdateWithoutNotificationsInput>
    create: XOR<UserCreateWithoutNotificationsInput, UserUncheckedCreateWithoutNotificationsInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutNotificationsInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutNotificationsInput, UserUncheckedUpdateWithoutNotificationsInput>
  }

  export type UserUpdateWithoutNotificationsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    phone?: StringFieldUpdateOperationsInput | string
    passwordHash?: StringFieldUpdateOperationsInput | string
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    emailVerified?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    phoneVerified?: BoolFieldUpdateOperationsInput | boolean
    profilePicture?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    agent?: AgentUpdateOneWithoutUserNestedInput
    partner?: PartnerUpdateOneWithoutUserNestedInput
    userNotifications?: NotificationUpdateManyWithoutUserNestedInput
    tickets?: SupportTicketUpdateManyWithoutUserNestedInput
  }

  export type UserUncheckedUpdateWithoutNotificationsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    phone?: StringFieldUpdateOperationsInput | string
    passwordHash?: StringFieldUpdateOperationsInput | string
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    emailVerified?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    phoneVerified?: BoolFieldUpdateOperationsInput | boolean
    profilePicture?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    agent?: AgentUncheckedUpdateOneWithoutUserNestedInput
    partner?: PartnerUncheckedUpdateOneWithoutUserNestedInput
    userNotifications?: NotificationUncheckedUpdateManyWithoutUserNestedInput
    tickets?: SupportTicketUncheckedUpdateManyWithoutUserNestedInput
  }

  export type OrderCreateWithoutTicketsInput = {
    id?: string
    pickupLat: number
    pickupLng: number
    dropLat: number
    dropLng: number
    payoutAmount: number
    orderAmount?: number | null
    platformFee?: number | null
    orderType?: string | null
    commissionRate?: number | null
    priority?: string | null
    status?: $Enums.OrderStatus
    assignedAt?: Date | string | null
    pickedUpAt?: Date | string | null
    deliveredAt?: Date | string | null
    cancelledAt?: Date | string | null
    cancellationReason?: string | null
    estimatedDuration?: number | null
    actualDuration?: number | null
    createdAt?: Date | string
    updatedAt?: Date | string
    barcode?: string | null
    qrCode?: string | null
    deliveryOtp?: string | null
    deliveryQrCode?: string | null
    otpExpiresAt?: Date | string | null
    verifiedAt?: Date | string | null
    verificationMethod?: string | null
    partner: PartnerCreateNestedOneWithoutOrdersInput
    agent?: AgentCreateNestedOneWithoutOrdersInput
    currentAgent?: AgentCreateNestedOneWithoutCurrentOrderInput
    rating?: AgentRatingCreateNestedOneWithoutOrderInput
    payments?: PaymentCreateNestedManyWithoutOrderInput
    partnerRevenue?: PartnerRevenueCreateNestedOneWithoutOrderInput
    platformRevenue?: PlatformRevenueCreateNestedOneWithoutOrderInput
    walletTransactions?: WalletTransactionCreateNestedManyWithoutOrderInput
  }

  export type OrderUncheckedCreateWithoutTicketsInput = {
    id?: string
    partnerId: string
    agentId?: string | null
    pickupLat: number
    pickupLng: number
    dropLat: number
    dropLng: number
    payoutAmount: number
    orderAmount?: number | null
    platformFee?: number | null
    orderType?: string | null
    commissionRate?: number | null
    priority?: string | null
    status?: $Enums.OrderStatus
    assignedAt?: Date | string | null
    pickedUpAt?: Date | string | null
    deliveredAt?: Date | string | null
    cancelledAt?: Date | string | null
    cancellationReason?: string | null
    estimatedDuration?: number | null
    actualDuration?: number | null
    createdAt?: Date | string
    updatedAt?: Date | string
    barcode?: string | null
    qrCode?: string | null
    deliveryOtp?: string | null
    deliveryQrCode?: string | null
    otpExpiresAt?: Date | string | null
    verifiedAt?: Date | string | null
    verificationMethod?: string | null
    currentAgent?: AgentUncheckedCreateNestedOneWithoutCurrentOrderInput
    rating?: AgentRatingUncheckedCreateNestedOneWithoutOrderInput
    payments?: PaymentUncheckedCreateNestedManyWithoutOrderInput
    partnerRevenue?: PartnerRevenueUncheckedCreateNestedOneWithoutOrderInput
    platformRevenue?: PlatformRevenueUncheckedCreateNestedOneWithoutOrderInput
    walletTransactions?: WalletTransactionUncheckedCreateNestedManyWithoutOrderInput
  }

  export type OrderCreateOrConnectWithoutTicketsInput = {
    where: OrderWhereUniqueInput
    create: XOR<OrderCreateWithoutTicketsInput, OrderUncheckedCreateWithoutTicketsInput>
  }

  export type AgentCreateWithoutTicketsInput = {
    id?: string
    vehicleType: $Enums.VehicleType
    status?: $Enums.AgentStatus
    rating?: number | null
    totalOrders?: number
    completedOrders?: number
    cancelledOrders?: number
    acceptanceRate?: number
    isApproved?: boolean
    isBlocked?: boolean
    blockedReason?: string | null
    city?: string | null
    state?: string | null
    pincode?: string | null
    lastOnlineAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    user: UserCreateNestedOneWithoutAgentInput
    orders?: OrderCreateNestedManyWithoutAgentInput
    currentOrder?: OrderCreateNestedOneWithoutCurrentAgentInput
    documents?: AgentDocumentCreateNestedManyWithoutAgentInput
    locationHistory?: AgentLocationCreateNestedManyWithoutAgentInput
    ratings?: AgentRatingCreateNestedManyWithoutAgentInput
    wallet?: AgentWalletCreateNestedOneWithoutAgentInput
    walletPayouts?: WalletPayoutCreateNestedManyWithoutAgentInput
    payments?: PaymentCreateNestedManyWithoutAgentInput
    payrolls?: PayrollCreateNestedManyWithoutAgentInput
    schedules?: AgentScheduleCreateNestedManyWithoutAgentInput
  }

  export type AgentUncheckedCreateWithoutTicketsInput = {
    id?: string
    userId: string
    vehicleType: $Enums.VehicleType
    status?: $Enums.AgentStatus
    rating?: number | null
    totalOrders?: number
    completedOrders?: number
    cancelledOrders?: number
    acceptanceRate?: number
    currentOrderId?: string | null
    isApproved?: boolean
    isBlocked?: boolean
    blockedReason?: string | null
    city?: string | null
    state?: string | null
    pincode?: string | null
    lastOnlineAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    orders?: OrderUncheckedCreateNestedManyWithoutAgentInput
    documents?: AgentDocumentUncheckedCreateNestedManyWithoutAgentInput
    locationHistory?: AgentLocationUncheckedCreateNestedManyWithoutAgentInput
    ratings?: AgentRatingUncheckedCreateNestedManyWithoutAgentInput
    wallet?: AgentWalletUncheckedCreateNestedOneWithoutAgentInput
    walletPayouts?: WalletPayoutUncheckedCreateNestedManyWithoutAgentInput
    payments?: PaymentUncheckedCreateNestedManyWithoutAgentInput
    payrolls?: PayrollUncheckedCreateNestedManyWithoutAgentInput
    schedules?: AgentScheduleUncheckedCreateNestedManyWithoutAgentInput
  }

  export type AgentCreateOrConnectWithoutTicketsInput = {
    where: AgentWhereUniqueInput
    create: XOR<AgentCreateWithoutTicketsInput, AgentUncheckedCreateWithoutTicketsInput>
  }

  export type PartnerCreateWithoutTicketsInput = {
    id?: string
    companyName: string
    apiKey: string
    webhookUrl?: string | null
    isActive?: boolean
    city?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    user: UserCreateNestedOneWithoutPartnerInput
    orders?: OrderCreateNestedManyWithoutPartnerInput
    dailyStats?: PartnerDailyStatsCreateNestedManyWithoutPartnerInput
    agentRatings?: AgentRatingCreateNestedManyWithoutPartnerInput
    partnerRevenues?: PartnerRevenueCreateNestedManyWithoutPartnerInput
    platformRevenues?: PlatformRevenueCreateNestedManyWithoutPartnerInput
  }

  export type PartnerUncheckedCreateWithoutTicketsInput = {
    id?: string
    userId: string
    companyName: string
    apiKey: string
    webhookUrl?: string | null
    isActive?: boolean
    city?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    orders?: OrderUncheckedCreateNestedManyWithoutPartnerInput
    dailyStats?: PartnerDailyStatsUncheckedCreateNestedManyWithoutPartnerInput
    agentRatings?: AgentRatingUncheckedCreateNestedManyWithoutPartnerInput
    partnerRevenues?: PartnerRevenueUncheckedCreateNestedManyWithoutPartnerInput
    platformRevenues?: PlatformRevenueUncheckedCreateNestedManyWithoutPartnerInput
  }

  export type PartnerCreateOrConnectWithoutTicketsInput = {
    where: PartnerWhereUniqueInput
    create: XOR<PartnerCreateWithoutTicketsInput, PartnerUncheckedCreateWithoutTicketsInput>
  }

  export type UserCreateWithoutTicketsInput = {
    id?: string
    name: string
    email: string
    phone: string
    passwordHash: string
    role: $Enums.UserRole
    emailVerified?: Date | string | null
    phoneVerified?: boolean
    profilePicture?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    agent?: AgentCreateNestedOneWithoutUserInput
    partner?: PartnerCreateNestedOneWithoutUserInput
    notifications?: NotificationTokenCreateNestedManyWithoutUserInput
    userNotifications?: NotificationCreateNestedManyWithoutUserInput
  }

  export type UserUncheckedCreateWithoutTicketsInput = {
    id?: string
    name: string
    email: string
    phone: string
    passwordHash: string
    role: $Enums.UserRole
    emailVerified?: Date | string | null
    phoneVerified?: boolean
    profilePicture?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    agent?: AgentUncheckedCreateNestedOneWithoutUserInput
    partner?: PartnerUncheckedCreateNestedOneWithoutUserInput
    notifications?: NotificationTokenUncheckedCreateNestedManyWithoutUserInput
    userNotifications?: NotificationUncheckedCreateNestedManyWithoutUserInput
  }

  export type UserCreateOrConnectWithoutTicketsInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutTicketsInput, UserUncheckedCreateWithoutTicketsInput>
  }

  export type OrderUpsertWithoutTicketsInput = {
    update: XOR<OrderUpdateWithoutTicketsInput, OrderUncheckedUpdateWithoutTicketsInput>
    create: XOR<OrderCreateWithoutTicketsInput, OrderUncheckedCreateWithoutTicketsInput>
    where?: OrderWhereInput
  }

  export type OrderUpdateToOneWithWhereWithoutTicketsInput = {
    where?: OrderWhereInput
    data: XOR<OrderUpdateWithoutTicketsInput, OrderUncheckedUpdateWithoutTicketsInput>
  }

  export type OrderUpdateWithoutTicketsInput = {
    id?: StringFieldUpdateOperationsInput | string
    pickupLat?: FloatFieldUpdateOperationsInput | number
    pickupLng?: FloatFieldUpdateOperationsInput | number
    dropLat?: FloatFieldUpdateOperationsInput | number
    dropLng?: FloatFieldUpdateOperationsInput | number
    payoutAmount?: FloatFieldUpdateOperationsInput | number
    orderAmount?: NullableFloatFieldUpdateOperationsInput | number | null
    platformFee?: NullableFloatFieldUpdateOperationsInput | number | null
    orderType?: NullableStringFieldUpdateOperationsInput | string | null
    commissionRate?: NullableFloatFieldUpdateOperationsInput | number | null
    priority?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumOrderStatusFieldUpdateOperationsInput | $Enums.OrderStatus
    assignedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    pickedUpAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    deliveredAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    cancelledAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    cancellationReason?: NullableStringFieldUpdateOperationsInput | string | null
    estimatedDuration?: NullableIntFieldUpdateOperationsInput | number | null
    actualDuration?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    barcode?: NullableStringFieldUpdateOperationsInput | string | null
    qrCode?: NullableStringFieldUpdateOperationsInput | string | null
    deliveryOtp?: NullableStringFieldUpdateOperationsInput | string | null
    deliveryQrCode?: NullableStringFieldUpdateOperationsInput | string | null
    otpExpiresAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    verifiedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    verificationMethod?: NullableStringFieldUpdateOperationsInput | string | null
    partner?: PartnerUpdateOneRequiredWithoutOrdersNestedInput
    agent?: AgentUpdateOneWithoutOrdersNestedInput
    currentAgent?: AgentUpdateOneWithoutCurrentOrderNestedInput
    rating?: AgentRatingUpdateOneWithoutOrderNestedInput
    payments?: PaymentUpdateManyWithoutOrderNestedInput
    partnerRevenue?: PartnerRevenueUpdateOneWithoutOrderNestedInput
    platformRevenue?: PlatformRevenueUpdateOneWithoutOrderNestedInput
    walletTransactions?: WalletTransactionUpdateManyWithoutOrderNestedInput
  }

  export type OrderUncheckedUpdateWithoutTicketsInput = {
    id?: StringFieldUpdateOperationsInput | string
    partnerId?: StringFieldUpdateOperationsInput | string
    agentId?: NullableStringFieldUpdateOperationsInput | string | null
    pickupLat?: FloatFieldUpdateOperationsInput | number
    pickupLng?: FloatFieldUpdateOperationsInput | number
    dropLat?: FloatFieldUpdateOperationsInput | number
    dropLng?: FloatFieldUpdateOperationsInput | number
    payoutAmount?: FloatFieldUpdateOperationsInput | number
    orderAmount?: NullableFloatFieldUpdateOperationsInput | number | null
    platformFee?: NullableFloatFieldUpdateOperationsInput | number | null
    orderType?: NullableStringFieldUpdateOperationsInput | string | null
    commissionRate?: NullableFloatFieldUpdateOperationsInput | number | null
    priority?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumOrderStatusFieldUpdateOperationsInput | $Enums.OrderStatus
    assignedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    pickedUpAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    deliveredAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    cancelledAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    cancellationReason?: NullableStringFieldUpdateOperationsInput | string | null
    estimatedDuration?: NullableIntFieldUpdateOperationsInput | number | null
    actualDuration?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    barcode?: NullableStringFieldUpdateOperationsInput | string | null
    qrCode?: NullableStringFieldUpdateOperationsInput | string | null
    deliveryOtp?: NullableStringFieldUpdateOperationsInput | string | null
    deliveryQrCode?: NullableStringFieldUpdateOperationsInput | string | null
    otpExpiresAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    verifiedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    verificationMethod?: NullableStringFieldUpdateOperationsInput | string | null
    currentAgent?: AgentUncheckedUpdateOneWithoutCurrentOrderNestedInput
    rating?: AgentRatingUncheckedUpdateOneWithoutOrderNestedInput
    payments?: PaymentUncheckedUpdateManyWithoutOrderNestedInput
    partnerRevenue?: PartnerRevenueUncheckedUpdateOneWithoutOrderNestedInput
    platformRevenue?: PlatformRevenueUncheckedUpdateOneWithoutOrderNestedInput
    walletTransactions?: WalletTransactionUncheckedUpdateManyWithoutOrderNestedInput
  }

  export type AgentUpsertWithoutTicketsInput = {
    update: XOR<AgentUpdateWithoutTicketsInput, AgentUncheckedUpdateWithoutTicketsInput>
    create: XOR<AgentCreateWithoutTicketsInput, AgentUncheckedCreateWithoutTicketsInput>
    where?: AgentWhereInput
  }

  export type AgentUpdateToOneWithWhereWithoutTicketsInput = {
    where?: AgentWhereInput
    data: XOR<AgentUpdateWithoutTicketsInput, AgentUncheckedUpdateWithoutTicketsInput>
  }

  export type AgentUpdateWithoutTicketsInput = {
    id?: StringFieldUpdateOperationsInput | string
    vehicleType?: EnumVehicleTypeFieldUpdateOperationsInput | $Enums.VehicleType
    status?: EnumAgentStatusFieldUpdateOperationsInput | $Enums.AgentStatus
    rating?: NullableFloatFieldUpdateOperationsInput | number | null
    totalOrders?: IntFieldUpdateOperationsInput | number
    completedOrders?: IntFieldUpdateOperationsInput | number
    cancelledOrders?: IntFieldUpdateOperationsInput | number
    acceptanceRate?: FloatFieldUpdateOperationsInput | number
    isApproved?: BoolFieldUpdateOperationsInput | boolean
    isBlocked?: BoolFieldUpdateOperationsInput | boolean
    blockedReason?: NullableStringFieldUpdateOperationsInput | string | null
    city?: NullableStringFieldUpdateOperationsInput | string | null
    state?: NullableStringFieldUpdateOperationsInput | string | null
    pincode?: NullableStringFieldUpdateOperationsInput | string | null
    lastOnlineAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneRequiredWithoutAgentNestedInput
    orders?: OrderUpdateManyWithoutAgentNestedInput
    currentOrder?: OrderUpdateOneWithoutCurrentAgentNestedInput
    documents?: AgentDocumentUpdateManyWithoutAgentNestedInput
    locationHistory?: AgentLocationUpdateManyWithoutAgentNestedInput
    ratings?: AgentRatingUpdateManyWithoutAgentNestedInput
    wallet?: AgentWalletUpdateOneWithoutAgentNestedInput
    walletPayouts?: WalletPayoutUpdateManyWithoutAgentNestedInput
    payments?: PaymentUpdateManyWithoutAgentNestedInput
    payrolls?: PayrollUpdateManyWithoutAgentNestedInput
    schedules?: AgentScheduleUpdateManyWithoutAgentNestedInput
  }

  export type AgentUncheckedUpdateWithoutTicketsInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    vehicleType?: EnumVehicleTypeFieldUpdateOperationsInput | $Enums.VehicleType
    status?: EnumAgentStatusFieldUpdateOperationsInput | $Enums.AgentStatus
    rating?: NullableFloatFieldUpdateOperationsInput | number | null
    totalOrders?: IntFieldUpdateOperationsInput | number
    completedOrders?: IntFieldUpdateOperationsInput | number
    cancelledOrders?: IntFieldUpdateOperationsInput | number
    acceptanceRate?: FloatFieldUpdateOperationsInput | number
    currentOrderId?: NullableStringFieldUpdateOperationsInput | string | null
    isApproved?: BoolFieldUpdateOperationsInput | boolean
    isBlocked?: BoolFieldUpdateOperationsInput | boolean
    blockedReason?: NullableStringFieldUpdateOperationsInput | string | null
    city?: NullableStringFieldUpdateOperationsInput | string | null
    state?: NullableStringFieldUpdateOperationsInput | string | null
    pincode?: NullableStringFieldUpdateOperationsInput | string | null
    lastOnlineAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    orders?: OrderUncheckedUpdateManyWithoutAgentNestedInput
    documents?: AgentDocumentUncheckedUpdateManyWithoutAgentNestedInput
    locationHistory?: AgentLocationUncheckedUpdateManyWithoutAgentNestedInput
    ratings?: AgentRatingUncheckedUpdateManyWithoutAgentNestedInput
    wallet?: AgentWalletUncheckedUpdateOneWithoutAgentNestedInput
    walletPayouts?: WalletPayoutUncheckedUpdateManyWithoutAgentNestedInput
    payments?: PaymentUncheckedUpdateManyWithoutAgentNestedInput
    payrolls?: PayrollUncheckedUpdateManyWithoutAgentNestedInput
    schedules?: AgentScheduleUncheckedUpdateManyWithoutAgentNestedInput
  }

  export type PartnerUpsertWithoutTicketsInput = {
    update: XOR<PartnerUpdateWithoutTicketsInput, PartnerUncheckedUpdateWithoutTicketsInput>
    create: XOR<PartnerCreateWithoutTicketsInput, PartnerUncheckedCreateWithoutTicketsInput>
    where?: PartnerWhereInput
  }

  export type PartnerUpdateToOneWithWhereWithoutTicketsInput = {
    where?: PartnerWhereInput
    data: XOR<PartnerUpdateWithoutTicketsInput, PartnerUncheckedUpdateWithoutTicketsInput>
  }

  export type PartnerUpdateWithoutTicketsInput = {
    id?: StringFieldUpdateOperationsInput | string
    companyName?: StringFieldUpdateOperationsInput | string
    apiKey?: StringFieldUpdateOperationsInput | string
    webhookUrl?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    city?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneRequiredWithoutPartnerNestedInput
    orders?: OrderUpdateManyWithoutPartnerNestedInput
    dailyStats?: PartnerDailyStatsUpdateManyWithoutPartnerNestedInput
    agentRatings?: AgentRatingUpdateManyWithoutPartnerNestedInput
    partnerRevenues?: PartnerRevenueUpdateManyWithoutPartnerNestedInput
    platformRevenues?: PlatformRevenueUpdateManyWithoutPartnerNestedInput
  }

  export type PartnerUncheckedUpdateWithoutTicketsInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    companyName?: StringFieldUpdateOperationsInput | string
    apiKey?: StringFieldUpdateOperationsInput | string
    webhookUrl?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    city?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    orders?: OrderUncheckedUpdateManyWithoutPartnerNestedInput
    dailyStats?: PartnerDailyStatsUncheckedUpdateManyWithoutPartnerNestedInput
    agentRatings?: AgentRatingUncheckedUpdateManyWithoutPartnerNestedInput
    partnerRevenues?: PartnerRevenueUncheckedUpdateManyWithoutPartnerNestedInput
    platformRevenues?: PlatformRevenueUncheckedUpdateManyWithoutPartnerNestedInput
  }

  export type UserUpsertWithoutTicketsInput = {
    update: XOR<UserUpdateWithoutTicketsInput, UserUncheckedUpdateWithoutTicketsInput>
    create: XOR<UserCreateWithoutTicketsInput, UserUncheckedCreateWithoutTicketsInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutTicketsInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutTicketsInput, UserUncheckedUpdateWithoutTicketsInput>
  }

  export type UserUpdateWithoutTicketsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    phone?: StringFieldUpdateOperationsInput | string
    passwordHash?: StringFieldUpdateOperationsInput | string
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    emailVerified?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    phoneVerified?: BoolFieldUpdateOperationsInput | boolean
    profilePicture?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    agent?: AgentUpdateOneWithoutUserNestedInput
    partner?: PartnerUpdateOneWithoutUserNestedInput
    notifications?: NotificationTokenUpdateManyWithoutUserNestedInput
    userNotifications?: NotificationUpdateManyWithoutUserNestedInput
  }

  export type UserUncheckedUpdateWithoutTicketsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    phone?: StringFieldUpdateOperationsInput | string
    passwordHash?: StringFieldUpdateOperationsInput | string
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    emailVerified?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    phoneVerified?: BoolFieldUpdateOperationsInput | boolean
    profilePicture?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    agent?: AgentUncheckedUpdateOneWithoutUserNestedInput
    partner?: PartnerUncheckedUpdateOneWithoutUserNestedInput
    notifications?: NotificationTokenUncheckedUpdateManyWithoutUserNestedInput
    userNotifications?: NotificationUncheckedUpdateManyWithoutUserNestedInput
  }

  export type PartnerCreateWithoutDailyStatsInput = {
    id?: string
    companyName: string
    apiKey: string
    webhookUrl?: string | null
    isActive?: boolean
    city?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    user: UserCreateNestedOneWithoutPartnerInput
    orders?: OrderCreateNestedManyWithoutPartnerInput
    tickets?: SupportTicketCreateNestedManyWithoutPartnerInput
    agentRatings?: AgentRatingCreateNestedManyWithoutPartnerInput
    partnerRevenues?: PartnerRevenueCreateNestedManyWithoutPartnerInput
    platformRevenues?: PlatformRevenueCreateNestedManyWithoutPartnerInput
  }

  export type PartnerUncheckedCreateWithoutDailyStatsInput = {
    id?: string
    userId: string
    companyName: string
    apiKey: string
    webhookUrl?: string | null
    isActive?: boolean
    city?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    orders?: OrderUncheckedCreateNestedManyWithoutPartnerInput
    tickets?: SupportTicketUncheckedCreateNestedManyWithoutPartnerInput
    agentRatings?: AgentRatingUncheckedCreateNestedManyWithoutPartnerInput
    partnerRevenues?: PartnerRevenueUncheckedCreateNestedManyWithoutPartnerInput
    platformRevenues?: PlatformRevenueUncheckedCreateNestedManyWithoutPartnerInput
  }

  export type PartnerCreateOrConnectWithoutDailyStatsInput = {
    where: PartnerWhereUniqueInput
    create: XOR<PartnerCreateWithoutDailyStatsInput, PartnerUncheckedCreateWithoutDailyStatsInput>
  }

  export type PartnerUpsertWithoutDailyStatsInput = {
    update: XOR<PartnerUpdateWithoutDailyStatsInput, PartnerUncheckedUpdateWithoutDailyStatsInput>
    create: XOR<PartnerCreateWithoutDailyStatsInput, PartnerUncheckedCreateWithoutDailyStatsInput>
    where?: PartnerWhereInput
  }

  export type PartnerUpdateToOneWithWhereWithoutDailyStatsInput = {
    where?: PartnerWhereInput
    data: XOR<PartnerUpdateWithoutDailyStatsInput, PartnerUncheckedUpdateWithoutDailyStatsInput>
  }

  export type PartnerUpdateWithoutDailyStatsInput = {
    id?: StringFieldUpdateOperationsInput | string
    companyName?: StringFieldUpdateOperationsInput | string
    apiKey?: StringFieldUpdateOperationsInput | string
    webhookUrl?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    city?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneRequiredWithoutPartnerNestedInput
    orders?: OrderUpdateManyWithoutPartnerNestedInput
    tickets?: SupportTicketUpdateManyWithoutPartnerNestedInput
    agentRatings?: AgentRatingUpdateManyWithoutPartnerNestedInput
    partnerRevenues?: PartnerRevenueUpdateManyWithoutPartnerNestedInput
    platformRevenues?: PlatformRevenueUpdateManyWithoutPartnerNestedInput
  }

  export type PartnerUncheckedUpdateWithoutDailyStatsInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    companyName?: StringFieldUpdateOperationsInput | string
    apiKey?: StringFieldUpdateOperationsInput | string
    webhookUrl?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    city?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    orders?: OrderUncheckedUpdateManyWithoutPartnerNestedInput
    tickets?: SupportTicketUncheckedUpdateManyWithoutPartnerNestedInput
    agentRatings?: AgentRatingUncheckedUpdateManyWithoutPartnerNestedInput
    partnerRevenues?: PartnerRevenueUncheckedUpdateManyWithoutPartnerNestedInput
    platformRevenues?: PlatformRevenueUncheckedUpdateManyWithoutPartnerNestedInput
  }

  export type PartnerCreateWithoutPartnerRevenuesInput = {
    id?: string
    companyName: string
    apiKey: string
    webhookUrl?: string | null
    isActive?: boolean
    city?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    user: UserCreateNestedOneWithoutPartnerInput
    orders?: OrderCreateNestedManyWithoutPartnerInput
    tickets?: SupportTicketCreateNestedManyWithoutPartnerInput
    dailyStats?: PartnerDailyStatsCreateNestedManyWithoutPartnerInput
    agentRatings?: AgentRatingCreateNestedManyWithoutPartnerInput
    platformRevenues?: PlatformRevenueCreateNestedManyWithoutPartnerInput
  }

  export type PartnerUncheckedCreateWithoutPartnerRevenuesInput = {
    id?: string
    userId: string
    companyName: string
    apiKey: string
    webhookUrl?: string | null
    isActive?: boolean
    city?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    orders?: OrderUncheckedCreateNestedManyWithoutPartnerInput
    tickets?: SupportTicketUncheckedCreateNestedManyWithoutPartnerInput
    dailyStats?: PartnerDailyStatsUncheckedCreateNestedManyWithoutPartnerInput
    agentRatings?: AgentRatingUncheckedCreateNestedManyWithoutPartnerInput
    platformRevenues?: PlatformRevenueUncheckedCreateNestedManyWithoutPartnerInput
  }

  export type PartnerCreateOrConnectWithoutPartnerRevenuesInput = {
    where: PartnerWhereUniqueInput
    create: XOR<PartnerCreateWithoutPartnerRevenuesInput, PartnerUncheckedCreateWithoutPartnerRevenuesInput>
  }

  export type OrderCreateWithoutPartnerRevenueInput = {
    id?: string
    pickupLat: number
    pickupLng: number
    dropLat: number
    dropLng: number
    payoutAmount: number
    orderAmount?: number | null
    platformFee?: number | null
    orderType?: string | null
    commissionRate?: number | null
    priority?: string | null
    status?: $Enums.OrderStatus
    assignedAt?: Date | string | null
    pickedUpAt?: Date | string | null
    deliveredAt?: Date | string | null
    cancelledAt?: Date | string | null
    cancellationReason?: string | null
    estimatedDuration?: number | null
    actualDuration?: number | null
    createdAt?: Date | string
    updatedAt?: Date | string
    barcode?: string | null
    qrCode?: string | null
    deliveryOtp?: string | null
    deliveryQrCode?: string | null
    otpExpiresAt?: Date | string | null
    verifiedAt?: Date | string | null
    verificationMethod?: string | null
    partner: PartnerCreateNestedOneWithoutOrdersInput
    agent?: AgentCreateNestedOneWithoutOrdersInput
    currentAgent?: AgentCreateNestedOneWithoutCurrentOrderInput
    tickets?: SupportTicketCreateNestedManyWithoutOrderInput
    rating?: AgentRatingCreateNestedOneWithoutOrderInput
    payments?: PaymentCreateNestedManyWithoutOrderInput
    platformRevenue?: PlatformRevenueCreateNestedOneWithoutOrderInput
    walletTransactions?: WalletTransactionCreateNestedManyWithoutOrderInput
  }

  export type OrderUncheckedCreateWithoutPartnerRevenueInput = {
    id?: string
    partnerId: string
    agentId?: string | null
    pickupLat: number
    pickupLng: number
    dropLat: number
    dropLng: number
    payoutAmount: number
    orderAmount?: number | null
    platformFee?: number | null
    orderType?: string | null
    commissionRate?: number | null
    priority?: string | null
    status?: $Enums.OrderStatus
    assignedAt?: Date | string | null
    pickedUpAt?: Date | string | null
    deliveredAt?: Date | string | null
    cancelledAt?: Date | string | null
    cancellationReason?: string | null
    estimatedDuration?: number | null
    actualDuration?: number | null
    createdAt?: Date | string
    updatedAt?: Date | string
    barcode?: string | null
    qrCode?: string | null
    deliveryOtp?: string | null
    deliveryQrCode?: string | null
    otpExpiresAt?: Date | string | null
    verifiedAt?: Date | string | null
    verificationMethod?: string | null
    currentAgent?: AgentUncheckedCreateNestedOneWithoutCurrentOrderInput
    tickets?: SupportTicketUncheckedCreateNestedManyWithoutOrderInput
    rating?: AgentRatingUncheckedCreateNestedOneWithoutOrderInput
    payments?: PaymentUncheckedCreateNestedManyWithoutOrderInput
    platformRevenue?: PlatformRevenueUncheckedCreateNestedOneWithoutOrderInput
    walletTransactions?: WalletTransactionUncheckedCreateNestedManyWithoutOrderInput
  }

  export type OrderCreateOrConnectWithoutPartnerRevenueInput = {
    where: OrderWhereUniqueInput
    create: XOR<OrderCreateWithoutPartnerRevenueInput, OrderUncheckedCreateWithoutPartnerRevenueInput>
  }

  export type PartnerUpsertWithoutPartnerRevenuesInput = {
    update: XOR<PartnerUpdateWithoutPartnerRevenuesInput, PartnerUncheckedUpdateWithoutPartnerRevenuesInput>
    create: XOR<PartnerCreateWithoutPartnerRevenuesInput, PartnerUncheckedCreateWithoutPartnerRevenuesInput>
    where?: PartnerWhereInput
  }

  export type PartnerUpdateToOneWithWhereWithoutPartnerRevenuesInput = {
    where?: PartnerWhereInput
    data: XOR<PartnerUpdateWithoutPartnerRevenuesInput, PartnerUncheckedUpdateWithoutPartnerRevenuesInput>
  }

  export type PartnerUpdateWithoutPartnerRevenuesInput = {
    id?: StringFieldUpdateOperationsInput | string
    companyName?: StringFieldUpdateOperationsInput | string
    apiKey?: StringFieldUpdateOperationsInput | string
    webhookUrl?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    city?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneRequiredWithoutPartnerNestedInput
    orders?: OrderUpdateManyWithoutPartnerNestedInput
    tickets?: SupportTicketUpdateManyWithoutPartnerNestedInput
    dailyStats?: PartnerDailyStatsUpdateManyWithoutPartnerNestedInput
    agentRatings?: AgentRatingUpdateManyWithoutPartnerNestedInput
    platformRevenues?: PlatformRevenueUpdateManyWithoutPartnerNestedInput
  }

  export type PartnerUncheckedUpdateWithoutPartnerRevenuesInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    companyName?: StringFieldUpdateOperationsInput | string
    apiKey?: StringFieldUpdateOperationsInput | string
    webhookUrl?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    city?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    orders?: OrderUncheckedUpdateManyWithoutPartnerNestedInput
    tickets?: SupportTicketUncheckedUpdateManyWithoutPartnerNestedInput
    dailyStats?: PartnerDailyStatsUncheckedUpdateManyWithoutPartnerNestedInput
    agentRatings?: AgentRatingUncheckedUpdateManyWithoutPartnerNestedInput
    platformRevenues?: PlatformRevenueUncheckedUpdateManyWithoutPartnerNestedInput
  }

  export type OrderUpsertWithoutPartnerRevenueInput = {
    update: XOR<OrderUpdateWithoutPartnerRevenueInput, OrderUncheckedUpdateWithoutPartnerRevenueInput>
    create: XOR<OrderCreateWithoutPartnerRevenueInput, OrderUncheckedCreateWithoutPartnerRevenueInput>
    where?: OrderWhereInput
  }

  export type OrderUpdateToOneWithWhereWithoutPartnerRevenueInput = {
    where?: OrderWhereInput
    data: XOR<OrderUpdateWithoutPartnerRevenueInput, OrderUncheckedUpdateWithoutPartnerRevenueInput>
  }

  export type OrderUpdateWithoutPartnerRevenueInput = {
    id?: StringFieldUpdateOperationsInput | string
    pickupLat?: FloatFieldUpdateOperationsInput | number
    pickupLng?: FloatFieldUpdateOperationsInput | number
    dropLat?: FloatFieldUpdateOperationsInput | number
    dropLng?: FloatFieldUpdateOperationsInput | number
    payoutAmount?: FloatFieldUpdateOperationsInput | number
    orderAmount?: NullableFloatFieldUpdateOperationsInput | number | null
    platformFee?: NullableFloatFieldUpdateOperationsInput | number | null
    orderType?: NullableStringFieldUpdateOperationsInput | string | null
    commissionRate?: NullableFloatFieldUpdateOperationsInput | number | null
    priority?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumOrderStatusFieldUpdateOperationsInput | $Enums.OrderStatus
    assignedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    pickedUpAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    deliveredAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    cancelledAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    cancellationReason?: NullableStringFieldUpdateOperationsInput | string | null
    estimatedDuration?: NullableIntFieldUpdateOperationsInput | number | null
    actualDuration?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    barcode?: NullableStringFieldUpdateOperationsInput | string | null
    qrCode?: NullableStringFieldUpdateOperationsInput | string | null
    deliveryOtp?: NullableStringFieldUpdateOperationsInput | string | null
    deliveryQrCode?: NullableStringFieldUpdateOperationsInput | string | null
    otpExpiresAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    verifiedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    verificationMethod?: NullableStringFieldUpdateOperationsInput | string | null
    partner?: PartnerUpdateOneRequiredWithoutOrdersNestedInput
    agent?: AgentUpdateOneWithoutOrdersNestedInput
    currentAgent?: AgentUpdateOneWithoutCurrentOrderNestedInput
    tickets?: SupportTicketUpdateManyWithoutOrderNestedInput
    rating?: AgentRatingUpdateOneWithoutOrderNestedInput
    payments?: PaymentUpdateManyWithoutOrderNestedInput
    platformRevenue?: PlatformRevenueUpdateOneWithoutOrderNestedInput
    walletTransactions?: WalletTransactionUpdateManyWithoutOrderNestedInput
  }

  export type OrderUncheckedUpdateWithoutPartnerRevenueInput = {
    id?: StringFieldUpdateOperationsInput | string
    partnerId?: StringFieldUpdateOperationsInput | string
    agentId?: NullableStringFieldUpdateOperationsInput | string | null
    pickupLat?: FloatFieldUpdateOperationsInput | number
    pickupLng?: FloatFieldUpdateOperationsInput | number
    dropLat?: FloatFieldUpdateOperationsInput | number
    dropLng?: FloatFieldUpdateOperationsInput | number
    payoutAmount?: FloatFieldUpdateOperationsInput | number
    orderAmount?: NullableFloatFieldUpdateOperationsInput | number | null
    platformFee?: NullableFloatFieldUpdateOperationsInput | number | null
    orderType?: NullableStringFieldUpdateOperationsInput | string | null
    commissionRate?: NullableFloatFieldUpdateOperationsInput | number | null
    priority?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumOrderStatusFieldUpdateOperationsInput | $Enums.OrderStatus
    assignedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    pickedUpAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    deliveredAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    cancelledAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    cancellationReason?: NullableStringFieldUpdateOperationsInput | string | null
    estimatedDuration?: NullableIntFieldUpdateOperationsInput | number | null
    actualDuration?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    barcode?: NullableStringFieldUpdateOperationsInput | string | null
    qrCode?: NullableStringFieldUpdateOperationsInput | string | null
    deliveryOtp?: NullableStringFieldUpdateOperationsInput | string | null
    deliveryQrCode?: NullableStringFieldUpdateOperationsInput | string | null
    otpExpiresAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    verifiedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    verificationMethod?: NullableStringFieldUpdateOperationsInput | string | null
    currentAgent?: AgentUncheckedUpdateOneWithoutCurrentOrderNestedInput
    tickets?: SupportTicketUncheckedUpdateManyWithoutOrderNestedInput
    rating?: AgentRatingUncheckedUpdateOneWithoutOrderNestedInput
    payments?: PaymentUncheckedUpdateManyWithoutOrderNestedInput
    platformRevenue?: PlatformRevenueUncheckedUpdateOneWithoutOrderNestedInput
    walletTransactions?: WalletTransactionUncheckedUpdateManyWithoutOrderNestedInput
  }

  export type OrderCreateWithoutPlatformRevenueInput = {
    id?: string
    pickupLat: number
    pickupLng: number
    dropLat: number
    dropLng: number
    payoutAmount: number
    orderAmount?: number | null
    platformFee?: number | null
    orderType?: string | null
    commissionRate?: number | null
    priority?: string | null
    status?: $Enums.OrderStatus
    assignedAt?: Date | string | null
    pickedUpAt?: Date | string | null
    deliveredAt?: Date | string | null
    cancelledAt?: Date | string | null
    cancellationReason?: string | null
    estimatedDuration?: number | null
    actualDuration?: number | null
    createdAt?: Date | string
    updatedAt?: Date | string
    barcode?: string | null
    qrCode?: string | null
    deliveryOtp?: string | null
    deliveryQrCode?: string | null
    otpExpiresAt?: Date | string | null
    verifiedAt?: Date | string | null
    verificationMethod?: string | null
    partner: PartnerCreateNestedOneWithoutOrdersInput
    agent?: AgentCreateNestedOneWithoutOrdersInput
    currentAgent?: AgentCreateNestedOneWithoutCurrentOrderInput
    tickets?: SupportTicketCreateNestedManyWithoutOrderInput
    rating?: AgentRatingCreateNestedOneWithoutOrderInput
    payments?: PaymentCreateNestedManyWithoutOrderInput
    partnerRevenue?: PartnerRevenueCreateNestedOneWithoutOrderInput
    walletTransactions?: WalletTransactionCreateNestedManyWithoutOrderInput
  }

  export type OrderUncheckedCreateWithoutPlatformRevenueInput = {
    id?: string
    partnerId: string
    agentId?: string | null
    pickupLat: number
    pickupLng: number
    dropLat: number
    dropLng: number
    payoutAmount: number
    orderAmount?: number | null
    platformFee?: number | null
    orderType?: string | null
    commissionRate?: number | null
    priority?: string | null
    status?: $Enums.OrderStatus
    assignedAt?: Date | string | null
    pickedUpAt?: Date | string | null
    deliveredAt?: Date | string | null
    cancelledAt?: Date | string | null
    cancellationReason?: string | null
    estimatedDuration?: number | null
    actualDuration?: number | null
    createdAt?: Date | string
    updatedAt?: Date | string
    barcode?: string | null
    qrCode?: string | null
    deliveryOtp?: string | null
    deliveryQrCode?: string | null
    otpExpiresAt?: Date | string | null
    verifiedAt?: Date | string | null
    verificationMethod?: string | null
    currentAgent?: AgentUncheckedCreateNestedOneWithoutCurrentOrderInput
    tickets?: SupportTicketUncheckedCreateNestedManyWithoutOrderInput
    rating?: AgentRatingUncheckedCreateNestedOneWithoutOrderInput
    payments?: PaymentUncheckedCreateNestedManyWithoutOrderInput
    partnerRevenue?: PartnerRevenueUncheckedCreateNestedOneWithoutOrderInput
    walletTransactions?: WalletTransactionUncheckedCreateNestedManyWithoutOrderInput
  }

  export type OrderCreateOrConnectWithoutPlatformRevenueInput = {
    where: OrderWhereUniqueInput
    create: XOR<OrderCreateWithoutPlatformRevenueInput, OrderUncheckedCreateWithoutPlatformRevenueInput>
  }

  export type PartnerCreateWithoutPlatformRevenuesInput = {
    id?: string
    companyName: string
    apiKey: string
    webhookUrl?: string | null
    isActive?: boolean
    city?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    user: UserCreateNestedOneWithoutPartnerInput
    orders?: OrderCreateNestedManyWithoutPartnerInput
    tickets?: SupportTicketCreateNestedManyWithoutPartnerInput
    dailyStats?: PartnerDailyStatsCreateNestedManyWithoutPartnerInput
    agentRatings?: AgentRatingCreateNestedManyWithoutPartnerInput
    partnerRevenues?: PartnerRevenueCreateNestedManyWithoutPartnerInput
  }

  export type PartnerUncheckedCreateWithoutPlatformRevenuesInput = {
    id?: string
    userId: string
    companyName: string
    apiKey: string
    webhookUrl?: string | null
    isActive?: boolean
    city?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    orders?: OrderUncheckedCreateNestedManyWithoutPartnerInput
    tickets?: SupportTicketUncheckedCreateNestedManyWithoutPartnerInput
    dailyStats?: PartnerDailyStatsUncheckedCreateNestedManyWithoutPartnerInput
    agentRatings?: AgentRatingUncheckedCreateNestedManyWithoutPartnerInput
    partnerRevenues?: PartnerRevenueUncheckedCreateNestedManyWithoutPartnerInput
  }

  export type PartnerCreateOrConnectWithoutPlatformRevenuesInput = {
    where: PartnerWhereUniqueInput
    create: XOR<PartnerCreateWithoutPlatformRevenuesInput, PartnerUncheckedCreateWithoutPlatformRevenuesInput>
  }

  export type OrderUpsertWithoutPlatformRevenueInput = {
    update: XOR<OrderUpdateWithoutPlatformRevenueInput, OrderUncheckedUpdateWithoutPlatformRevenueInput>
    create: XOR<OrderCreateWithoutPlatformRevenueInput, OrderUncheckedCreateWithoutPlatformRevenueInput>
    where?: OrderWhereInput
  }

  export type OrderUpdateToOneWithWhereWithoutPlatformRevenueInput = {
    where?: OrderWhereInput
    data: XOR<OrderUpdateWithoutPlatformRevenueInput, OrderUncheckedUpdateWithoutPlatformRevenueInput>
  }

  export type OrderUpdateWithoutPlatformRevenueInput = {
    id?: StringFieldUpdateOperationsInput | string
    pickupLat?: FloatFieldUpdateOperationsInput | number
    pickupLng?: FloatFieldUpdateOperationsInput | number
    dropLat?: FloatFieldUpdateOperationsInput | number
    dropLng?: FloatFieldUpdateOperationsInput | number
    payoutAmount?: FloatFieldUpdateOperationsInput | number
    orderAmount?: NullableFloatFieldUpdateOperationsInput | number | null
    platformFee?: NullableFloatFieldUpdateOperationsInput | number | null
    orderType?: NullableStringFieldUpdateOperationsInput | string | null
    commissionRate?: NullableFloatFieldUpdateOperationsInput | number | null
    priority?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumOrderStatusFieldUpdateOperationsInput | $Enums.OrderStatus
    assignedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    pickedUpAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    deliveredAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    cancelledAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    cancellationReason?: NullableStringFieldUpdateOperationsInput | string | null
    estimatedDuration?: NullableIntFieldUpdateOperationsInput | number | null
    actualDuration?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    barcode?: NullableStringFieldUpdateOperationsInput | string | null
    qrCode?: NullableStringFieldUpdateOperationsInput | string | null
    deliveryOtp?: NullableStringFieldUpdateOperationsInput | string | null
    deliveryQrCode?: NullableStringFieldUpdateOperationsInput | string | null
    otpExpiresAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    verifiedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    verificationMethod?: NullableStringFieldUpdateOperationsInput | string | null
    partner?: PartnerUpdateOneRequiredWithoutOrdersNestedInput
    agent?: AgentUpdateOneWithoutOrdersNestedInput
    currentAgent?: AgentUpdateOneWithoutCurrentOrderNestedInput
    tickets?: SupportTicketUpdateManyWithoutOrderNestedInput
    rating?: AgentRatingUpdateOneWithoutOrderNestedInput
    payments?: PaymentUpdateManyWithoutOrderNestedInput
    partnerRevenue?: PartnerRevenueUpdateOneWithoutOrderNestedInput
    walletTransactions?: WalletTransactionUpdateManyWithoutOrderNestedInput
  }

  export type OrderUncheckedUpdateWithoutPlatformRevenueInput = {
    id?: StringFieldUpdateOperationsInput | string
    partnerId?: StringFieldUpdateOperationsInput | string
    agentId?: NullableStringFieldUpdateOperationsInput | string | null
    pickupLat?: FloatFieldUpdateOperationsInput | number
    pickupLng?: FloatFieldUpdateOperationsInput | number
    dropLat?: FloatFieldUpdateOperationsInput | number
    dropLng?: FloatFieldUpdateOperationsInput | number
    payoutAmount?: FloatFieldUpdateOperationsInput | number
    orderAmount?: NullableFloatFieldUpdateOperationsInput | number | null
    platformFee?: NullableFloatFieldUpdateOperationsInput | number | null
    orderType?: NullableStringFieldUpdateOperationsInput | string | null
    commissionRate?: NullableFloatFieldUpdateOperationsInput | number | null
    priority?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumOrderStatusFieldUpdateOperationsInput | $Enums.OrderStatus
    assignedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    pickedUpAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    deliveredAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    cancelledAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    cancellationReason?: NullableStringFieldUpdateOperationsInput | string | null
    estimatedDuration?: NullableIntFieldUpdateOperationsInput | number | null
    actualDuration?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    barcode?: NullableStringFieldUpdateOperationsInput | string | null
    qrCode?: NullableStringFieldUpdateOperationsInput | string | null
    deliveryOtp?: NullableStringFieldUpdateOperationsInput | string | null
    deliveryQrCode?: NullableStringFieldUpdateOperationsInput | string | null
    otpExpiresAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    verifiedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    verificationMethod?: NullableStringFieldUpdateOperationsInput | string | null
    currentAgent?: AgentUncheckedUpdateOneWithoutCurrentOrderNestedInput
    tickets?: SupportTicketUncheckedUpdateManyWithoutOrderNestedInput
    rating?: AgentRatingUncheckedUpdateOneWithoutOrderNestedInput
    payments?: PaymentUncheckedUpdateManyWithoutOrderNestedInput
    partnerRevenue?: PartnerRevenueUncheckedUpdateOneWithoutOrderNestedInput
    walletTransactions?: WalletTransactionUncheckedUpdateManyWithoutOrderNestedInput
  }

  export type PartnerUpsertWithoutPlatformRevenuesInput = {
    update: XOR<PartnerUpdateWithoutPlatformRevenuesInput, PartnerUncheckedUpdateWithoutPlatformRevenuesInput>
    create: XOR<PartnerCreateWithoutPlatformRevenuesInput, PartnerUncheckedCreateWithoutPlatformRevenuesInput>
    where?: PartnerWhereInput
  }

  export type PartnerUpdateToOneWithWhereWithoutPlatformRevenuesInput = {
    where?: PartnerWhereInput
    data: XOR<PartnerUpdateWithoutPlatformRevenuesInput, PartnerUncheckedUpdateWithoutPlatformRevenuesInput>
  }

  export type PartnerUpdateWithoutPlatformRevenuesInput = {
    id?: StringFieldUpdateOperationsInput | string
    companyName?: StringFieldUpdateOperationsInput | string
    apiKey?: StringFieldUpdateOperationsInput | string
    webhookUrl?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    city?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneRequiredWithoutPartnerNestedInput
    orders?: OrderUpdateManyWithoutPartnerNestedInput
    tickets?: SupportTicketUpdateManyWithoutPartnerNestedInput
    dailyStats?: PartnerDailyStatsUpdateManyWithoutPartnerNestedInput
    agentRatings?: AgentRatingUpdateManyWithoutPartnerNestedInput
    partnerRevenues?: PartnerRevenueUpdateManyWithoutPartnerNestedInput
  }

  export type PartnerUncheckedUpdateWithoutPlatformRevenuesInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    companyName?: StringFieldUpdateOperationsInput | string
    apiKey?: StringFieldUpdateOperationsInput | string
    webhookUrl?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    city?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    orders?: OrderUncheckedUpdateManyWithoutPartnerNestedInput
    tickets?: SupportTicketUncheckedUpdateManyWithoutPartnerNestedInput
    dailyStats?: PartnerDailyStatsUncheckedUpdateManyWithoutPartnerNestedInput
    agentRatings?: AgentRatingUncheckedUpdateManyWithoutPartnerNestedInput
    partnerRevenues?: PartnerRevenueUncheckedUpdateManyWithoutPartnerNestedInput
  }

  export type WalletTransactionCreateWithoutAdminWalletInput = {
    id?: string
    walletType: string
    amount: number
    type: string
    description?: string | null
    balanceBefore: number
    balanceAfter: number
    status?: string
    createdAt?: Date | string
    agentWallet?: AgentWalletCreateNestedOneWithoutTransactionsInput
    order?: OrderCreateNestedOneWithoutWalletTransactionsInput
  }

  export type WalletTransactionUncheckedCreateWithoutAdminWalletInput = {
    id?: string
    walletType: string
    agentWalletId?: string | null
    orderId?: string | null
    amount: number
    type: string
    description?: string | null
    balanceBefore: number
    balanceAfter: number
    status?: string
    createdAt?: Date | string
  }

  export type WalletTransactionCreateOrConnectWithoutAdminWalletInput = {
    where: WalletTransactionWhereUniqueInput
    create: XOR<WalletTransactionCreateWithoutAdminWalletInput, WalletTransactionUncheckedCreateWithoutAdminWalletInput>
  }

  export type WalletTransactionCreateManyAdminWalletInputEnvelope = {
    data: WalletTransactionCreateManyAdminWalletInput | WalletTransactionCreateManyAdminWalletInput[]
    skipDuplicates?: boolean
  }

  export type WalletTransactionUpsertWithWhereUniqueWithoutAdminWalletInput = {
    where: WalletTransactionWhereUniqueInput
    update: XOR<WalletTransactionUpdateWithoutAdminWalletInput, WalletTransactionUncheckedUpdateWithoutAdminWalletInput>
    create: XOR<WalletTransactionCreateWithoutAdminWalletInput, WalletTransactionUncheckedCreateWithoutAdminWalletInput>
  }

  export type WalletTransactionUpdateWithWhereUniqueWithoutAdminWalletInput = {
    where: WalletTransactionWhereUniqueInput
    data: XOR<WalletTransactionUpdateWithoutAdminWalletInput, WalletTransactionUncheckedUpdateWithoutAdminWalletInput>
  }

  export type WalletTransactionUpdateManyWithWhereWithoutAdminWalletInput = {
    where: WalletTransactionScalarWhereInput
    data: XOR<WalletTransactionUpdateManyMutationInput, WalletTransactionUncheckedUpdateManyWithoutAdminWalletInput>
  }

  export type AgentCreateWithoutWalletInput = {
    id?: string
    vehicleType: $Enums.VehicleType
    status?: $Enums.AgentStatus
    rating?: number | null
    totalOrders?: number
    completedOrders?: number
    cancelledOrders?: number
    acceptanceRate?: number
    isApproved?: boolean
    isBlocked?: boolean
    blockedReason?: string | null
    city?: string | null
    state?: string | null
    pincode?: string | null
    lastOnlineAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    user: UserCreateNestedOneWithoutAgentInput
    orders?: OrderCreateNestedManyWithoutAgentInput
    currentOrder?: OrderCreateNestedOneWithoutCurrentAgentInput
    documents?: AgentDocumentCreateNestedManyWithoutAgentInput
    locationHistory?: AgentLocationCreateNestedManyWithoutAgentInput
    tickets?: SupportTicketCreateNestedManyWithoutAgentInput
    ratings?: AgentRatingCreateNestedManyWithoutAgentInput
    walletPayouts?: WalletPayoutCreateNestedManyWithoutAgentInput
    payments?: PaymentCreateNestedManyWithoutAgentInput
    payrolls?: PayrollCreateNestedManyWithoutAgentInput
    schedules?: AgentScheduleCreateNestedManyWithoutAgentInput
  }

  export type AgentUncheckedCreateWithoutWalletInput = {
    id?: string
    userId: string
    vehicleType: $Enums.VehicleType
    status?: $Enums.AgentStatus
    rating?: number | null
    totalOrders?: number
    completedOrders?: number
    cancelledOrders?: number
    acceptanceRate?: number
    currentOrderId?: string | null
    isApproved?: boolean
    isBlocked?: boolean
    blockedReason?: string | null
    city?: string | null
    state?: string | null
    pincode?: string | null
    lastOnlineAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    orders?: OrderUncheckedCreateNestedManyWithoutAgentInput
    documents?: AgentDocumentUncheckedCreateNestedManyWithoutAgentInput
    locationHistory?: AgentLocationUncheckedCreateNestedManyWithoutAgentInput
    tickets?: SupportTicketUncheckedCreateNestedManyWithoutAgentInput
    ratings?: AgentRatingUncheckedCreateNestedManyWithoutAgentInput
    walletPayouts?: WalletPayoutUncheckedCreateNestedManyWithoutAgentInput
    payments?: PaymentUncheckedCreateNestedManyWithoutAgentInput
    payrolls?: PayrollUncheckedCreateNestedManyWithoutAgentInput
    schedules?: AgentScheduleUncheckedCreateNestedManyWithoutAgentInput
  }

  export type AgentCreateOrConnectWithoutWalletInput = {
    where: AgentWhereUniqueInput
    create: XOR<AgentCreateWithoutWalletInput, AgentUncheckedCreateWithoutWalletInput>
  }

  export type WalletTransactionCreateWithoutAgentWalletInput = {
    id?: string
    walletType: string
    amount: number
    type: string
    description?: string | null
    balanceBefore: number
    balanceAfter: number
    status?: string
    createdAt?: Date | string
    adminWallet?: AdminWalletCreateNestedOneWithoutTransactionsInput
    order?: OrderCreateNestedOneWithoutWalletTransactionsInput
  }

  export type WalletTransactionUncheckedCreateWithoutAgentWalletInput = {
    id?: string
    walletType: string
    adminWalletId?: string | null
    orderId?: string | null
    amount: number
    type: string
    description?: string | null
    balanceBefore: number
    balanceAfter: number
    status?: string
    createdAt?: Date | string
  }

  export type WalletTransactionCreateOrConnectWithoutAgentWalletInput = {
    where: WalletTransactionWhereUniqueInput
    create: XOR<WalletTransactionCreateWithoutAgentWalletInput, WalletTransactionUncheckedCreateWithoutAgentWalletInput>
  }

  export type WalletTransactionCreateManyAgentWalletInputEnvelope = {
    data: WalletTransactionCreateManyAgentWalletInput | WalletTransactionCreateManyAgentWalletInput[]
    skipDuplicates?: boolean
  }

  export type WalletPayoutCreateWithoutAgentWalletInput = {
    id?: string
    amount: number
    periodStart: Date | string
    periodEnd: Date | string
    status?: string
    paymentMethod?: string | null
    transactionId?: string | null
    bankAccount?: string | null
    upiId?: string | null
    processedAt?: Date | string | null
    failedAt?: Date | string | null
    failureReason?: string | null
    notes?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    agent: AgentCreateNestedOneWithoutWalletPayoutsInput
  }

  export type WalletPayoutUncheckedCreateWithoutAgentWalletInput = {
    id?: string
    agentId: string
    amount: number
    periodStart: Date | string
    periodEnd: Date | string
    status?: string
    paymentMethod?: string | null
    transactionId?: string | null
    bankAccount?: string | null
    upiId?: string | null
    processedAt?: Date | string | null
    failedAt?: Date | string | null
    failureReason?: string | null
    notes?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type WalletPayoutCreateOrConnectWithoutAgentWalletInput = {
    where: WalletPayoutWhereUniqueInput
    create: XOR<WalletPayoutCreateWithoutAgentWalletInput, WalletPayoutUncheckedCreateWithoutAgentWalletInput>
  }

  export type WalletPayoutCreateManyAgentWalletInputEnvelope = {
    data: WalletPayoutCreateManyAgentWalletInput | WalletPayoutCreateManyAgentWalletInput[]
    skipDuplicates?: boolean
  }

  export type AgentUpsertWithoutWalletInput = {
    update: XOR<AgentUpdateWithoutWalletInput, AgentUncheckedUpdateWithoutWalletInput>
    create: XOR<AgentCreateWithoutWalletInput, AgentUncheckedCreateWithoutWalletInput>
    where?: AgentWhereInput
  }

  export type AgentUpdateToOneWithWhereWithoutWalletInput = {
    where?: AgentWhereInput
    data: XOR<AgentUpdateWithoutWalletInput, AgentUncheckedUpdateWithoutWalletInput>
  }

  export type AgentUpdateWithoutWalletInput = {
    id?: StringFieldUpdateOperationsInput | string
    vehicleType?: EnumVehicleTypeFieldUpdateOperationsInput | $Enums.VehicleType
    status?: EnumAgentStatusFieldUpdateOperationsInput | $Enums.AgentStatus
    rating?: NullableFloatFieldUpdateOperationsInput | number | null
    totalOrders?: IntFieldUpdateOperationsInput | number
    completedOrders?: IntFieldUpdateOperationsInput | number
    cancelledOrders?: IntFieldUpdateOperationsInput | number
    acceptanceRate?: FloatFieldUpdateOperationsInput | number
    isApproved?: BoolFieldUpdateOperationsInput | boolean
    isBlocked?: BoolFieldUpdateOperationsInput | boolean
    blockedReason?: NullableStringFieldUpdateOperationsInput | string | null
    city?: NullableStringFieldUpdateOperationsInput | string | null
    state?: NullableStringFieldUpdateOperationsInput | string | null
    pincode?: NullableStringFieldUpdateOperationsInput | string | null
    lastOnlineAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneRequiredWithoutAgentNestedInput
    orders?: OrderUpdateManyWithoutAgentNestedInput
    currentOrder?: OrderUpdateOneWithoutCurrentAgentNestedInput
    documents?: AgentDocumentUpdateManyWithoutAgentNestedInput
    locationHistory?: AgentLocationUpdateManyWithoutAgentNestedInput
    tickets?: SupportTicketUpdateManyWithoutAgentNestedInput
    ratings?: AgentRatingUpdateManyWithoutAgentNestedInput
    walletPayouts?: WalletPayoutUpdateManyWithoutAgentNestedInput
    payments?: PaymentUpdateManyWithoutAgentNestedInput
    payrolls?: PayrollUpdateManyWithoutAgentNestedInput
    schedules?: AgentScheduleUpdateManyWithoutAgentNestedInput
  }

  export type AgentUncheckedUpdateWithoutWalletInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    vehicleType?: EnumVehicleTypeFieldUpdateOperationsInput | $Enums.VehicleType
    status?: EnumAgentStatusFieldUpdateOperationsInput | $Enums.AgentStatus
    rating?: NullableFloatFieldUpdateOperationsInput | number | null
    totalOrders?: IntFieldUpdateOperationsInput | number
    completedOrders?: IntFieldUpdateOperationsInput | number
    cancelledOrders?: IntFieldUpdateOperationsInput | number
    acceptanceRate?: FloatFieldUpdateOperationsInput | number
    currentOrderId?: NullableStringFieldUpdateOperationsInput | string | null
    isApproved?: BoolFieldUpdateOperationsInput | boolean
    isBlocked?: BoolFieldUpdateOperationsInput | boolean
    blockedReason?: NullableStringFieldUpdateOperationsInput | string | null
    city?: NullableStringFieldUpdateOperationsInput | string | null
    state?: NullableStringFieldUpdateOperationsInput | string | null
    pincode?: NullableStringFieldUpdateOperationsInput | string | null
    lastOnlineAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    orders?: OrderUncheckedUpdateManyWithoutAgentNestedInput
    documents?: AgentDocumentUncheckedUpdateManyWithoutAgentNestedInput
    locationHistory?: AgentLocationUncheckedUpdateManyWithoutAgentNestedInput
    tickets?: SupportTicketUncheckedUpdateManyWithoutAgentNestedInput
    ratings?: AgentRatingUncheckedUpdateManyWithoutAgentNestedInput
    walletPayouts?: WalletPayoutUncheckedUpdateManyWithoutAgentNestedInput
    payments?: PaymentUncheckedUpdateManyWithoutAgentNestedInput
    payrolls?: PayrollUncheckedUpdateManyWithoutAgentNestedInput
    schedules?: AgentScheduleUncheckedUpdateManyWithoutAgentNestedInput
  }

  export type WalletTransactionUpsertWithWhereUniqueWithoutAgentWalletInput = {
    where: WalletTransactionWhereUniqueInput
    update: XOR<WalletTransactionUpdateWithoutAgentWalletInput, WalletTransactionUncheckedUpdateWithoutAgentWalletInput>
    create: XOR<WalletTransactionCreateWithoutAgentWalletInput, WalletTransactionUncheckedCreateWithoutAgentWalletInput>
  }

  export type WalletTransactionUpdateWithWhereUniqueWithoutAgentWalletInput = {
    where: WalletTransactionWhereUniqueInput
    data: XOR<WalletTransactionUpdateWithoutAgentWalletInput, WalletTransactionUncheckedUpdateWithoutAgentWalletInput>
  }

  export type WalletTransactionUpdateManyWithWhereWithoutAgentWalletInput = {
    where: WalletTransactionScalarWhereInput
    data: XOR<WalletTransactionUpdateManyMutationInput, WalletTransactionUncheckedUpdateManyWithoutAgentWalletInput>
  }

  export type WalletPayoutUpsertWithWhereUniqueWithoutAgentWalletInput = {
    where: WalletPayoutWhereUniqueInput
    update: XOR<WalletPayoutUpdateWithoutAgentWalletInput, WalletPayoutUncheckedUpdateWithoutAgentWalletInput>
    create: XOR<WalletPayoutCreateWithoutAgentWalletInput, WalletPayoutUncheckedCreateWithoutAgentWalletInput>
  }

  export type WalletPayoutUpdateWithWhereUniqueWithoutAgentWalletInput = {
    where: WalletPayoutWhereUniqueInput
    data: XOR<WalletPayoutUpdateWithoutAgentWalletInput, WalletPayoutUncheckedUpdateWithoutAgentWalletInput>
  }

  export type WalletPayoutUpdateManyWithWhereWithoutAgentWalletInput = {
    where: WalletPayoutScalarWhereInput
    data: XOR<WalletPayoutUpdateManyMutationInput, WalletPayoutUncheckedUpdateManyWithoutAgentWalletInput>
  }

  export type AdminWalletCreateWithoutTransactionsInput = {
    id?: string
    balance?: number
    totalDeposited?: number
    totalPaidOut?: number
    lastUpdated?: Date | string
    createdAt?: Date | string
  }

  export type AdminWalletUncheckedCreateWithoutTransactionsInput = {
    id?: string
    balance?: number
    totalDeposited?: number
    totalPaidOut?: number
    lastUpdated?: Date | string
    createdAt?: Date | string
  }

  export type AdminWalletCreateOrConnectWithoutTransactionsInput = {
    where: AdminWalletWhereUniqueInput
    create: XOR<AdminWalletCreateWithoutTransactionsInput, AdminWalletUncheckedCreateWithoutTransactionsInput>
  }

  export type AgentWalletCreateWithoutTransactionsInput = {
    id?: string
    balance?: number
    totalEarned?: number
    totalPaidOut?: number
    lastPayoutDate?: Date | string | null
    nextPayoutDate?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    agent: AgentCreateNestedOneWithoutWalletInput
    payouts?: WalletPayoutCreateNestedManyWithoutAgentWalletInput
  }

  export type AgentWalletUncheckedCreateWithoutTransactionsInput = {
    id?: string
    agentId: string
    balance?: number
    totalEarned?: number
    totalPaidOut?: number
    lastPayoutDate?: Date | string | null
    nextPayoutDate?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    payouts?: WalletPayoutUncheckedCreateNestedManyWithoutAgentWalletInput
  }

  export type AgentWalletCreateOrConnectWithoutTransactionsInput = {
    where: AgentWalletWhereUniqueInput
    create: XOR<AgentWalletCreateWithoutTransactionsInput, AgentWalletUncheckedCreateWithoutTransactionsInput>
  }

  export type OrderCreateWithoutWalletTransactionsInput = {
    id?: string
    pickupLat: number
    pickupLng: number
    dropLat: number
    dropLng: number
    payoutAmount: number
    orderAmount?: number | null
    platformFee?: number | null
    orderType?: string | null
    commissionRate?: number | null
    priority?: string | null
    status?: $Enums.OrderStatus
    assignedAt?: Date | string | null
    pickedUpAt?: Date | string | null
    deliveredAt?: Date | string | null
    cancelledAt?: Date | string | null
    cancellationReason?: string | null
    estimatedDuration?: number | null
    actualDuration?: number | null
    createdAt?: Date | string
    updatedAt?: Date | string
    barcode?: string | null
    qrCode?: string | null
    deliveryOtp?: string | null
    deliveryQrCode?: string | null
    otpExpiresAt?: Date | string | null
    verifiedAt?: Date | string | null
    verificationMethod?: string | null
    partner: PartnerCreateNestedOneWithoutOrdersInput
    agent?: AgentCreateNestedOneWithoutOrdersInput
    currentAgent?: AgentCreateNestedOneWithoutCurrentOrderInput
    tickets?: SupportTicketCreateNestedManyWithoutOrderInput
    rating?: AgentRatingCreateNestedOneWithoutOrderInput
    payments?: PaymentCreateNestedManyWithoutOrderInput
    partnerRevenue?: PartnerRevenueCreateNestedOneWithoutOrderInput
    platformRevenue?: PlatformRevenueCreateNestedOneWithoutOrderInput
  }

  export type OrderUncheckedCreateWithoutWalletTransactionsInput = {
    id?: string
    partnerId: string
    agentId?: string | null
    pickupLat: number
    pickupLng: number
    dropLat: number
    dropLng: number
    payoutAmount: number
    orderAmount?: number | null
    platformFee?: number | null
    orderType?: string | null
    commissionRate?: number | null
    priority?: string | null
    status?: $Enums.OrderStatus
    assignedAt?: Date | string | null
    pickedUpAt?: Date | string | null
    deliveredAt?: Date | string | null
    cancelledAt?: Date | string | null
    cancellationReason?: string | null
    estimatedDuration?: number | null
    actualDuration?: number | null
    createdAt?: Date | string
    updatedAt?: Date | string
    barcode?: string | null
    qrCode?: string | null
    deliveryOtp?: string | null
    deliveryQrCode?: string | null
    otpExpiresAt?: Date | string | null
    verifiedAt?: Date | string | null
    verificationMethod?: string | null
    currentAgent?: AgentUncheckedCreateNestedOneWithoutCurrentOrderInput
    tickets?: SupportTicketUncheckedCreateNestedManyWithoutOrderInput
    rating?: AgentRatingUncheckedCreateNestedOneWithoutOrderInput
    payments?: PaymentUncheckedCreateNestedManyWithoutOrderInput
    partnerRevenue?: PartnerRevenueUncheckedCreateNestedOneWithoutOrderInput
    platformRevenue?: PlatformRevenueUncheckedCreateNestedOneWithoutOrderInput
  }

  export type OrderCreateOrConnectWithoutWalletTransactionsInput = {
    where: OrderWhereUniqueInput
    create: XOR<OrderCreateWithoutWalletTransactionsInput, OrderUncheckedCreateWithoutWalletTransactionsInput>
  }

  export type AdminWalletUpsertWithoutTransactionsInput = {
    update: XOR<AdminWalletUpdateWithoutTransactionsInput, AdminWalletUncheckedUpdateWithoutTransactionsInput>
    create: XOR<AdminWalletCreateWithoutTransactionsInput, AdminWalletUncheckedCreateWithoutTransactionsInput>
    where?: AdminWalletWhereInput
  }

  export type AdminWalletUpdateToOneWithWhereWithoutTransactionsInput = {
    where?: AdminWalletWhereInput
    data: XOR<AdminWalletUpdateWithoutTransactionsInput, AdminWalletUncheckedUpdateWithoutTransactionsInput>
  }

  export type AdminWalletUpdateWithoutTransactionsInput = {
    id?: StringFieldUpdateOperationsInput | string
    balance?: FloatFieldUpdateOperationsInput | number
    totalDeposited?: FloatFieldUpdateOperationsInput | number
    totalPaidOut?: FloatFieldUpdateOperationsInput | number
    lastUpdated?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AdminWalletUncheckedUpdateWithoutTransactionsInput = {
    id?: StringFieldUpdateOperationsInput | string
    balance?: FloatFieldUpdateOperationsInput | number
    totalDeposited?: FloatFieldUpdateOperationsInput | number
    totalPaidOut?: FloatFieldUpdateOperationsInput | number
    lastUpdated?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AgentWalletUpsertWithoutTransactionsInput = {
    update: XOR<AgentWalletUpdateWithoutTransactionsInput, AgentWalletUncheckedUpdateWithoutTransactionsInput>
    create: XOR<AgentWalletCreateWithoutTransactionsInput, AgentWalletUncheckedCreateWithoutTransactionsInput>
    where?: AgentWalletWhereInput
  }

  export type AgentWalletUpdateToOneWithWhereWithoutTransactionsInput = {
    where?: AgentWalletWhereInput
    data: XOR<AgentWalletUpdateWithoutTransactionsInput, AgentWalletUncheckedUpdateWithoutTransactionsInput>
  }

  export type AgentWalletUpdateWithoutTransactionsInput = {
    id?: StringFieldUpdateOperationsInput | string
    balance?: FloatFieldUpdateOperationsInput | number
    totalEarned?: FloatFieldUpdateOperationsInput | number
    totalPaidOut?: FloatFieldUpdateOperationsInput | number
    lastPayoutDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    nextPayoutDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    agent?: AgentUpdateOneRequiredWithoutWalletNestedInput
    payouts?: WalletPayoutUpdateManyWithoutAgentWalletNestedInput
  }

  export type AgentWalletUncheckedUpdateWithoutTransactionsInput = {
    id?: StringFieldUpdateOperationsInput | string
    agentId?: StringFieldUpdateOperationsInput | string
    balance?: FloatFieldUpdateOperationsInput | number
    totalEarned?: FloatFieldUpdateOperationsInput | number
    totalPaidOut?: FloatFieldUpdateOperationsInput | number
    lastPayoutDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    nextPayoutDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    payouts?: WalletPayoutUncheckedUpdateManyWithoutAgentWalletNestedInput
  }

  export type OrderUpsertWithoutWalletTransactionsInput = {
    update: XOR<OrderUpdateWithoutWalletTransactionsInput, OrderUncheckedUpdateWithoutWalletTransactionsInput>
    create: XOR<OrderCreateWithoutWalletTransactionsInput, OrderUncheckedCreateWithoutWalletTransactionsInput>
    where?: OrderWhereInput
  }

  export type OrderUpdateToOneWithWhereWithoutWalletTransactionsInput = {
    where?: OrderWhereInput
    data: XOR<OrderUpdateWithoutWalletTransactionsInput, OrderUncheckedUpdateWithoutWalletTransactionsInput>
  }

  export type OrderUpdateWithoutWalletTransactionsInput = {
    id?: StringFieldUpdateOperationsInput | string
    pickupLat?: FloatFieldUpdateOperationsInput | number
    pickupLng?: FloatFieldUpdateOperationsInput | number
    dropLat?: FloatFieldUpdateOperationsInput | number
    dropLng?: FloatFieldUpdateOperationsInput | number
    payoutAmount?: FloatFieldUpdateOperationsInput | number
    orderAmount?: NullableFloatFieldUpdateOperationsInput | number | null
    platformFee?: NullableFloatFieldUpdateOperationsInput | number | null
    orderType?: NullableStringFieldUpdateOperationsInput | string | null
    commissionRate?: NullableFloatFieldUpdateOperationsInput | number | null
    priority?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumOrderStatusFieldUpdateOperationsInput | $Enums.OrderStatus
    assignedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    pickedUpAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    deliveredAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    cancelledAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    cancellationReason?: NullableStringFieldUpdateOperationsInput | string | null
    estimatedDuration?: NullableIntFieldUpdateOperationsInput | number | null
    actualDuration?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    barcode?: NullableStringFieldUpdateOperationsInput | string | null
    qrCode?: NullableStringFieldUpdateOperationsInput | string | null
    deliveryOtp?: NullableStringFieldUpdateOperationsInput | string | null
    deliveryQrCode?: NullableStringFieldUpdateOperationsInput | string | null
    otpExpiresAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    verifiedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    verificationMethod?: NullableStringFieldUpdateOperationsInput | string | null
    partner?: PartnerUpdateOneRequiredWithoutOrdersNestedInput
    agent?: AgentUpdateOneWithoutOrdersNestedInput
    currentAgent?: AgentUpdateOneWithoutCurrentOrderNestedInput
    tickets?: SupportTicketUpdateManyWithoutOrderNestedInput
    rating?: AgentRatingUpdateOneWithoutOrderNestedInput
    payments?: PaymentUpdateManyWithoutOrderNestedInput
    partnerRevenue?: PartnerRevenueUpdateOneWithoutOrderNestedInput
    platformRevenue?: PlatformRevenueUpdateOneWithoutOrderNestedInput
  }

  export type OrderUncheckedUpdateWithoutWalletTransactionsInput = {
    id?: StringFieldUpdateOperationsInput | string
    partnerId?: StringFieldUpdateOperationsInput | string
    agentId?: NullableStringFieldUpdateOperationsInput | string | null
    pickupLat?: FloatFieldUpdateOperationsInput | number
    pickupLng?: FloatFieldUpdateOperationsInput | number
    dropLat?: FloatFieldUpdateOperationsInput | number
    dropLng?: FloatFieldUpdateOperationsInput | number
    payoutAmount?: FloatFieldUpdateOperationsInput | number
    orderAmount?: NullableFloatFieldUpdateOperationsInput | number | null
    platformFee?: NullableFloatFieldUpdateOperationsInput | number | null
    orderType?: NullableStringFieldUpdateOperationsInput | string | null
    commissionRate?: NullableFloatFieldUpdateOperationsInput | number | null
    priority?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumOrderStatusFieldUpdateOperationsInput | $Enums.OrderStatus
    assignedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    pickedUpAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    deliveredAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    cancelledAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    cancellationReason?: NullableStringFieldUpdateOperationsInput | string | null
    estimatedDuration?: NullableIntFieldUpdateOperationsInput | number | null
    actualDuration?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    barcode?: NullableStringFieldUpdateOperationsInput | string | null
    qrCode?: NullableStringFieldUpdateOperationsInput | string | null
    deliveryOtp?: NullableStringFieldUpdateOperationsInput | string | null
    deliveryQrCode?: NullableStringFieldUpdateOperationsInput | string | null
    otpExpiresAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    verifiedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    verificationMethod?: NullableStringFieldUpdateOperationsInput | string | null
    currentAgent?: AgentUncheckedUpdateOneWithoutCurrentOrderNestedInput
    tickets?: SupportTicketUncheckedUpdateManyWithoutOrderNestedInput
    rating?: AgentRatingUncheckedUpdateOneWithoutOrderNestedInput
    payments?: PaymentUncheckedUpdateManyWithoutOrderNestedInput
    partnerRevenue?: PartnerRevenueUncheckedUpdateOneWithoutOrderNestedInput
    platformRevenue?: PlatformRevenueUncheckedUpdateOneWithoutOrderNestedInput
  }

  export type AgentWalletCreateWithoutPayoutsInput = {
    id?: string
    balance?: number
    totalEarned?: number
    totalPaidOut?: number
    lastPayoutDate?: Date | string | null
    nextPayoutDate?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    agent: AgentCreateNestedOneWithoutWalletInput
    transactions?: WalletTransactionCreateNestedManyWithoutAgentWalletInput
  }

  export type AgentWalletUncheckedCreateWithoutPayoutsInput = {
    id?: string
    agentId: string
    balance?: number
    totalEarned?: number
    totalPaidOut?: number
    lastPayoutDate?: Date | string | null
    nextPayoutDate?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    transactions?: WalletTransactionUncheckedCreateNestedManyWithoutAgentWalletInput
  }

  export type AgentWalletCreateOrConnectWithoutPayoutsInput = {
    where: AgentWalletWhereUniqueInput
    create: XOR<AgentWalletCreateWithoutPayoutsInput, AgentWalletUncheckedCreateWithoutPayoutsInput>
  }

  export type AgentCreateWithoutWalletPayoutsInput = {
    id?: string
    vehicleType: $Enums.VehicleType
    status?: $Enums.AgentStatus
    rating?: number | null
    totalOrders?: number
    completedOrders?: number
    cancelledOrders?: number
    acceptanceRate?: number
    isApproved?: boolean
    isBlocked?: boolean
    blockedReason?: string | null
    city?: string | null
    state?: string | null
    pincode?: string | null
    lastOnlineAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    user: UserCreateNestedOneWithoutAgentInput
    orders?: OrderCreateNestedManyWithoutAgentInput
    currentOrder?: OrderCreateNestedOneWithoutCurrentAgentInput
    documents?: AgentDocumentCreateNestedManyWithoutAgentInput
    locationHistory?: AgentLocationCreateNestedManyWithoutAgentInput
    tickets?: SupportTicketCreateNestedManyWithoutAgentInput
    ratings?: AgentRatingCreateNestedManyWithoutAgentInput
    wallet?: AgentWalletCreateNestedOneWithoutAgentInput
    payments?: PaymentCreateNestedManyWithoutAgentInput
    payrolls?: PayrollCreateNestedManyWithoutAgentInput
    schedules?: AgentScheduleCreateNestedManyWithoutAgentInput
  }

  export type AgentUncheckedCreateWithoutWalletPayoutsInput = {
    id?: string
    userId: string
    vehicleType: $Enums.VehicleType
    status?: $Enums.AgentStatus
    rating?: number | null
    totalOrders?: number
    completedOrders?: number
    cancelledOrders?: number
    acceptanceRate?: number
    currentOrderId?: string | null
    isApproved?: boolean
    isBlocked?: boolean
    blockedReason?: string | null
    city?: string | null
    state?: string | null
    pincode?: string | null
    lastOnlineAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    orders?: OrderUncheckedCreateNestedManyWithoutAgentInput
    documents?: AgentDocumentUncheckedCreateNestedManyWithoutAgentInput
    locationHistory?: AgentLocationUncheckedCreateNestedManyWithoutAgentInput
    tickets?: SupportTicketUncheckedCreateNestedManyWithoutAgentInput
    ratings?: AgentRatingUncheckedCreateNestedManyWithoutAgentInput
    wallet?: AgentWalletUncheckedCreateNestedOneWithoutAgentInput
    payments?: PaymentUncheckedCreateNestedManyWithoutAgentInput
    payrolls?: PayrollUncheckedCreateNestedManyWithoutAgentInput
    schedules?: AgentScheduleUncheckedCreateNestedManyWithoutAgentInput
  }

  export type AgentCreateOrConnectWithoutWalletPayoutsInput = {
    where: AgentWhereUniqueInput
    create: XOR<AgentCreateWithoutWalletPayoutsInput, AgentUncheckedCreateWithoutWalletPayoutsInput>
  }

  export type AgentWalletUpsertWithoutPayoutsInput = {
    update: XOR<AgentWalletUpdateWithoutPayoutsInput, AgentWalletUncheckedUpdateWithoutPayoutsInput>
    create: XOR<AgentWalletCreateWithoutPayoutsInput, AgentWalletUncheckedCreateWithoutPayoutsInput>
    where?: AgentWalletWhereInput
  }

  export type AgentWalletUpdateToOneWithWhereWithoutPayoutsInput = {
    where?: AgentWalletWhereInput
    data: XOR<AgentWalletUpdateWithoutPayoutsInput, AgentWalletUncheckedUpdateWithoutPayoutsInput>
  }

  export type AgentWalletUpdateWithoutPayoutsInput = {
    id?: StringFieldUpdateOperationsInput | string
    balance?: FloatFieldUpdateOperationsInput | number
    totalEarned?: FloatFieldUpdateOperationsInput | number
    totalPaidOut?: FloatFieldUpdateOperationsInput | number
    lastPayoutDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    nextPayoutDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    agent?: AgentUpdateOneRequiredWithoutWalletNestedInput
    transactions?: WalletTransactionUpdateManyWithoutAgentWalletNestedInput
  }

  export type AgentWalletUncheckedUpdateWithoutPayoutsInput = {
    id?: StringFieldUpdateOperationsInput | string
    agentId?: StringFieldUpdateOperationsInput | string
    balance?: FloatFieldUpdateOperationsInput | number
    totalEarned?: FloatFieldUpdateOperationsInput | number
    totalPaidOut?: FloatFieldUpdateOperationsInput | number
    lastPayoutDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    nextPayoutDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    transactions?: WalletTransactionUncheckedUpdateManyWithoutAgentWalletNestedInput
  }

  export type AgentUpsertWithoutWalletPayoutsInput = {
    update: XOR<AgentUpdateWithoutWalletPayoutsInput, AgentUncheckedUpdateWithoutWalletPayoutsInput>
    create: XOR<AgentCreateWithoutWalletPayoutsInput, AgentUncheckedCreateWithoutWalletPayoutsInput>
    where?: AgentWhereInput
  }

  export type AgentUpdateToOneWithWhereWithoutWalletPayoutsInput = {
    where?: AgentWhereInput
    data: XOR<AgentUpdateWithoutWalletPayoutsInput, AgentUncheckedUpdateWithoutWalletPayoutsInput>
  }

  export type AgentUpdateWithoutWalletPayoutsInput = {
    id?: StringFieldUpdateOperationsInput | string
    vehicleType?: EnumVehicleTypeFieldUpdateOperationsInput | $Enums.VehicleType
    status?: EnumAgentStatusFieldUpdateOperationsInput | $Enums.AgentStatus
    rating?: NullableFloatFieldUpdateOperationsInput | number | null
    totalOrders?: IntFieldUpdateOperationsInput | number
    completedOrders?: IntFieldUpdateOperationsInput | number
    cancelledOrders?: IntFieldUpdateOperationsInput | number
    acceptanceRate?: FloatFieldUpdateOperationsInput | number
    isApproved?: BoolFieldUpdateOperationsInput | boolean
    isBlocked?: BoolFieldUpdateOperationsInput | boolean
    blockedReason?: NullableStringFieldUpdateOperationsInput | string | null
    city?: NullableStringFieldUpdateOperationsInput | string | null
    state?: NullableStringFieldUpdateOperationsInput | string | null
    pincode?: NullableStringFieldUpdateOperationsInput | string | null
    lastOnlineAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneRequiredWithoutAgentNestedInput
    orders?: OrderUpdateManyWithoutAgentNestedInput
    currentOrder?: OrderUpdateOneWithoutCurrentAgentNestedInput
    documents?: AgentDocumentUpdateManyWithoutAgentNestedInput
    locationHistory?: AgentLocationUpdateManyWithoutAgentNestedInput
    tickets?: SupportTicketUpdateManyWithoutAgentNestedInput
    ratings?: AgentRatingUpdateManyWithoutAgentNestedInput
    wallet?: AgentWalletUpdateOneWithoutAgentNestedInput
    payments?: PaymentUpdateManyWithoutAgentNestedInput
    payrolls?: PayrollUpdateManyWithoutAgentNestedInput
    schedules?: AgentScheduleUpdateManyWithoutAgentNestedInput
  }

  export type AgentUncheckedUpdateWithoutWalletPayoutsInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    vehicleType?: EnumVehicleTypeFieldUpdateOperationsInput | $Enums.VehicleType
    status?: EnumAgentStatusFieldUpdateOperationsInput | $Enums.AgentStatus
    rating?: NullableFloatFieldUpdateOperationsInput | number | null
    totalOrders?: IntFieldUpdateOperationsInput | number
    completedOrders?: IntFieldUpdateOperationsInput | number
    cancelledOrders?: IntFieldUpdateOperationsInput | number
    acceptanceRate?: FloatFieldUpdateOperationsInput | number
    currentOrderId?: NullableStringFieldUpdateOperationsInput | string | null
    isApproved?: BoolFieldUpdateOperationsInput | boolean
    isBlocked?: BoolFieldUpdateOperationsInput | boolean
    blockedReason?: NullableStringFieldUpdateOperationsInput | string | null
    city?: NullableStringFieldUpdateOperationsInput | string | null
    state?: NullableStringFieldUpdateOperationsInput | string | null
    pincode?: NullableStringFieldUpdateOperationsInput | string | null
    lastOnlineAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    orders?: OrderUncheckedUpdateManyWithoutAgentNestedInput
    documents?: AgentDocumentUncheckedUpdateManyWithoutAgentNestedInput
    locationHistory?: AgentLocationUncheckedUpdateManyWithoutAgentNestedInput
    tickets?: SupportTicketUncheckedUpdateManyWithoutAgentNestedInput
    ratings?: AgentRatingUncheckedUpdateManyWithoutAgentNestedInput
    wallet?: AgentWalletUncheckedUpdateOneWithoutAgentNestedInput
    payments?: PaymentUncheckedUpdateManyWithoutAgentNestedInput
    payrolls?: PayrollUncheckedUpdateManyWithoutAgentNestedInput
    schedules?: AgentScheduleUncheckedUpdateManyWithoutAgentNestedInput
  }

  export type UserCreateWithoutUserNotificationsInput = {
    id?: string
    name: string
    email: string
    phone: string
    passwordHash: string
    role: $Enums.UserRole
    emailVerified?: Date | string | null
    phoneVerified?: boolean
    profilePicture?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    agent?: AgentCreateNestedOneWithoutUserInput
    partner?: PartnerCreateNestedOneWithoutUserInput
    notifications?: NotificationTokenCreateNestedManyWithoutUserInput
    tickets?: SupportTicketCreateNestedManyWithoutUserInput
  }

  export type UserUncheckedCreateWithoutUserNotificationsInput = {
    id?: string
    name: string
    email: string
    phone: string
    passwordHash: string
    role: $Enums.UserRole
    emailVerified?: Date | string | null
    phoneVerified?: boolean
    profilePicture?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    agent?: AgentUncheckedCreateNestedOneWithoutUserInput
    partner?: PartnerUncheckedCreateNestedOneWithoutUserInput
    notifications?: NotificationTokenUncheckedCreateNestedManyWithoutUserInput
    tickets?: SupportTicketUncheckedCreateNestedManyWithoutUserInput
  }

  export type UserCreateOrConnectWithoutUserNotificationsInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutUserNotificationsInput, UserUncheckedCreateWithoutUserNotificationsInput>
  }

  export type UserUpsertWithoutUserNotificationsInput = {
    update: XOR<UserUpdateWithoutUserNotificationsInput, UserUncheckedUpdateWithoutUserNotificationsInput>
    create: XOR<UserCreateWithoutUserNotificationsInput, UserUncheckedCreateWithoutUserNotificationsInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutUserNotificationsInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutUserNotificationsInput, UserUncheckedUpdateWithoutUserNotificationsInput>
  }

  export type UserUpdateWithoutUserNotificationsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    phone?: StringFieldUpdateOperationsInput | string
    passwordHash?: StringFieldUpdateOperationsInput | string
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    emailVerified?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    phoneVerified?: BoolFieldUpdateOperationsInput | boolean
    profilePicture?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    agent?: AgentUpdateOneWithoutUserNestedInput
    partner?: PartnerUpdateOneWithoutUserNestedInput
    notifications?: NotificationTokenUpdateManyWithoutUserNestedInput
    tickets?: SupportTicketUpdateManyWithoutUserNestedInput
  }

  export type UserUncheckedUpdateWithoutUserNotificationsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    phone?: StringFieldUpdateOperationsInput | string
    passwordHash?: StringFieldUpdateOperationsInput | string
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    emailVerified?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    phoneVerified?: BoolFieldUpdateOperationsInput | boolean
    profilePicture?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    agent?: AgentUncheckedUpdateOneWithoutUserNestedInput
    partner?: PartnerUncheckedUpdateOneWithoutUserNestedInput
    notifications?: NotificationTokenUncheckedUpdateManyWithoutUserNestedInput
    tickets?: SupportTicketUncheckedUpdateManyWithoutUserNestedInput
  }

  export type OrderCreateWithoutRatingInput = {
    id?: string
    pickupLat: number
    pickupLng: number
    dropLat: number
    dropLng: number
    payoutAmount: number
    orderAmount?: number | null
    platformFee?: number | null
    orderType?: string | null
    commissionRate?: number | null
    priority?: string | null
    status?: $Enums.OrderStatus
    assignedAt?: Date | string | null
    pickedUpAt?: Date | string | null
    deliveredAt?: Date | string | null
    cancelledAt?: Date | string | null
    cancellationReason?: string | null
    estimatedDuration?: number | null
    actualDuration?: number | null
    createdAt?: Date | string
    updatedAt?: Date | string
    barcode?: string | null
    qrCode?: string | null
    deliveryOtp?: string | null
    deliveryQrCode?: string | null
    otpExpiresAt?: Date | string | null
    verifiedAt?: Date | string | null
    verificationMethod?: string | null
    partner: PartnerCreateNestedOneWithoutOrdersInput
    agent?: AgentCreateNestedOneWithoutOrdersInput
    currentAgent?: AgentCreateNestedOneWithoutCurrentOrderInput
    tickets?: SupportTicketCreateNestedManyWithoutOrderInput
    payments?: PaymentCreateNestedManyWithoutOrderInput
    partnerRevenue?: PartnerRevenueCreateNestedOneWithoutOrderInput
    platformRevenue?: PlatformRevenueCreateNestedOneWithoutOrderInput
    walletTransactions?: WalletTransactionCreateNestedManyWithoutOrderInput
  }

  export type OrderUncheckedCreateWithoutRatingInput = {
    id?: string
    partnerId: string
    agentId?: string | null
    pickupLat: number
    pickupLng: number
    dropLat: number
    dropLng: number
    payoutAmount: number
    orderAmount?: number | null
    platformFee?: number | null
    orderType?: string | null
    commissionRate?: number | null
    priority?: string | null
    status?: $Enums.OrderStatus
    assignedAt?: Date | string | null
    pickedUpAt?: Date | string | null
    deliveredAt?: Date | string | null
    cancelledAt?: Date | string | null
    cancellationReason?: string | null
    estimatedDuration?: number | null
    actualDuration?: number | null
    createdAt?: Date | string
    updatedAt?: Date | string
    barcode?: string | null
    qrCode?: string | null
    deliveryOtp?: string | null
    deliveryQrCode?: string | null
    otpExpiresAt?: Date | string | null
    verifiedAt?: Date | string | null
    verificationMethod?: string | null
    currentAgent?: AgentUncheckedCreateNestedOneWithoutCurrentOrderInput
    tickets?: SupportTicketUncheckedCreateNestedManyWithoutOrderInput
    payments?: PaymentUncheckedCreateNestedManyWithoutOrderInput
    partnerRevenue?: PartnerRevenueUncheckedCreateNestedOneWithoutOrderInput
    platformRevenue?: PlatformRevenueUncheckedCreateNestedOneWithoutOrderInput
    walletTransactions?: WalletTransactionUncheckedCreateNestedManyWithoutOrderInput
  }

  export type OrderCreateOrConnectWithoutRatingInput = {
    where: OrderWhereUniqueInput
    create: XOR<OrderCreateWithoutRatingInput, OrderUncheckedCreateWithoutRatingInput>
  }

  export type AgentCreateWithoutRatingsInput = {
    id?: string
    vehicleType: $Enums.VehicleType
    status?: $Enums.AgentStatus
    rating?: number | null
    totalOrders?: number
    completedOrders?: number
    cancelledOrders?: number
    acceptanceRate?: number
    isApproved?: boolean
    isBlocked?: boolean
    blockedReason?: string | null
    city?: string | null
    state?: string | null
    pincode?: string | null
    lastOnlineAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    user: UserCreateNestedOneWithoutAgentInput
    orders?: OrderCreateNestedManyWithoutAgentInput
    currentOrder?: OrderCreateNestedOneWithoutCurrentAgentInput
    documents?: AgentDocumentCreateNestedManyWithoutAgentInput
    locationHistory?: AgentLocationCreateNestedManyWithoutAgentInput
    tickets?: SupportTicketCreateNestedManyWithoutAgentInput
    wallet?: AgentWalletCreateNestedOneWithoutAgentInput
    walletPayouts?: WalletPayoutCreateNestedManyWithoutAgentInput
    payments?: PaymentCreateNestedManyWithoutAgentInput
    payrolls?: PayrollCreateNestedManyWithoutAgentInput
    schedules?: AgentScheduleCreateNestedManyWithoutAgentInput
  }

  export type AgentUncheckedCreateWithoutRatingsInput = {
    id?: string
    userId: string
    vehicleType: $Enums.VehicleType
    status?: $Enums.AgentStatus
    rating?: number | null
    totalOrders?: number
    completedOrders?: number
    cancelledOrders?: number
    acceptanceRate?: number
    currentOrderId?: string | null
    isApproved?: boolean
    isBlocked?: boolean
    blockedReason?: string | null
    city?: string | null
    state?: string | null
    pincode?: string | null
    lastOnlineAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    orders?: OrderUncheckedCreateNestedManyWithoutAgentInput
    documents?: AgentDocumentUncheckedCreateNestedManyWithoutAgentInput
    locationHistory?: AgentLocationUncheckedCreateNestedManyWithoutAgentInput
    tickets?: SupportTicketUncheckedCreateNestedManyWithoutAgentInput
    wallet?: AgentWalletUncheckedCreateNestedOneWithoutAgentInput
    walletPayouts?: WalletPayoutUncheckedCreateNestedManyWithoutAgentInput
    payments?: PaymentUncheckedCreateNestedManyWithoutAgentInput
    payrolls?: PayrollUncheckedCreateNestedManyWithoutAgentInput
    schedules?: AgentScheduleUncheckedCreateNestedManyWithoutAgentInput
  }

  export type AgentCreateOrConnectWithoutRatingsInput = {
    where: AgentWhereUniqueInput
    create: XOR<AgentCreateWithoutRatingsInput, AgentUncheckedCreateWithoutRatingsInput>
  }

  export type PartnerCreateWithoutAgentRatingsInput = {
    id?: string
    companyName: string
    apiKey: string
    webhookUrl?: string | null
    isActive?: boolean
    city?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    user: UserCreateNestedOneWithoutPartnerInput
    orders?: OrderCreateNestedManyWithoutPartnerInput
    tickets?: SupportTicketCreateNestedManyWithoutPartnerInput
    dailyStats?: PartnerDailyStatsCreateNestedManyWithoutPartnerInput
    partnerRevenues?: PartnerRevenueCreateNestedManyWithoutPartnerInput
    platformRevenues?: PlatformRevenueCreateNestedManyWithoutPartnerInput
  }

  export type PartnerUncheckedCreateWithoutAgentRatingsInput = {
    id?: string
    userId: string
    companyName: string
    apiKey: string
    webhookUrl?: string | null
    isActive?: boolean
    city?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    orders?: OrderUncheckedCreateNestedManyWithoutPartnerInput
    tickets?: SupportTicketUncheckedCreateNestedManyWithoutPartnerInput
    dailyStats?: PartnerDailyStatsUncheckedCreateNestedManyWithoutPartnerInput
    partnerRevenues?: PartnerRevenueUncheckedCreateNestedManyWithoutPartnerInput
    platformRevenues?: PlatformRevenueUncheckedCreateNestedManyWithoutPartnerInput
  }

  export type PartnerCreateOrConnectWithoutAgentRatingsInput = {
    where: PartnerWhereUniqueInput
    create: XOR<PartnerCreateWithoutAgentRatingsInput, PartnerUncheckedCreateWithoutAgentRatingsInput>
  }

  export type OrderUpsertWithoutRatingInput = {
    update: XOR<OrderUpdateWithoutRatingInput, OrderUncheckedUpdateWithoutRatingInput>
    create: XOR<OrderCreateWithoutRatingInput, OrderUncheckedCreateWithoutRatingInput>
    where?: OrderWhereInput
  }

  export type OrderUpdateToOneWithWhereWithoutRatingInput = {
    where?: OrderWhereInput
    data: XOR<OrderUpdateWithoutRatingInput, OrderUncheckedUpdateWithoutRatingInput>
  }

  export type OrderUpdateWithoutRatingInput = {
    id?: StringFieldUpdateOperationsInput | string
    pickupLat?: FloatFieldUpdateOperationsInput | number
    pickupLng?: FloatFieldUpdateOperationsInput | number
    dropLat?: FloatFieldUpdateOperationsInput | number
    dropLng?: FloatFieldUpdateOperationsInput | number
    payoutAmount?: FloatFieldUpdateOperationsInput | number
    orderAmount?: NullableFloatFieldUpdateOperationsInput | number | null
    platformFee?: NullableFloatFieldUpdateOperationsInput | number | null
    orderType?: NullableStringFieldUpdateOperationsInput | string | null
    commissionRate?: NullableFloatFieldUpdateOperationsInput | number | null
    priority?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumOrderStatusFieldUpdateOperationsInput | $Enums.OrderStatus
    assignedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    pickedUpAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    deliveredAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    cancelledAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    cancellationReason?: NullableStringFieldUpdateOperationsInput | string | null
    estimatedDuration?: NullableIntFieldUpdateOperationsInput | number | null
    actualDuration?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    barcode?: NullableStringFieldUpdateOperationsInput | string | null
    qrCode?: NullableStringFieldUpdateOperationsInput | string | null
    deliveryOtp?: NullableStringFieldUpdateOperationsInput | string | null
    deliveryQrCode?: NullableStringFieldUpdateOperationsInput | string | null
    otpExpiresAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    verifiedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    verificationMethod?: NullableStringFieldUpdateOperationsInput | string | null
    partner?: PartnerUpdateOneRequiredWithoutOrdersNestedInput
    agent?: AgentUpdateOneWithoutOrdersNestedInput
    currentAgent?: AgentUpdateOneWithoutCurrentOrderNestedInput
    tickets?: SupportTicketUpdateManyWithoutOrderNestedInput
    payments?: PaymentUpdateManyWithoutOrderNestedInput
    partnerRevenue?: PartnerRevenueUpdateOneWithoutOrderNestedInput
    platformRevenue?: PlatformRevenueUpdateOneWithoutOrderNestedInput
    walletTransactions?: WalletTransactionUpdateManyWithoutOrderNestedInput
  }

  export type OrderUncheckedUpdateWithoutRatingInput = {
    id?: StringFieldUpdateOperationsInput | string
    partnerId?: StringFieldUpdateOperationsInput | string
    agentId?: NullableStringFieldUpdateOperationsInput | string | null
    pickupLat?: FloatFieldUpdateOperationsInput | number
    pickupLng?: FloatFieldUpdateOperationsInput | number
    dropLat?: FloatFieldUpdateOperationsInput | number
    dropLng?: FloatFieldUpdateOperationsInput | number
    payoutAmount?: FloatFieldUpdateOperationsInput | number
    orderAmount?: NullableFloatFieldUpdateOperationsInput | number | null
    platformFee?: NullableFloatFieldUpdateOperationsInput | number | null
    orderType?: NullableStringFieldUpdateOperationsInput | string | null
    commissionRate?: NullableFloatFieldUpdateOperationsInput | number | null
    priority?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumOrderStatusFieldUpdateOperationsInput | $Enums.OrderStatus
    assignedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    pickedUpAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    deliveredAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    cancelledAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    cancellationReason?: NullableStringFieldUpdateOperationsInput | string | null
    estimatedDuration?: NullableIntFieldUpdateOperationsInput | number | null
    actualDuration?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    barcode?: NullableStringFieldUpdateOperationsInput | string | null
    qrCode?: NullableStringFieldUpdateOperationsInput | string | null
    deliveryOtp?: NullableStringFieldUpdateOperationsInput | string | null
    deliveryQrCode?: NullableStringFieldUpdateOperationsInput | string | null
    otpExpiresAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    verifiedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    verificationMethod?: NullableStringFieldUpdateOperationsInput | string | null
    currentAgent?: AgentUncheckedUpdateOneWithoutCurrentOrderNestedInput
    tickets?: SupportTicketUncheckedUpdateManyWithoutOrderNestedInput
    payments?: PaymentUncheckedUpdateManyWithoutOrderNestedInput
    partnerRevenue?: PartnerRevenueUncheckedUpdateOneWithoutOrderNestedInput
    platformRevenue?: PlatformRevenueUncheckedUpdateOneWithoutOrderNestedInput
    walletTransactions?: WalletTransactionUncheckedUpdateManyWithoutOrderNestedInput
  }

  export type AgentUpsertWithoutRatingsInput = {
    update: XOR<AgentUpdateWithoutRatingsInput, AgentUncheckedUpdateWithoutRatingsInput>
    create: XOR<AgentCreateWithoutRatingsInput, AgentUncheckedCreateWithoutRatingsInput>
    where?: AgentWhereInput
  }

  export type AgentUpdateToOneWithWhereWithoutRatingsInput = {
    where?: AgentWhereInput
    data: XOR<AgentUpdateWithoutRatingsInput, AgentUncheckedUpdateWithoutRatingsInput>
  }

  export type AgentUpdateWithoutRatingsInput = {
    id?: StringFieldUpdateOperationsInput | string
    vehicleType?: EnumVehicleTypeFieldUpdateOperationsInput | $Enums.VehicleType
    status?: EnumAgentStatusFieldUpdateOperationsInput | $Enums.AgentStatus
    rating?: NullableFloatFieldUpdateOperationsInput | number | null
    totalOrders?: IntFieldUpdateOperationsInput | number
    completedOrders?: IntFieldUpdateOperationsInput | number
    cancelledOrders?: IntFieldUpdateOperationsInput | number
    acceptanceRate?: FloatFieldUpdateOperationsInput | number
    isApproved?: BoolFieldUpdateOperationsInput | boolean
    isBlocked?: BoolFieldUpdateOperationsInput | boolean
    blockedReason?: NullableStringFieldUpdateOperationsInput | string | null
    city?: NullableStringFieldUpdateOperationsInput | string | null
    state?: NullableStringFieldUpdateOperationsInput | string | null
    pincode?: NullableStringFieldUpdateOperationsInput | string | null
    lastOnlineAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneRequiredWithoutAgentNestedInput
    orders?: OrderUpdateManyWithoutAgentNestedInput
    currentOrder?: OrderUpdateOneWithoutCurrentAgentNestedInput
    documents?: AgentDocumentUpdateManyWithoutAgentNestedInput
    locationHistory?: AgentLocationUpdateManyWithoutAgentNestedInput
    tickets?: SupportTicketUpdateManyWithoutAgentNestedInput
    wallet?: AgentWalletUpdateOneWithoutAgentNestedInput
    walletPayouts?: WalletPayoutUpdateManyWithoutAgentNestedInput
    payments?: PaymentUpdateManyWithoutAgentNestedInput
    payrolls?: PayrollUpdateManyWithoutAgentNestedInput
    schedules?: AgentScheduleUpdateManyWithoutAgentNestedInput
  }

  export type AgentUncheckedUpdateWithoutRatingsInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    vehicleType?: EnumVehicleTypeFieldUpdateOperationsInput | $Enums.VehicleType
    status?: EnumAgentStatusFieldUpdateOperationsInput | $Enums.AgentStatus
    rating?: NullableFloatFieldUpdateOperationsInput | number | null
    totalOrders?: IntFieldUpdateOperationsInput | number
    completedOrders?: IntFieldUpdateOperationsInput | number
    cancelledOrders?: IntFieldUpdateOperationsInput | number
    acceptanceRate?: FloatFieldUpdateOperationsInput | number
    currentOrderId?: NullableStringFieldUpdateOperationsInput | string | null
    isApproved?: BoolFieldUpdateOperationsInput | boolean
    isBlocked?: BoolFieldUpdateOperationsInput | boolean
    blockedReason?: NullableStringFieldUpdateOperationsInput | string | null
    city?: NullableStringFieldUpdateOperationsInput | string | null
    state?: NullableStringFieldUpdateOperationsInput | string | null
    pincode?: NullableStringFieldUpdateOperationsInput | string | null
    lastOnlineAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    orders?: OrderUncheckedUpdateManyWithoutAgentNestedInput
    documents?: AgentDocumentUncheckedUpdateManyWithoutAgentNestedInput
    locationHistory?: AgentLocationUncheckedUpdateManyWithoutAgentNestedInput
    tickets?: SupportTicketUncheckedUpdateManyWithoutAgentNestedInput
    wallet?: AgentWalletUncheckedUpdateOneWithoutAgentNestedInput
    walletPayouts?: WalletPayoutUncheckedUpdateManyWithoutAgentNestedInput
    payments?: PaymentUncheckedUpdateManyWithoutAgentNestedInput
    payrolls?: PayrollUncheckedUpdateManyWithoutAgentNestedInput
    schedules?: AgentScheduleUncheckedUpdateManyWithoutAgentNestedInput
  }

  export type PartnerUpsertWithoutAgentRatingsInput = {
    update: XOR<PartnerUpdateWithoutAgentRatingsInput, PartnerUncheckedUpdateWithoutAgentRatingsInput>
    create: XOR<PartnerCreateWithoutAgentRatingsInput, PartnerUncheckedCreateWithoutAgentRatingsInput>
    where?: PartnerWhereInput
  }

  export type PartnerUpdateToOneWithWhereWithoutAgentRatingsInput = {
    where?: PartnerWhereInput
    data: XOR<PartnerUpdateWithoutAgentRatingsInput, PartnerUncheckedUpdateWithoutAgentRatingsInput>
  }

  export type PartnerUpdateWithoutAgentRatingsInput = {
    id?: StringFieldUpdateOperationsInput | string
    companyName?: StringFieldUpdateOperationsInput | string
    apiKey?: StringFieldUpdateOperationsInput | string
    webhookUrl?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    city?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneRequiredWithoutPartnerNestedInput
    orders?: OrderUpdateManyWithoutPartnerNestedInput
    tickets?: SupportTicketUpdateManyWithoutPartnerNestedInput
    dailyStats?: PartnerDailyStatsUpdateManyWithoutPartnerNestedInput
    partnerRevenues?: PartnerRevenueUpdateManyWithoutPartnerNestedInput
    platformRevenues?: PlatformRevenueUpdateManyWithoutPartnerNestedInput
  }

  export type PartnerUncheckedUpdateWithoutAgentRatingsInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    companyName?: StringFieldUpdateOperationsInput | string
    apiKey?: StringFieldUpdateOperationsInput | string
    webhookUrl?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    city?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    orders?: OrderUncheckedUpdateManyWithoutPartnerNestedInput
    tickets?: SupportTicketUncheckedUpdateManyWithoutPartnerNestedInput
    dailyStats?: PartnerDailyStatsUncheckedUpdateManyWithoutPartnerNestedInput
    partnerRevenues?: PartnerRevenueUncheckedUpdateManyWithoutPartnerNestedInput
    platformRevenues?: PlatformRevenueUncheckedUpdateManyWithoutPartnerNestedInput
  }

  export type AgentCreateWithoutPaymentsInput = {
    id?: string
    vehicleType: $Enums.VehicleType
    status?: $Enums.AgentStatus
    rating?: number | null
    totalOrders?: number
    completedOrders?: number
    cancelledOrders?: number
    acceptanceRate?: number
    isApproved?: boolean
    isBlocked?: boolean
    blockedReason?: string | null
    city?: string | null
    state?: string | null
    pincode?: string | null
    lastOnlineAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    user: UserCreateNestedOneWithoutAgentInput
    orders?: OrderCreateNestedManyWithoutAgentInput
    currentOrder?: OrderCreateNestedOneWithoutCurrentAgentInput
    documents?: AgentDocumentCreateNestedManyWithoutAgentInput
    locationHistory?: AgentLocationCreateNestedManyWithoutAgentInput
    tickets?: SupportTicketCreateNestedManyWithoutAgentInput
    ratings?: AgentRatingCreateNestedManyWithoutAgentInput
    wallet?: AgentWalletCreateNestedOneWithoutAgentInput
    walletPayouts?: WalletPayoutCreateNestedManyWithoutAgentInput
    payrolls?: PayrollCreateNestedManyWithoutAgentInput
    schedules?: AgentScheduleCreateNestedManyWithoutAgentInput
  }

  export type AgentUncheckedCreateWithoutPaymentsInput = {
    id?: string
    userId: string
    vehicleType: $Enums.VehicleType
    status?: $Enums.AgentStatus
    rating?: number | null
    totalOrders?: number
    completedOrders?: number
    cancelledOrders?: number
    acceptanceRate?: number
    currentOrderId?: string | null
    isApproved?: boolean
    isBlocked?: boolean
    blockedReason?: string | null
    city?: string | null
    state?: string | null
    pincode?: string | null
    lastOnlineAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    orders?: OrderUncheckedCreateNestedManyWithoutAgentInput
    documents?: AgentDocumentUncheckedCreateNestedManyWithoutAgentInput
    locationHistory?: AgentLocationUncheckedCreateNestedManyWithoutAgentInput
    tickets?: SupportTicketUncheckedCreateNestedManyWithoutAgentInput
    ratings?: AgentRatingUncheckedCreateNestedManyWithoutAgentInput
    wallet?: AgentWalletUncheckedCreateNestedOneWithoutAgentInput
    walletPayouts?: WalletPayoutUncheckedCreateNestedManyWithoutAgentInput
    payrolls?: PayrollUncheckedCreateNestedManyWithoutAgentInput
    schedules?: AgentScheduleUncheckedCreateNestedManyWithoutAgentInput
  }

  export type AgentCreateOrConnectWithoutPaymentsInput = {
    where: AgentWhereUniqueInput
    create: XOR<AgentCreateWithoutPaymentsInput, AgentUncheckedCreateWithoutPaymentsInput>
  }

  export type OrderCreateWithoutPaymentsInput = {
    id?: string
    pickupLat: number
    pickupLng: number
    dropLat: number
    dropLng: number
    payoutAmount: number
    orderAmount?: number | null
    platformFee?: number | null
    orderType?: string | null
    commissionRate?: number | null
    priority?: string | null
    status?: $Enums.OrderStatus
    assignedAt?: Date | string | null
    pickedUpAt?: Date | string | null
    deliveredAt?: Date | string | null
    cancelledAt?: Date | string | null
    cancellationReason?: string | null
    estimatedDuration?: number | null
    actualDuration?: number | null
    createdAt?: Date | string
    updatedAt?: Date | string
    barcode?: string | null
    qrCode?: string | null
    deliveryOtp?: string | null
    deliveryQrCode?: string | null
    otpExpiresAt?: Date | string | null
    verifiedAt?: Date | string | null
    verificationMethod?: string | null
    partner: PartnerCreateNestedOneWithoutOrdersInput
    agent?: AgentCreateNestedOneWithoutOrdersInput
    currentAgent?: AgentCreateNestedOneWithoutCurrentOrderInput
    tickets?: SupportTicketCreateNestedManyWithoutOrderInput
    rating?: AgentRatingCreateNestedOneWithoutOrderInput
    partnerRevenue?: PartnerRevenueCreateNestedOneWithoutOrderInput
    platformRevenue?: PlatformRevenueCreateNestedOneWithoutOrderInput
    walletTransactions?: WalletTransactionCreateNestedManyWithoutOrderInput
  }

  export type OrderUncheckedCreateWithoutPaymentsInput = {
    id?: string
    partnerId: string
    agentId?: string | null
    pickupLat: number
    pickupLng: number
    dropLat: number
    dropLng: number
    payoutAmount: number
    orderAmount?: number | null
    platformFee?: number | null
    orderType?: string | null
    commissionRate?: number | null
    priority?: string | null
    status?: $Enums.OrderStatus
    assignedAt?: Date | string | null
    pickedUpAt?: Date | string | null
    deliveredAt?: Date | string | null
    cancelledAt?: Date | string | null
    cancellationReason?: string | null
    estimatedDuration?: number | null
    actualDuration?: number | null
    createdAt?: Date | string
    updatedAt?: Date | string
    barcode?: string | null
    qrCode?: string | null
    deliveryOtp?: string | null
    deliveryQrCode?: string | null
    otpExpiresAt?: Date | string | null
    verifiedAt?: Date | string | null
    verificationMethod?: string | null
    currentAgent?: AgentUncheckedCreateNestedOneWithoutCurrentOrderInput
    tickets?: SupportTicketUncheckedCreateNestedManyWithoutOrderInput
    rating?: AgentRatingUncheckedCreateNestedOneWithoutOrderInput
    partnerRevenue?: PartnerRevenueUncheckedCreateNestedOneWithoutOrderInput
    platformRevenue?: PlatformRevenueUncheckedCreateNestedOneWithoutOrderInput
    walletTransactions?: WalletTransactionUncheckedCreateNestedManyWithoutOrderInput
  }

  export type OrderCreateOrConnectWithoutPaymentsInput = {
    where: OrderWhereUniqueInput
    create: XOR<OrderCreateWithoutPaymentsInput, OrderUncheckedCreateWithoutPaymentsInput>
  }

  export type AgentUpsertWithoutPaymentsInput = {
    update: XOR<AgentUpdateWithoutPaymentsInput, AgentUncheckedUpdateWithoutPaymentsInput>
    create: XOR<AgentCreateWithoutPaymentsInput, AgentUncheckedCreateWithoutPaymentsInput>
    where?: AgentWhereInput
  }

  export type AgentUpdateToOneWithWhereWithoutPaymentsInput = {
    where?: AgentWhereInput
    data: XOR<AgentUpdateWithoutPaymentsInput, AgentUncheckedUpdateWithoutPaymentsInput>
  }

  export type AgentUpdateWithoutPaymentsInput = {
    id?: StringFieldUpdateOperationsInput | string
    vehicleType?: EnumVehicleTypeFieldUpdateOperationsInput | $Enums.VehicleType
    status?: EnumAgentStatusFieldUpdateOperationsInput | $Enums.AgentStatus
    rating?: NullableFloatFieldUpdateOperationsInput | number | null
    totalOrders?: IntFieldUpdateOperationsInput | number
    completedOrders?: IntFieldUpdateOperationsInput | number
    cancelledOrders?: IntFieldUpdateOperationsInput | number
    acceptanceRate?: FloatFieldUpdateOperationsInput | number
    isApproved?: BoolFieldUpdateOperationsInput | boolean
    isBlocked?: BoolFieldUpdateOperationsInput | boolean
    blockedReason?: NullableStringFieldUpdateOperationsInput | string | null
    city?: NullableStringFieldUpdateOperationsInput | string | null
    state?: NullableStringFieldUpdateOperationsInput | string | null
    pincode?: NullableStringFieldUpdateOperationsInput | string | null
    lastOnlineAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneRequiredWithoutAgentNestedInput
    orders?: OrderUpdateManyWithoutAgentNestedInput
    currentOrder?: OrderUpdateOneWithoutCurrentAgentNestedInput
    documents?: AgentDocumentUpdateManyWithoutAgentNestedInput
    locationHistory?: AgentLocationUpdateManyWithoutAgentNestedInput
    tickets?: SupportTicketUpdateManyWithoutAgentNestedInput
    ratings?: AgentRatingUpdateManyWithoutAgentNestedInput
    wallet?: AgentWalletUpdateOneWithoutAgentNestedInput
    walletPayouts?: WalletPayoutUpdateManyWithoutAgentNestedInput
    payrolls?: PayrollUpdateManyWithoutAgentNestedInput
    schedules?: AgentScheduleUpdateManyWithoutAgentNestedInput
  }

  export type AgentUncheckedUpdateWithoutPaymentsInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    vehicleType?: EnumVehicleTypeFieldUpdateOperationsInput | $Enums.VehicleType
    status?: EnumAgentStatusFieldUpdateOperationsInput | $Enums.AgentStatus
    rating?: NullableFloatFieldUpdateOperationsInput | number | null
    totalOrders?: IntFieldUpdateOperationsInput | number
    completedOrders?: IntFieldUpdateOperationsInput | number
    cancelledOrders?: IntFieldUpdateOperationsInput | number
    acceptanceRate?: FloatFieldUpdateOperationsInput | number
    currentOrderId?: NullableStringFieldUpdateOperationsInput | string | null
    isApproved?: BoolFieldUpdateOperationsInput | boolean
    isBlocked?: BoolFieldUpdateOperationsInput | boolean
    blockedReason?: NullableStringFieldUpdateOperationsInput | string | null
    city?: NullableStringFieldUpdateOperationsInput | string | null
    state?: NullableStringFieldUpdateOperationsInput | string | null
    pincode?: NullableStringFieldUpdateOperationsInput | string | null
    lastOnlineAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    orders?: OrderUncheckedUpdateManyWithoutAgentNestedInput
    documents?: AgentDocumentUncheckedUpdateManyWithoutAgentNestedInput
    locationHistory?: AgentLocationUncheckedUpdateManyWithoutAgentNestedInput
    tickets?: SupportTicketUncheckedUpdateManyWithoutAgentNestedInput
    ratings?: AgentRatingUncheckedUpdateManyWithoutAgentNestedInput
    wallet?: AgentWalletUncheckedUpdateOneWithoutAgentNestedInput
    walletPayouts?: WalletPayoutUncheckedUpdateManyWithoutAgentNestedInput
    payrolls?: PayrollUncheckedUpdateManyWithoutAgentNestedInput
    schedules?: AgentScheduleUncheckedUpdateManyWithoutAgentNestedInput
  }

  export type OrderUpsertWithoutPaymentsInput = {
    update: XOR<OrderUpdateWithoutPaymentsInput, OrderUncheckedUpdateWithoutPaymentsInput>
    create: XOR<OrderCreateWithoutPaymentsInput, OrderUncheckedCreateWithoutPaymentsInput>
    where?: OrderWhereInput
  }

  export type OrderUpdateToOneWithWhereWithoutPaymentsInput = {
    where?: OrderWhereInput
    data: XOR<OrderUpdateWithoutPaymentsInput, OrderUncheckedUpdateWithoutPaymentsInput>
  }

  export type OrderUpdateWithoutPaymentsInput = {
    id?: StringFieldUpdateOperationsInput | string
    pickupLat?: FloatFieldUpdateOperationsInput | number
    pickupLng?: FloatFieldUpdateOperationsInput | number
    dropLat?: FloatFieldUpdateOperationsInput | number
    dropLng?: FloatFieldUpdateOperationsInput | number
    payoutAmount?: FloatFieldUpdateOperationsInput | number
    orderAmount?: NullableFloatFieldUpdateOperationsInput | number | null
    platformFee?: NullableFloatFieldUpdateOperationsInput | number | null
    orderType?: NullableStringFieldUpdateOperationsInput | string | null
    commissionRate?: NullableFloatFieldUpdateOperationsInput | number | null
    priority?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumOrderStatusFieldUpdateOperationsInput | $Enums.OrderStatus
    assignedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    pickedUpAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    deliveredAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    cancelledAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    cancellationReason?: NullableStringFieldUpdateOperationsInput | string | null
    estimatedDuration?: NullableIntFieldUpdateOperationsInput | number | null
    actualDuration?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    barcode?: NullableStringFieldUpdateOperationsInput | string | null
    qrCode?: NullableStringFieldUpdateOperationsInput | string | null
    deliveryOtp?: NullableStringFieldUpdateOperationsInput | string | null
    deliveryQrCode?: NullableStringFieldUpdateOperationsInput | string | null
    otpExpiresAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    verifiedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    verificationMethod?: NullableStringFieldUpdateOperationsInput | string | null
    partner?: PartnerUpdateOneRequiredWithoutOrdersNestedInput
    agent?: AgentUpdateOneWithoutOrdersNestedInput
    currentAgent?: AgentUpdateOneWithoutCurrentOrderNestedInput
    tickets?: SupportTicketUpdateManyWithoutOrderNestedInput
    rating?: AgentRatingUpdateOneWithoutOrderNestedInput
    partnerRevenue?: PartnerRevenueUpdateOneWithoutOrderNestedInput
    platformRevenue?: PlatformRevenueUpdateOneWithoutOrderNestedInput
    walletTransactions?: WalletTransactionUpdateManyWithoutOrderNestedInput
  }

  export type OrderUncheckedUpdateWithoutPaymentsInput = {
    id?: StringFieldUpdateOperationsInput | string
    partnerId?: StringFieldUpdateOperationsInput | string
    agentId?: NullableStringFieldUpdateOperationsInput | string | null
    pickupLat?: FloatFieldUpdateOperationsInput | number
    pickupLng?: FloatFieldUpdateOperationsInput | number
    dropLat?: FloatFieldUpdateOperationsInput | number
    dropLng?: FloatFieldUpdateOperationsInput | number
    payoutAmount?: FloatFieldUpdateOperationsInput | number
    orderAmount?: NullableFloatFieldUpdateOperationsInput | number | null
    platformFee?: NullableFloatFieldUpdateOperationsInput | number | null
    orderType?: NullableStringFieldUpdateOperationsInput | string | null
    commissionRate?: NullableFloatFieldUpdateOperationsInput | number | null
    priority?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumOrderStatusFieldUpdateOperationsInput | $Enums.OrderStatus
    assignedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    pickedUpAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    deliveredAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    cancelledAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    cancellationReason?: NullableStringFieldUpdateOperationsInput | string | null
    estimatedDuration?: NullableIntFieldUpdateOperationsInput | number | null
    actualDuration?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    barcode?: NullableStringFieldUpdateOperationsInput | string | null
    qrCode?: NullableStringFieldUpdateOperationsInput | string | null
    deliveryOtp?: NullableStringFieldUpdateOperationsInput | string | null
    deliveryQrCode?: NullableStringFieldUpdateOperationsInput | string | null
    otpExpiresAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    verifiedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    verificationMethod?: NullableStringFieldUpdateOperationsInput | string | null
    currentAgent?: AgentUncheckedUpdateOneWithoutCurrentOrderNestedInput
    tickets?: SupportTicketUncheckedUpdateManyWithoutOrderNestedInput
    rating?: AgentRatingUncheckedUpdateOneWithoutOrderNestedInput
    partnerRevenue?: PartnerRevenueUncheckedUpdateOneWithoutOrderNestedInput
    platformRevenue?: PlatformRevenueUncheckedUpdateOneWithoutOrderNestedInput
    walletTransactions?: WalletTransactionUncheckedUpdateManyWithoutOrderNestedInput
  }

  export type AgentCreateWithoutPayrollsInput = {
    id?: string
    vehicleType: $Enums.VehicleType
    status?: $Enums.AgentStatus
    rating?: number | null
    totalOrders?: number
    completedOrders?: number
    cancelledOrders?: number
    acceptanceRate?: number
    isApproved?: boolean
    isBlocked?: boolean
    blockedReason?: string | null
    city?: string | null
    state?: string | null
    pincode?: string | null
    lastOnlineAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    user: UserCreateNestedOneWithoutAgentInput
    orders?: OrderCreateNestedManyWithoutAgentInput
    currentOrder?: OrderCreateNestedOneWithoutCurrentAgentInput
    documents?: AgentDocumentCreateNestedManyWithoutAgentInput
    locationHistory?: AgentLocationCreateNestedManyWithoutAgentInput
    tickets?: SupportTicketCreateNestedManyWithoutAgentInput
    ratings?: AgentRatingCreateNestedManyWithoutAgentInput
    wallet?: AgentWalletCreateNestedOneWithoutAgentInput
    walletPayouts?: WalletPayoutCreateNestedManyWithoutAgentInput
    payments?: PaymentCreateNestedManyWithoutAgentInput
    schedules?: AgentScheduleCreateNestedManyWithoutAgentInput
  }

  export type AgentUncheckedCreateWithoutPayrollsInput = {
    id?: string
    userId: string
    vehicleType: $Enums.VehicleType
    status?: $Enums.AgentStatus
    rating?: number | null
    totalOrders?: number
    completedOrders?: number
    cancelledOrders?: number
    acceptanceRate?: number
    currentOrderId?: string | null
    isApproved?: boolean
    isBlocked?: boolean
    blockedReason?: string | null
    city?: string | null
    state?: string | null
    pincode?: string | null
    lastOnlineAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    orders?: OrderUncheckedCreateNestedManyWithoutAgentInput
    documents?: AgentDocumentUncheckedCreateNestedManyWithoutAgentInput
    locationHistory?: AgentLocationUncheckedCreateNestedManyWithoutAgentInput
    tickets?: SupportTicketUncheckedCreateNestedManyWithoutAgentInput
    ratings?: AgentRatingUncheckedCreateNestedManyWithoutAgentInput
    wallet?: AgentWalletUncheckedCreateNestedOneWithoutAgentInput
    walletPayouts?: WalletPayoutUncheckedCreateNestedManyWithoutAgentInput
    payments?: PaymentUncheckedCreateNestedManyWithoutAgentInput
    schedules?: AgentScheduleUncheckedCreateNestedManyWithoutAgentInput
  }

  export type AgentCreateOrConnectWithoutPayrollsInput = {
    where: AgentWhereUniqueInput
    create: XOR<AgentCreateWithoutPayrollsInput, AgentUncheckedCreateWithoutPayrollsInput>
  }

  export type AgentUpsertWithoutPayrollsInput = {
    update: XOR<AgentUpdateWithoutPayrollsInput, AgentUncheckedUpdateWithoutPayrollsInput>
    create: XOR<AgentCreateWithoutPayrollsInput, AgentUncheckedCreateWithoutPayrollsInput>
    where?: AgentWhereInput
  }

  export type AgentUpdateToOneWithWhereWithoutPayrollsInput = {
    where?: AgentWhereInput
    data: XOR<AgentUpdateWithoutPayrollsInput, AgentUncheckedUpdateWithoutPayrollsInput>
  }

  export type AgentUpdateWithoutPayrollsInput = {
    id?: StringFieldUpdateOperationsInput | string
    vehicleType?: EnumVehicleTypeFieldUpdateOperationsInput | $Enums.VehicleType
    status?: EnumAgentStatusFieldUpdateOperationsInput | $Enums.AgentStatus
    rating?: NullableFloatFieldUpdateOperationsInput | number | null
    totalOrders?: IntFieldUpdateOperationsInput | number
    completedOrders?: IntFieldUpdateOperationsInput | number
    cancelledOrders?: IntFieldUpdateOperationsInput | number
    acceptanceRate?: FloatFieldUpdateOperationsInput | number
    isApproved?: BoolFieldUpdateOperationsInput | boolean
    isBlocked?: BoolFieldUpdateOperationsInput | boolean
    blockedReason?: NullableStringFieldUpdateOperationsInput | string | null
    city?: NullableStringFieldUpdateOperationsInput | string | null
    state?: NullableStringFieldUpdateOperationsInput | string | null
    pincode?: NullableStringFieldUpdateOperationsInput | string | null
    lastOnlineAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneRequiredWithoutAgentNestedInput
    orders?: OrderUpdateManyWithoutAgentNestedInput
    currentOrder?: OrderUpdateOneWithoutCurrentAgentNestedInput
    documents?: AgentDocumentUpdateManyWithoutAgentNestedInput
    locationHistory?: AgentLocationUpdateManyWithoutAgentNestedInput
    tickets?: SupportTicketUpdateManyWithoutAgentNestedInput
    ratings?: AgentRatingUpdateManyWithoutAgentNestedInput
    wallet?: AgentWalletUpdateOneWithoutAgentNestedInput
    walletPayouts?: WalletPayoutUpdateManyWithoutAgentNestedInput
    payments?: PaymentUpdateManyWithoutAgentNestedInput
    schedules?: AgentScheduleUpdateManyWithoutAgentNestedInput
  }

  export type AgentUncheckedUpdateWithoutPayrollsInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    vehicleType?: EnumVehicleTypeFieldUpdateOperationsInput | $Enums.VehicleType
    status?: EnumAgentStatusFieldUpdateOperationsInput | $Enums.AgentStatus
    rating?: NullableFloatFieldUpdateOperationsInput | number | null
    totalOrders?: IntFieldUpdateOperationsInput | number
    completedOrders?: IntFieldUpdateOperationsInput | number
    cancelledOrders?: IntFieldUpdateOperationsInput | number
    acceptanceRate?: FloatFieldUpdateOperationsInput | number
    currentOrderId?: NullableStringFieldUpdateOperationsInput | string | null
    isApproved?: BoolFieldUpdateOperationsInput | boolean
    isBlocked?: BoolFieldUpdateOperationsInput | boolean
    blockedReason?: NullableStringFieldUpdateOperationsInput | string | null
    city?: NullableStringFieldUpdateOperationsInput | string | null
    state?: NullableStringFieldUpdateOperationsInput | string | null
    pincode?: NullableStringFieldUpdateOperationsInput | string | null
    lastOnlineAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    orders?: OrderUncheckedUpdateManyWithoutAgentNestedInput
    documents?: AgentDocumentUncheckedUpdateManyWithoutAgentNestedInput
    locationHistory?: AgentLocationUncheckedUpdateManyWithoutAgentNestedInput
    tickets?: SupportTicketUncheckedUpdateManyWithoutAgentNestedInput
    ratings?: AgentRatingUncheckedUpdateManyWithoutAgentNestedInput
    wallet?: AgentWalletUncheckedUpdateOneWithoutAgentNestedInput
    walletPayouts?: WalletPayoutUncheckedUpdateManyWithoutAgentNestedInput
    payments?: PaymentUncheckedUpdateManyWithoutAgentNestedInput
    schedules?: AgentScheduleUncheckedUpdateManyWithoutAgentNestedInput
  }

  export type AgentCreateWithoutSchedulesInput = {
    id?: string
    vehicleType: $Enums.VehicleType
    status?: $Enums.AgentStatus
    rating?: number | null
    totalOrders?: number
    completedOrders?: number
    cancelledOrders?: number
    acceptanceRate?: number
    isApproved?: boolean
    isBlocked?: boolean
    blockedReason?: string | null
    city?: string | null
    state?: string | null
    pincode?: string | null
    lastOnlineAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    user: UserCreateNestedOneWithoutAgentInput
    orders?: OrderCreateNestedManyWithoutAgentInput
    currentOrder?: OrderCreateNestedOneWithoutCurrentAgentInput
    documents?: AgentDocumentCreateNestedManyWithoutAgentInput
    locationHistory?: AgentLocationCreateNestedManyWithoutAgentInput
    tickets?: SupportTicketCreateNestedManyWithoutAgentInput
    ratings?: AgentRatingCreateNestedManyWithoutAgentInput
    wallet?: AgentWalletCreateNestedOneWithoutAgentInput
    walletPayouts?: WalletPayoutCreateNestedManyWithoutAgentInput
    payments?: PaymentCreateNestedManyWithoutAgentInput
    payrolls?: PayrollCreateNestedManyWithoutAgentInput
  }

  export type AgentUncheckedCreateWithoutSchedulesInput = {
    id?: string
    userId: string
    vehicleType: $Enums.VehicleType
    status?: $Enums.AgentStatus
    rating?: number | null
    totalOrders?: number
    completedOrders?: number
    cancelledOrders?: number
    acceptanceRate?: number
    currentOrderId?: string | null
    isApproved?: boolean
    isBlocked?: boolean
    blockedReason?: string | null
    city?: string | null
    state?: string | null
    pincode?: string | null
    lastOnlineAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    orders?: OrderUncheckedCreateNestedManyWithoutAgentInput
    documents?: AgentDocumentUncheckedCreateNestedManyWithoutAgentInput
    locationHistory?: AgentLocationUncheckedCreateNestedManyWithoutAgentInput
    tickets?: SupportTicketUncheckedCreateNestedManyWithoutAgentInput
    ratings?: AgentRatingUncheckedCreateNestedManyWithoutAgentInput
    wallet?: AgentWalletUncheckedCreateNestedOneWithoutAgentInput
    walletPayouts?: WalletPayoutUncheckedCreateNestedManyWithoutAgentInput
    payments?: PaymentUncheckedCreateNestedManyWithoutAgentInput
    payrolls?: PayrollUncheckedCreateNestedManyWithoutAgentInput
  }

  export type AgentCreateOrConnectWithoutSchedulesInput = {
    where: AgentWhereUniqueInput
    create: XOR<AgentCreateWithoutSchedulesInput, AgentUncheckedCreateWithoutSchedulesInput>
  }

  export type AgentUpsertWithoutSchedulesInput = {
    update: XOR<AgentUpdateWithoutSchedulesInput, AgentUncheckedUpdateWithoutSchedulesInput>
    create: XOR<AgentCreateWithoutSchedulesInput, AgentUncheckedCreateWithoutSchedulesInput>
    where?: AgentWhereInput
  }

  export type AgentUpdateToOneWithWhereWithoutSchedulesInput = {
    where?: AgentWhereInput
    data: XOR<AgentUpdateWithoutSchedulesInput, AgentUncheckedUpdateWithoutSchedulesInput>
  }

  export type AgentUpdateWithoutSchedulesInput = {
    id?: StringFieldUpdateOperationsInput | string
    vehicleType?: EnumVehicleTypeFieldUpdateOperationsInput | $Enums.VehicleType
    status?: EnumAgentStatusFieldUpdateOperationsInput | $Enums.AgentStatus
    rating?: NullableFloatFieldUpdateOperationsInput | number | null
    totalOrders?: IntFieldUpdateOperationsInput | number
    completedOrders?: IntFieldUpdateOperationsInput | number
    cancelledOrders?: IntFieldUpdateOperationsInput | number
    acceptanceRate?: FloatFieldUpdateOperationsInput | number
    isApproved?: BoolFieldUpdateOperationsInput | boolean
    isBlocked?: BoolFieldUpdateOperationsInput | boolean
    blockedReason?: NullableStringFieldUpdateOperationsInput | string | null
    city?: NullableStringFieldUpdateOperationsInput | string | null
    state?: NullableStringFieldUpdateOperationsInput | string | null
    pincode?: NullableStringFieldUpdateOperationsInput | string | null
    lastOnlineAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneRequiredWithoutAgentNestedInput
    orders?: OrderUpdateManyWithoutAgentNestedInput
    currentOrder?: OrderUpdateOneWithoutCurrentAgentNestedInput
    documents?: AgentDocumentUpdateManyWithoutAgentNestedInput
    locationHistory?: AgentLocationUpdateManyWithoutAgentNestedInput
    tickets?: SupportTicketUpdateManyWithoutAgentNestedInput
    ratings?: AgentRatingUpdateManyWithoutAgentNestedInput
    wallet?: AgentWalletUpdateOneWithoutAgentNestedInput
    walletPayouts?: WalletPayoutUpdateManyWithoutAgentNestedInput
    payments?: PaymentUpdateManyWithoutAgentNestedInput
    payrolls?: PayrollUpdateManyWithoutAgentNestedInput
  }

  export type AgentUncheckedUpdateWithoutSchedulesInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    vehicleType?: EnumVehicleTypeFieldUpdateOperationsInput | $Enums.VehicleType
    status?: EnumAgentStatusFieldUpdateOperationsInput | $Enums.AgentStatus
    rating?: NullableFloatFieldUpdateOperationsInput | number | null
    totalOrders?: IntFieldUpdateOperationsInput | number
    completedOrders?: IntFieldUpdateOperationsInput | number
    cancelledOrders?: IntFieldUpdateOperationsInput | number
    acceptanceRate?: FloatFieldUpdateOperationsInput | number
    currentOrderId?: NullableStringFieldUpdateOperationsInput | string | null
    isApproved?: BoolFieldUpdateOperationsInput | boolean
    isBlocked?: BoolFieldUpdateOperationsInput | boolean
    blockedReason?: NullableStringFieldUpdateOperationsInput | string | null
    city?: NullableStringFieldUpdateOperationsInput | string | null
    state?: NullableStringFieldUpdateOperationsInput | string | null
    pincode?: NullableStringFieldUpdateOperationsInput | string | null
    lastOnlineAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    orders?: OrderUncheckedUpdateManyWithoutAgentNestedInput
    documents?: AgentDocumentUncheckedUpdateManyWithoutAgentNestedInput
    locationHistory?: AgentLocationUncheckedUpdateManyWithoutAgentNestedInput
    tickets?: SupportTicketUncheckedUpdateManyWithoutAgentNestedInput
    ratings?: AgentRatingUncheckedUpdateManyWithoutAgentNestedInput
    wallet?: AgentWalletUncheckedUpdateOneWithoutAgentNestedInput
    walletPayouts?: WalletPayoutUncheckedUpdateManyWithoutAgentNestedInput
    payments?: PaymentUncheckedUpdateManyWithoutAgentNestedInput
    payrolls?: PayrollUncheckedUpdateManyWithoutAgentNestedInput
  }

  export type NotificationTokenCreateManyUserInput = {
    id?: string
    fcmToken: string
    deviceType?: string | null
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type NotificationCreateManyUserInput = {
    id?: string
    title: string
    message: string
    type: string
    isRead?: boolean
    link?: string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    readAt?: Date | string | null
  }

  export type SupportTicketCreateManyUserInput = {
    id?: string
    orderId?: string | null
    agentId?: string | null
    partnerId?: string | null
    issueType: string
    description: string
    status?: $Enums.TicketStatus
    resolvedAt?: Date | string | null
    adminNotes?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type NotificationTokenUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    fcmToken?: StringFieldUpdateOperationsInput | string
    deviceType?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type NotificationTokenUncheckedUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    fcmToken?: StringFieldUpdateOperationsInput | string
    deviceType?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type NotificationTokenUncheckedUpdateManyWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    fcmToken?: StringFieldUpdateOperationsInput | string
    deviceType?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type NotificationUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    message?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    isRead?: BoolFieldUpdateOperationsInput | boolean
    link?: NullableStringFieldUpdateOperationsInput | string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    readAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type NotificationUncheckedUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    message?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    isRead?: BoolFieldUpdateOperationsInput | boolean
    link?: NullableStringFieldUpdateOperationsInput | string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    readAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type NotificationUncheckedUpdateManyWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    message?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    isRead?: BoolFieldUpdateOperationsInput | boolean
    link?: NullableStringFieldUpdateOperationsInput | string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    readAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type SupportTicketUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    issueType?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    status?: EnumTicketStatusFieldUpdateOperationsInput | $Enums.TicketStatus
    resolvedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    adminNotes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    order?: OrderUpdateOneWithoutTicketsNestedInput
    agent?: AgentUpdateOneWithoutTicketsNestedInput
    partner?: PartnerUpdateOneWithoutTicketsNestedInput
  }

  export type SupportTicketUncheckedUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    orderId?: NullableStringFieldUpdateOperationsInput | string | null
    agentId?: NullableStringFieldUpdateOperationsInput | string | null
    partnerId?: NullableStringFieldUpdateOperationsInput | string | null
    issueType?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    status?: EnumTicketStatusFieldUpdateOperationsInput | $Enums.TicketStatus
    resolvedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    adminNotes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SupportTicketUncheckedUpdateManyWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    orderId?: NullableStringFieldUpdateOperationsInput | string | null
    agentId?: NullableStringFieldUpdateOperationsInput | string | null
    partnerId?: NullableStringFieldUpdateOperationsInput | string | null
    issueType?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    status?: EnumTicketStatusFieldUpdateOperationsInput | $Enums.TicketStatus
    resolvedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    adminNotes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type OrderCreateManyAgentInput = {
    id?: string
    partnerId: string
    pickupLat: number
    pickupLng: number
    dropLat: number
    dropLng: number
    payoutAmount: number
    orderAmount?: number | null
    platformFee?: number | null
    orderType?: string | null
    commissionRate?: number | null
    priority?: string | null
    status?: $Enums.OrderStatus
    assignedAt?: Date | string | null
    pickedUpAt?: Date | string | null
    deliveredAt?: Date | string | null
    cancelledAt?: Date | string | null
    cancellationReason?: string | null
    estimatedDuration?: number | null
    actualDuration?: number | null
    createdAt?: Date | string
    updatedAt?: Date | string
    barcode?: string | null
    qrCode?: string | null
    deliveryOtp?: string | null
    deliveryQrCode?: string | null
    otpExpiresAt?: Date | string | null
    verifiedAt?: Date | string | null
    verificationMethod?: string | null
  }

  export type AgentDocumentCreateManyAgentInput = {
    id?: string
    documentType: string
    fileName: string
    fileUrl: string
    verified?: boolean
    uploadedAt?: Date | string
  }

  export type AgentLocationCreateManyAgentInput = {
    id?: string
    latitude: number
    longitude: number
    timestamp?: Date | string
  }

  export type SupportTicketCreateManyAgentInput = {
    id?: string
    orderId?: string | null
    partnerId?: string | null
    userId: string
    issueType: string
    description: string
    status?: $Enums.TicketStatus
    resolvedAt?: Date | string | null
    adminNotes?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type AgentRatingCreateManyAgentInput = {
    id?: string
    orderId: string
    partnerId: string
    rating: number
    comment?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type WalletPayoutCreateManyAgentInput = {
    id?: string
    agentWalletId: string
    amount: number
    periodStart: Date | string
    periodEnd: Date | string
    status?: string
    paymentMethod?: string | null
    transactionId?: string | null
    bankAccount?: string | null
    upiId?: string | null
    processedAt?: Date | string | null
    failedAt?: Date | string | null
    failureReason?: string | null
    notes?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type PaymentCreateManyAgentInput = {
    id?: string
    orderId: string
    amount: number
    paymentType: string
    status?: string
    processedAt?: Date | string | null
    paymentMethod?: string | null
    transactionId?: string | null
    notes?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type PayrollCreateManyAgentInput = {
    id?: string
    periodStart: Date | string
    periodEnd: Date | string
    periodType: string
    totalEarnings?: number
    totalOrders?: number
    basePay?: number
    bonuses?: number
    deductions?: number
    netPay?: number
    status?: string
    processedAt?: Date | string | null
    paidAt?: Date | string | null
    paymentMethod?: string | null
    transactionId?: string | null
    notes?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type AgentScheduleCreateManyAgentInput = {
    id?: string
    date: Date | string
    startTime?: string | null
    endTime?: string | null
    isAvailable?: boolean
    notes?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type OrderUpdateWithoutAgentInput = {
    id?: StringFieldUpdateOperationsInput | string
    pickupLat?: FloatFieldUpdateOperationsInput | number
    pickupLng?: FloatFieldUpdateOperationsInput | number
    dropLat?: FloatFieldUpdateOperationsInput | number
    dropLng?: FloatFieldUpdateOperationsInput | number
    payoutAmount?: FloatFieldUpdateOperationsInput | number
    orderAmount?: NullableFloatFieldUpdateOperationsInput | number | null
    platformFee?: NullableFloatFieldUpdateOperationsInput | number | null
    orderType?: NullableStringFieldUpdateOperationsInput | string | null
    commissionRate?: NullableFloatFieldUpdateOperationsInput | number | null
    priority?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumOrderStatusFieldUpdateOperationsInput | $Enums.OrderStatus
    assignedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    pickedUpAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    deliveredAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    cancelledAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    cancellationReason?: NullableStringFieldUpdateOperationsInput | string | null
    estimatedDuration?: NullableIntFieldUpdateOperationsInput | number | null
    actualDuration?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    barcode?: NullableStringFieldUpdateOperationsInput | string | null
    qrCode?: NullableStringFieldUpdateOperationsInput | string | null
    deliveryOtp?: NullableStringFieldUpdateOperationsInput | string | null
    deliveryQrCode?: NullableStringFieldUpdateOperationsInput | string | null
    otpExpiresAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    verifiedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    verificationMethod?: NullableStringFieldUpdateOperationsInput | string | null
    partner?: PartnerUpdateOneRequiredWithoutOrdersNestedInput
    currentAgent?: AgentUpdateOneWithoutCurrentOrderNestedInput
    tickets?: SupportTicketUpdateManyWithoutOrderNestedInput
    rating?: AgentRatingUpdateOneWithoutOrderNestedInput
    payments?: PaymentUpdateManyWithoutOrderNestedInput
    partnerRevenue?: PartnerRevenueUpdateOneWithoutOrderNestedInput
    platformRevenue?: PlatformRevenueUpdateOneWithoutOrderNestedInput
    walletTransactions?: WalletTransactionUpdateManyWithoutOrderNestedInput
  }

  export type OrderUncheckedUpdateWithoutAgentInput = {
    id?: StringFieldUpdateOperationsInput | string
    partnerId?: StringFieldUpdateOperationsInput | string
    pickupLat?: FloatFieldUpdateOperationsInput | number
    pickupLng?: FloatFieldUpdateOperationsInput | number
    dropLat?: FloatFieldUpdateOperationsInput | number
    dropLng?: FloatFieldUpdateOperationsInput | number
    payoutAmount?: FloatFieldUpdateOperationsInput | number
    orderAmount?: NullableFloatFieldUpdateOperationsInput | number | null
    platformFee?: NullableFloatFieldUpdateOperationsInput | number | null
    orderType?: NullableStringFieldUpdateOperationsInput | string | null
    commissionRate?: NullableFloatFieldUpdateOperationsInput | number | null
    priority?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumOrderStatusFieldUpdateOperationsInput | $Enums.OrderStatus
    assignedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    pickedUpAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    deliveredAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    cancelledAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    cancellationReason?: NullableStringFieldUpdateOperationsInput | string | null
    estimatedDuration?: NullableIntFieldUpdateOperationsInput | number | null
    actualDuration?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    barcode?: NullableStringFieldUpdateOperationsInput | string | null
    qrCode?: NullableStringFieldUpdateOperationsInput | string | null
    deliveryOtp?: NullableStringFieldUpdateOperationsInput | string | null
    deliveryQrCode?: NullableStringFieldUpdateOperationsInput | string | null
    otpExpiresAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    verifiedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    verificationMethod?: NullableStringFieldUpdateOperationsInput | string | null
    currentAgent?: AgentUncheckedUpdateOneWithoutCurrentOrderNestedInput
    tickets?: SupportTicketUncheckedUpdateManyWithoutOrderNestedInput
    rating?: AgentRatingUncheckedUpdateOneWithoutOrderNestedInput
    payments?: PaymentUncheckedUpdateManyWithoutOrderNestedInput
    partnerRevenue?: PartnerRevenueUncheckedUpdateOneWithoutOrderNestedInput
    platformRevenue?: PlatformRevenueUncheckedUpdateOneWithoutOrderNestedInput
    walletTransactions?: WalletTransactionUncheckedUpdateManyWithoutOrderNestedInput
  }

  export type OrderUncheckedUpdateManyWithoutAgentInput = {
    id?: StringFieldUpdateOperationsInput | string
    partnerId?: StringFieldUpdateOperationsInput | string
    pickupLat?: FloatFieldUpdateOperationsInput | number
    pickupLng?: FloatFieldUpdateOperationsInput | number
    dropLat?: FloatFieldUpdateOperationsInput | number
    dropLng?: FloatFieldUpdateOperationsInput | number
    payoutAmount?: FloatFieldUpdateOperationsInput | number
    orderAmount?: NullableFloatFieldUpdateOperationsInput | number | null
    platformFee?: NullableFloatFieldUpdateOperationsInput | number | null
    orderType?: NullableStringFieldUpdateOperationsInput | string | null
    commissionRate?: NullableFloatFieldUpdateOperationsInput | number | null
    priority?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumOrderStatusFieldUpdateOperationsInput | $Enums.OrderStatus
    assignedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    pickedUpAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    deliveredAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    cancelledAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    cancellationReason?: NullableStringFieldUpdateOperationsInput | string | null
    estimatedDuration?: NullableIntFieldUpdateOperationsInput | number | null
    actualDuration?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    barcode?: NullableStringFieldUpdateOperationsInput | string | null
    qrCode?: NullableStringFieldUpdateOperationsInput | string | null
    deliveryOtp?: NullableStringFieldUpdateOperationsInput | string | null
    deliveryQrCode?: NullableStringFieldUpdateOperationsInput | string | null
    otpExpiresAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    verifiedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    verificationMethod?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type AgentDocumentUpdateWithoutAgentInput = {
    id?: StringFieldUpdateOperationsInput | string
    documentType?: StringFieldUpdateOperationsInput | string
    fileName?: StringFieldUpdateOperationsInput | string
    fileUrl?: StringFieldUpdateOperationsInput | string
    verified?: BoolFieldUpdateOperationsInput | boolean
    uploadedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AgentDocumentUncheckedUpdateWithoutAgentInput = {
    id?: StringFieldUpdateOperationsInput | string
    documentType?: StringFieldUpdateOperationsInput | string
    fileName?: StringFieldUpdateOperationsInput | string
    fileUrl?: StringFieldUpdateOperationsInput | string
    verified?: BoolFieldUpdateOperationsInput | boolean
    uploadedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AgentDocumentUncheckedUpdateManyWithoutAgentInput = {
    id?: StringFieldUpdateOperationsInput | string
    documentType?: StringFieldUpdateOperationsInput | string
    fileName?: StringFieldUpdateOperationsInput | string
    fileUrl?: StringFieldUpdateOperationsInput | string
    verified?: BoolFieldUpdateOperationsInput | boolean
    uploadedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AgentLocationUpdateWithoutAgentInput = {
    id?: StringFieldUpdateOperationsInput | string
    latitude?: FloatFieldUpdateOperationsInput | number
    longitude?: FloatFieldUpdateOperationsInput | number
    timestamp?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AgentLocationUncheckedUpdateWithoutAgentInput = {
    id?: StringFieldUpdateOperationsInput | string
    latitude?: FloatFieldUpdateOperationsInput | number
    longitude?: FloatFieldUpdateOperationsInput | number
    timestamp?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AgentLocationUncheckedUpdateManyWithoutAgentInput = {
    id?: StringFieldUpdateOperationsInput | string
    latitude?: FloatFieldUpdateOperationsInput | number
    longitude?: FloatFieldUpdateOperationsInput | number
    timestamp?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SupportTicketUpdateWithoutAgentInput = {
    id?: StringFieldUpdateOperationsInput | string
    issueType?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    status?: EnumTicketStatusFieldUpdateOperationsInput | $Enums.TicketStatus
    resolvedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    adminNotes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    order?: OrderUpdateOneWithoutTicketsNestedInput
    partner?: PartnerUpdateOneWithoutTicketsNestedInput
    user?: UserUpdateOneRequiredWithoutTicketsNestedInput
  }

  export type SupportTicketUncheckedUpdateWithoutAgentInput = {
    id?: StringFieldUpdateOperationsInput | string
    orderId?: NullableStringFieldUpdateOperationsInput | string | null
    partnerId?: NullableStringFieldUpdateOperationsInput | string | null
    userId?: StringFieldUpdateOperationsInput | string
    issueType?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    status?: EnumTicketStatusFieldUpdateOperationsInput | $Enums.TicketStatus
    resolvedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    adminNotes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SupportTicketUncheckedUpdateManyWithoutAgentInput = {
    id?: StringFieldUpdateOperationsInput | string
    orderId?: NullableStringFieldUpdateOperationsInput | string | null
    partnerId?: NullableStringFieldUpdateOperationsInput | string | null
    userId?: StringFieldUpdateOperationsInput | string
    issueType?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    status?: EnumTicketStatusFieldUpdateOperationsInput | $Enums.TicketStatus
    resolvedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    adminNotes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AgentRatingUpdateWithoutAgentInput = {
    id?: StringFieldUpdateOperationsInput | string
    rating?: IntFieldUpdateOperationsInput | number
    comment?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    order?: OrderUpdateOneRequiredWithoutRatingNestedInput
    partner?: PartnerUpdateOneRequiredWithoutAgentRatingsNestedInput
  }

  export type AgentRatingUncheckedUpdateWithoutAgentInput = {
    id?: StringFieldUpdateOperationsInput | string
    orderId?: StringFieldUpdateOperationsInput | string
    partnerId?: StringFieldUpdateOperationsInput | string
    rating?: IntFieldUpdateOperationsInput | number
    comment?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AgentRatingUncheckedUpdateManyWithoutAgentInput = {
    id?: StringFieldUpdateOperationsInput | string
    orderId?: StringFieldUpdateOperationsInput | string
    partnerId?: StringFieldUpdateOperationsInput | string
    rating?: IntFieldUpdateOperationsInput | number
    comment?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type WalletPayoutUpdateWithoutAgentInput = {
    id?: StringFieldUpdateOperationsInput | string
    amount?: FloatFieldUpdateOperationsInput | number
    periodStart?: DateTimeFieldUpdateOperationsInput | Date | string
    periodEnd?: DateTimeFieldUpdateOperationsInput | Date | string
    status?: StringFieldUpdateOperationsInput | string
    paymentMethod?: NullableStringFieldUpdateOperationsInput | string | null
    transactionId?: NullableStringFieldUpdateOperationsInput | string | null
    bankAccount?: NullableStringFieldUpdateOperationsInput | string | null
    upiId?: NullableStringFieldUpdateOperationsInput | string | null
    processedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    failedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    failureReason?: NullableStringFieldUpdateOperationsInput | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    agentWallet?: AgentWalletUpdateOneRequiredWithoutPayoutsNestedInput
  }

  export type WalletPayoutUncheckedUpdateWithoutAgentInput = {
    id?: StringFieldUpdateOperationsInput | string
    agentWalletId?: StringFieldUpdateOperationsInput | string
    amount?: FloatFieldUpdateOperationsInput | number
    periodStart?: DateTimeFieldUpdateOperationsInput | Date | string
    periodEnd?: DateTimeFieldUpdateOperationsInput | Date | string
    status?: StringFieldUpdateOperationsInput | string
    paymentMethod?: NullableStringFieldUpdateOperationsInput | string | null
    transactionId?: NullableStringFieldUpdateOperationsInput | string | null
    bankAccount?: NullableStringFieldUpdateOperationsInput | string | null
    upiId?: NullableStringFieldUpdateOperationsInput | string | null
    processedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    failedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    failureReason?: NullableStringFieldUpdateOperationsInput | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type WalletPayoutUncheckedUpdateManyWithoutAgentInput = {
    id?: StringFieldUpdateOperationsInput | string
    agentWalletId?: StringFieldUpdateOperationsInput | string
    amount?: FloatFieldUpdateOperationsInput | number
    periodStart?: DateTimeFieldUpdateOperationsInput | Date | string
    periodEnd?: DateTimeFieldUpdateOperationsInput | Date | string
    status?: StringFieldUpdateOperationsInput | string
    paymentMethod?: NullableStringFieldUpdateOperationsInput | string | null
    transactionId?: NullableStringFieldUpdateOperationsInput | string | null
    bankAccount?: NullableStringFieldUpdateOperationsInput | string | null
    upiId?: NullableStringFieldUpdateOperationsInput | string | null
    processedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    failedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    failureReason?: NullableStringFieldUpdateOperationsInput | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PaymentUpdateWithoutAgentInput = {
    id?: StringFieldUpdateOperationsInput | string
    amount?: FloatFieldUpdateOperationsInput | number
    paymentType?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    processedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    paymentMethod?: NullableStringFieldUpdateOperationsInput | string | null
    transactionId?: NullableStringFieldUpdateOperationsInput | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    order?: OrderUpdateOneRequiredWithoutPaymentsNestedInput
  }

  export type PaymentUncheckedUpdateWithoutAgentInput = {
    id?: StringFieldUpdateOperationsInput | string
    orderId?: StringFieldUpdateOperationsInput | string
    amount?: FloatFieldUpdateOperationsInput | number
    paymentType?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    processedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    paymentMethod?: NullableStringFieldUpdateOperationsInput | string | null
    transactionId?: NullableStringFieldUpdateOperationsInput | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PaymentUncheckedUpdateManyWithoutAgentInput = {
    id?: StringFieldUpdateOperationsInput | string
    orderId?: StringFieldUpdateOperationsInput | string
    amount?: FloatFieldUpdateOperationsInput | number
    paymentType?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    processedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    paymentMethod?: NullableStringFieldUpdateOperationsInput | string | null
    transactionId?: NullableStringFieldUpdateOperationsInput | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PayrollUpdateWithoutAgentInput = {
    id?: StringFieldUpdateOperationsInput | string
    periodStart?: DateTimeFieldUpdateOperationsInput | Date | string
    periodEnd?: DateTimeFieldUpdateOperationsInput | Date | string
    periodType?: StringFieldUpdateOperationsInput | string
    totalEarnings?: FloatFieldUpdateOperationsInput | number
    totalOrders?: IntFieldUpdateOperationsInput | number
    basePay?: FloatFieldUpdateOperationsInput | number
    bonuses?: FloatFieldUpdateOperationsInput | number
    deductions?: FloatFieldUpdateOperationsInput | number
    netPay?: FloatFieldUpdateOperationsInput | number
    status?: StringFieldUpdateOperationsInput | string
    processedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    paidAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    paymentMethod?: NullableStringFieldUpdateOperationsInput | string | null
    transactionId?: NullableStringFieldUpdateOperationsInput | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PayrollUncheckedUpdateWithoutAgentInput = {
    id?: StringFieldUpdateOperationsInput | string
    periodStart?: DateTimeFieldUpdateOperationsInput | Date | string
    periodEnd?: DateTimeFieldUpdateOperationsInput | Date | string
    periodType?: StringFieldUpdateOperationsInput | string
    totalEarnings?: FloatFieldUpdateOperationsInput | number
    totalOrders?: IntFieldUpdateOperationsInput | number
    basePay?: FloatFieldUpdateOperationsInput | number
    bonuses?: FloatFieldUpdateOperationsInput | number
    deductions?: FloatFieldUpdateOperationsInput | number
    netPay?: FloatFieldUpdateOperationsInput | number
    status?: StringFieldUpdateOperationsInput | string
    processedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    paidAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    paymentMethod?: NullableStringFieldUpdateOperationsInput | string | null
    transactionId?: NullableStringFieldUpdateOperationsInput | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PayrollUncheckedUpdateManyWithoutAgentInput = {
    id?: StringFieldUpdateOperationsInput | string
    periodStart?: DateTimeFieldUpdateOperationsInput | Date | string
    periodEnd?: DateTimeFieldUpdateOperationsInput | Date | string
    periodType?: StringFieldUpdateOperationsInput | string
    totalEarnings?: FloatFieldUpdateOperationsInput | number
    totalOrders?: IntFieldUpdateOperationsInput | number
    basePay?: FloatFieldUpdateOperationsInput | number
    bonuses?: FloatFieldUpdateOperationsInput | number
    deductions?: FloatFieldUpdateOperationsInput | number
    netPay?: FloatFieldUpdateOperationsInput | number
    status?: StringFieldUpdateOperationsInput | string
    processedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    paidAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    paymentMethod?: NullableStringFieldUpdateOperationsInput | string | null
    transactionId?: NullableStringFieldUpdateOperationsInput | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AgentScheduleUpdateWithoutAgentInput = {
    id?: StringFieldUpdateOperationsInput | string
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    startTime?: NullableStringFieldUpdateOperationsInput | string | null
    endTime?: NullableStringFieldUpdateOperationsInput | string | null
    isAvailable?: BoolFieldUpdateOperationsInput | boolean
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AgentScheduleUncheckedUpdateWithoutAgentInput = {
    id?: StringFieldUpdateOperationsInput | string
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    startTime?: NullableStringFieldUpdateOperationsInput | string | null
    endTime?: NullableStringFieldUpdateOperationsInput | string | null
    isAvailable?: BoolFieldUpdateOperationsInput | boolean
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AgentScheduleUncheckedUpdateManyWithoutAgentInput = {
    id?: StringFieldUpdateOperationsInput | string
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    startTime?: NullableStringFieldUpdateOperationsInput | string | null
    endTime?: NullableStringFieldUpdateOperationsInput | string | null
    isAvailable?: BoolFieldUpdateOperationsInput | boolean
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type OrderCreateManyPartnerInput = {
    id?: string
    agentId?: string | null
    pickupLat: number
    pickupLng: number
    dropLat: number
    dropLng: number
    payoutAmount: number
    orderAmount?: number | null
    platformFee?: number | null
    orderType?: string | null
    commissionRate?: number | null
    priority?: string | null
    status?: $Enums.OrderStatus
    assignedAt?: Date | string | null
    pickedUpAt?: Date | string | null
    deliveredAt?: Date | string | null
    cancelledAt?: Date | string | null
    cancellationReason?: string | null
    estimatedDuration?: number | null
    actualDuration?: number | null
    createdAt?: Date | string
    updatedAt?: Date | string
    barcode?: string | null
    qrCode?: string | null
    deliveryOtp?: string | null
    deliveryQrCode?: string | null
    otpExpiresAt?: Date | string | null
    verifiedAt?: Date | string | null
    verificationMethod?: string | null
  }

  export type SupportTicketCreateManyPartnerInput = {
    id?: string
    orderId?: string | null
    agentId?: string | null
    userId: string
    issueType: string
    description: string
    status?: $Enums.TicketStatus
    resolvedAt?: Date | string | null
    adminNotes?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type PartnerDailyStatsCreateManyPartnerInput = {
    id?: string
    date: Date | string
    totalOrders?: number
    completedOrders?: number
    cancelledOrders?: number
    avgAssignmentTime?: number | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type AgentRatingCreateManyPartnerInput = {
    id?: string
    orderId: string
    agentId: string
    rating: number
    comment?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type PartnerRevenueCreateManyPartnerInput = {
    id?: string
    orderId: string
    orderAmount: number
    deliveryFee: number
    platformFee: number
    netRevenue: number
    status?: string
    processedAt?: Date | string | null
    periodStart: Date | string
    periodEnd: Date | string
    periodType: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type PlatformRevenueCreateManyPartnerInput = {
    id?: string
    orderId: string
    agentId?: string | null
    orderAmount: number
    platformFee: number
    agentPayout: number
    netRevenue: number
    revenueType: string
    status?: string
    processedAt?: Date | string | null
    periodStart: Date | string
    periodEnd: Date | string
    periodType: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type OrderUpdateWithoutPartnerInput = {
    id?: StringFieldUpdateOperationsInput | string
    pickupLat?: FloatFieldUpdateOperationsInput | number
    pickupLng?: FloatFieldUpdateOperationsInput | number
    dropLat?: FloatFieldUpdateOperationsInput | number
    dropLng?: FloatFieldUpdateOperationsInput | number
    payoutAmount?: FloatFieldUpdateOperationsInput | number
    orderAmount?: NullableFloatFieldUpdateOperationsInput | number | null
    platformFee?: NullableFloatFieldUpdateOperationsInput | number | null
    orderType?: NullableStringFieldUpdateOperationsInput | string | null
    commissionRate?: NullableFloatFieldUpdateOperationsInput | number | null
    priority?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumOrderStatusFieldUpdateOperationsInput | $Enums.OrderStatus
    assignedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    pickedUpAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    deliveredAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    cancelledAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    cancellationReason?: NullableStringFieldUpdateOperationsInput | string | null
    estimatedDuration?: NullableIntFieldUpdateOperationsInput | number | null
    actualDuration?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    barcode?: NullableStringFieldUpdateOperationsInput | string | null
    qrCode?: NullableStringFieldUpdateOperationsInput | string | null
    deliveryOtp?: NullableStringFieldUpdateOperationsInput | string | null
    deliveryQrCode?: NullableStringFieldUpdateOperationsInput | string | null
    otpExpiresAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    verifiedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    verificationMethod?: NullableStringFieldUpdateOperationsInput | string | null
    agent?: AgentUpdateOneWithoutOrdersNestedInput
    currentAgent?: AgentUpdateOneWithoutCurrentOrderNestedInput
    tickets?: SupportTicketUpdateManyWithoutOrderNestedInput
    rating?: AgentRatingUpdateOneWithoutOrderNestedInput
    payments?: PaymentUpdateManyWithoutOrderNestedInput
    partnerRevenue?: PartnerRevenueUpdateOneWithoutOrderNestedInput
    platformRevenue?: PlatformRevenueUpdateOneWithoutOrderNestedInput
    walletTransactions?: WalletTransactionUpdateManyWithoutOrderNestedInput
  }

  export type OrderUncheckedUpdateWithoutPartnerInput = {
    id?: StringFieldUpdateOperationsInput | string
    agentId?: NullableStringFieldUpdateOperationsInput | string | null
    pickupLat?: FloatFieldUpdateOperationsInput | number
    pickupLng?: FloatFieldUpdateOperationsInput | number
    dropLat?: FloatFieldUpdateOperationsInput | number
    dropLng?: FloatFieldUpdateOperationsInput | number
    payoutAmount?: FloatFieldUpdateOperationsInput | number
    orderAmount?: NullableFloatFieldUpdateOperationsInput | number | null
    platformFee?: NullableFloatFieldUpdateOperationsInput | number | null
    orderType?: NullableStringFieldUpdateOperationsInput | string | null
    commissionRate?: NullableFloatFieldUpdateOperationsInput | number | null
    priority?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumOrderStatusFieldUpdateOperationsInput | $Enums.OrderStatus
    assignedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    pickedUpAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    deliveredAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    cancelledAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    cancellationReason?: NullableStringFieldUpdateOperationsInput | string | null
    estimatedDuration?: NullableIntFieldUpdateOperationsInput | number | null
    actualDuration?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    barcode?: NullableStringFieldUpdateOperationsInput | string | null
    qrCode?: NullableStringFieldUpdateOperationsInput | string | null
    deliveryOtp?: NullableStringFieldUpdateOperationsInput | string | null
    deliveryQrCode?: NullableStringFieldUpdateOperationsInput | string | null
    otpExpiresAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    verifiedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    verificationMethod?: NullableStringFieldUpdateOperationsInput | string | null
    currentAgent?: AgentUncheckedUpdateOneWithoutCurrentOrderNestedInput
    tickets?: SupportTicketUncheckedUpdateManyWithoutOrderNestedInput
    rating?: AgentRatingUncheckedUpdateOneWithoutOrderNestedInput
    payments?: PaymentUncheckedUpdateManyWithoutOrderNestedInput
    partnerRevenue?: PartnerRevenueUncheckedUpdateOneWithoutOrderNestedInput
    platformRevenue?: PlatformRevenueUncheckedUpdateOneWithoutOrderNestedInput
    walletTransactions?: WalletTransactionUncheckedUpdateManyWithoutOrderNestedInput
  }

  export type OrderUncheckedUpdateManyWithoutPartnerInput = {
    id?: StringFieldUpdateOperationsInput | string
    agentId?: NullableStringFieldUpdateOperationsInput | string | null
    pickupLat?: FloatFieldUpdateOperationsInput | number
    pickupLng?: FloatFieldUpdateOperationsInput | number
    dropLat?: FloatFieldUpdateOperationsInput | number
    dropLng?: FloatFieldUpdateOperationsInput | number
    payoutAmount?: FloatFieldUpdateOperationsInput | number
    orderAmount?: NullableFloatFieldUpdateOperationsInput | number | null
    platformFee?: NullableFloatFieldUpdateOperationsInput | number | null
    orderType?: NullableStringFieldUpdateOperationsInput | string | null
    commissionRate?: NullableFloatFieldUpdateOperationsInput | number | null
    priority?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumOrderStatusFieldUpdateOperationsInput | $Enums.OrderStatus
    assignedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    pickedUpAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    deliveredAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    cancelledAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    cancellationReason?: NullableStringFieldUpdateOperationsInput | string | null
    estimatedDuration?: NullableIntFieldUpdateOperationsInput | number | null
    actualDuration?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    barcode?: NullableStringFieldUpdateOperationsInput | string | null
    qrCode?: NullableStringFieldUpdateOperationsInput | string | null
    deliveryOtp?: NullableStringFieldUpdateOperationsInput | string | null
    deliveryQrCode?: NullableStringFieldUpdateOperationsInput | string | null
    otpExpiresAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    verifiedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    verificationMethod?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type SupportTicketUpdateWithoutPartnerInput = {
    id?: StringFieldUpdateOperationsInput | string
    issueType?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    status?: EnumTicketStatusFieldUpdateOperationsInput | $Enums.TicketStatus
    resolvedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    adminNotes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    order?: OrderUpdateOneWithoutTicketsNestedInput
    agent?: AgentUpdateOneWithoutTicketsNestedInput
    user?: UserUpdateOneRequiredWithoutTicketsNestedInput
  }

  export type SupportTicketUncheckedUpdateWithoutPartnerInput = {
    id?: StringFieldUpdateOperationsInput | string
    orderId?: NullableStringFieldUpdateOperationsInput | string | null
    agentId?: NullableStringFieldUpdateOperationsInput | string | null
    userId?: StringFieldUpdateOperationsInput | string
    issueType?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    status?: EnumTicketStatusFieldUpdateOperationsInput | $Enums.TicketStatus
    resolvedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    adminNotes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SupportTicketUncheckedUpdateManyWithoutPartnerInput = {
    id?: StringFieldUpdateOperationsInput | string
    orderId?: NullableStringFieldUpdateOperationsInput | string | null
    agentId?: NullableStringFieldUpdateOperationsInput | string | null
    userId?: StringFieldUpdateOperationsInput | string
    issueType?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    status?: EnumTicketStatusFieldUpdateOperationsInput | $Enums.TicketStatus
    resolvedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    adminNotes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PartnerDailyStatsUpdateWithoutPartnerInput = {
    id?: StringFieldUpdateOperationsInput | string
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    totalOrders?: IntFieldUpdateOperationsInput | number
    completedOrders?: IntFieldUpdateOperationsInput | number
    cancelledOrders?: IntFieldUpdateOperationsInput | number
    avgAssignmentTime?: NullableFloatFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PartnerDailyStatsUncheckedUpdateWithoutPartnerInput = {
    id?: StringFieldUpdateOperationsInput | string
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    totalOrders?: IntFieldUpdateOperationsInput | number
    completedOrders?: IntFieldUpdateOperationsInput | number
    cancelledOrders?: IntFieldUpdateOperationsInput | number
    avgAssignmentTime?: NullableFloatFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PartnerDailyStatsUncheckedUpdateManyWithoutPartnerInput = {
    id?: StringFieldUpdateOperationsInput | string
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    totalOrders?: IntFieldUpdateOperationsInput | number
    completedOrders?: IntFieldUpdateOperationsInput | number
    cancelledOrders?: IntFieldUpdateOperationsInput | number
    avgAssignmentTime?: NullableFloatFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AgentRatingUpdateWithoutPartnerInput = {
    id?: StringFieldUpdateOperationsInput | string
    rating?: IntFieldUpdateOperationsInput | number
    comment?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    order?: OrderUpdateOneRequiredWithoutRatingNestedInput
    agent?: AgentUpdateOneRequiredWithoutRatingsNestedInput
  }

  export type AgentRatingUncheckedUpdateWithoutPartnerInput = {
    id?: StringFieldUpdateOperationsInput | string
    orderId?: StringFieldUpdateOperationsInput | string
    agentId?: StringFieldUpdateOperationsInput | string
    rating?: IntFieldUpdateOperationsInput | number
    comment?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AgentRatingUncheckedUpdateManyWithoutPartnerInput = {
    id?: StringFieldUpdateOperationsInput | string
    orderId?: StringFieldUpdateOperationsInput | string
    agentId?: StringFieldUpdateOperationsInput | string
    rating?: IntFieldUpdateOperationsInput | number
    comment?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PartnerRevenueUpdateWithoutPartnerInput = {
    id?: StringFieldUpdateOperationsInput | string
    orderAmount?: FloatFieldUpdateOperationsInput | number
    deliveryFee?: FloatFieldUpdateOperationsInput | number
    platformFee?: FloatFieldUpdateOperationsInput | number
    netRevenue?: FloatFieldUpdateOperationsInput | number
    status?: StringFieldUpdateOperationsInput | string
    processedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    periodStart?: DateTimeFieldUpdateOperationsInput | Date | string
    periodEnd?: DateTimeFieldUpdateOperationsInput | Date | string
    periodType?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    order?: OrderUpdateOneRequiredWithoutPartnerRevenueNestedInput
  }

  export type PartnerRevenueUncheckedUpdateWithoutPartnerInput = {
    id?: StringFieldUpdateOperationsInput | string
    orderId?: StringFieldUpdateOperationsInput | string
    orderAmount?: FloatFieldUpdateOperationsInput | number
    deliveryFee?: FloatFieldUpdateOperationsInput | number
    platformFee?: FloatFieldUpdateOperationsInput | number
    netRevenue?: FloatFieldUpdateOperationsInput | number
    status?: StringFieldUpdateOperationsInput | string
    processedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    periodStart?: DateTimeFieldUpdateOperationsInput | Date | string
    periodEnd?: DateTimeFieldUpdateOperationsInput | Date | string
    periodType?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PartnerRevenueUncheckedUpdateManyWithoutPartnerInput = {
    id?: StringFieldUpdateOperationsInput | string
    orderId?: StringFieldUpdateOperationsInput | string
    orderAmount?: FloatFieldUpdateOperationsInput | number
    deliveryFee?: FloatFieldUpdateOperationsInput | number
    platformFee?: FloatFieldUpdateOperationsInput | number
    netRevenue?: FloatFieldUpdateOperationsInput | number
    status?: StringFieldUpdateOperationsInput | string
    processedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    periodStart?: DateTimeFieldUpdateOperationsInput | Date | string
    periodEnd?: DateTimeFieldUpdateOperationsInput | Date | string
    periodType?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PlatformRevenueUpdateWithoutPartnerInput = {
    id?: StringFieldUpdateOperationsInput | string
    agentId?: NullableStringFieldUpdateOperationsInput | string | null
    orderAmount?: FloatFieldUpdateOperationsInput | number
    platformFee?: FloatFieldUpdateOperationsInput | number
    agentPayout?: FloatFieldUpdateOperationsInput | number
    netRevenue?: FloatFieldUpdateOperationsInput | number
    revenueType?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    processedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    periodStart?: DateTimeFieldUpdateOperationsInput | Date | string
    periodEnd?: DateTimeFieldUpdateOperationsInput | Date | string
    periodType?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    order?: OrderUpdateOneRequiredWithoutPlatformRevenueNestedInput
  }

  export type PlatformRevenueUncheckedUpdateWithoutPartnerInput = {
    id?: StringFieldUpdateOperationsInput | string
    orderId?: StringFieldUpdateOperationsInput | string
    agentId?: NullableStringFieldUpdateOperationsInput | string | null
    orderAmount?: FloatFieldUpdateOperationsInput | number
    platformFee?: FloatFieldUpdateOperationsInput | number
    agentPayout?: FloatFieldUpdateOperationsInput | number
    netRevenue?: FloatFieldUpdateOperationsInput | number
    revenueType?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    processedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    periodStart?: DateTimeFieldUpdateOperationsInput | Date | string
    periodEnd?: DateTimeFieldUpdateOperationsInput | Date | string
    periodType?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PlatformRevenueUncheckedUpdateManyWithoutPartnerInput = {
    id?: StringFieldUpdateOperationsInput | string
    orderId?: StringFieldUpdateOperationsInput | string
    agentId?: NullableStringFieldUpdateOperationsInput | string | null
    orderAmount?: FloatFieldUpdateOperationsInput | number
    platformFee?: FloatFieldUpdateOperationsInput | number
    agentPayout?: FloatFieldUpdateOperationsInput | number
    netRevenue?: FloatFieldUpdateOperationsInput | number
    revenueType?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    processedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    periodStart?: DateTimeFieldUpdateOperationsInput | Date | string
    periodEnd?: DateTimeFieldUpdateOperationsInput | Date | string
    periodType?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SupportTicketCreateManyOrderInput = {
    id?: string
    agentId?: string | null
    partnerId?: string | null
    userId: string
    issueType: string
    description: string
    status?: $Enums.TicketStatus
    resolvedAt?: Date | string | null
    adminNotes?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type PaymentCreateManyOrderInput = {
    id?: string
    agentId: string
    amount: number
    paymentType: string
    status?: string
    processedAt?: Date | string | null
    paymentMethod?: string | null
    transactionId?: string | null
    notes?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type WalletTransactionCreateManyOrderInput = {
    id?: string
    walletType: string
    adminWalletId?: string | null
    agentWalletId?: string | null
    amount: number
    type: string
    description?: string | null
    balanceBefore: number
    balanceAfter: number
    status?: string
    createdAt?: Date | string
  }

  export type SupportTicketUpdateWithoutOrderInput = {
    id?: StringFieldUpdateOperationsInput | string
    issueType?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    status?: EnumTicketStatusFieldUpdateOperationsInput | $Enums.TicketStatus
    resolvedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    adminNotes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    agent?: AgentUpdateOneWithoutTicketsNestedInput
    partner?: PartnerUpdateOneWithoutTicketsNestedInput
    user?: UserUpdateOneRequiredWithoutTicketsNestedInput
  }

  export type SupportTicketUncheckedUpdateWithoutOrderInput = {
    id?: StringFieldUpdateOperationsInput | string
    agentId?: NullableStringFieldUpdateOperationsInput | string | null
    partnerId?: NullableStringFieldUpdateOperationsInput | string | null
    userId?: StringFieldUpdateOperationsInput | string
    issueType?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    status?: EnumTicketStatusFieldUpdateOperationsInput | $Enums.TicketStatus
    resolvedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    adminNotes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SupportTicketUncheckedUpdateManyWithoutOrderInput = {
    id?: StringFieldUpdateOperationsInput | string
    agentId?: NullableStringFieldUpdateOperationsInput | string | null
    partnerId?: NullableStringFieldUpdateOperationsInput | string | null
    userId?: StringFieldUpdateOperationsInput | string
    issueType?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    status?: EnumTicketStatusFieldUpdateOperationsInput | $Enums.TicketStatus
    resolvedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    adminNotes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PaymentUpdateWithoutOrderInput = {
    id?: StringFieldUpdateOperationsInput | string
    amount?: FloatFieldUpdateOperationsInput | number
    paymentType?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    processedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    paymentMethod?: NullableStringFieldUpdateOperationsInput | string | null
    transactionId?: NullableStringFieldUpdateOperationsInput | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    agent?: AgentUpdateOneRequiredWithoutPaymentsNestedInput
  }

  export type PaymentUncheckedUpdateWithoutOrderInput = {
    id?: StringFieldUpdateOperationsInput | string
    agentId?: StringFieldUpdateOperationsInput | string
    amount?: FloatFieldUpdateOperationsInput | number
    paymentType?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    processedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    paymentMethod?: NullableStringFieldUpdateOperationsInput | string | null
    transactionId?: NullableStringFieldUpdateOperationsInput | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PaymentUncheckedUpdateManyWithoutOrderInput = {
    id?: StringFieldUpdateOperationsInput | string
    agentId?: StringFieldUpdateOperationsInput | string
    amount?: FloatFieldUpdateOperationsInput | number
    paymentType?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    processedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    paymentMethod?: NullableStringFieldUpdateOperationsInput | string | null
    transactionId?: NullableStringFieldUpdateOperationsInput | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type WalletTransactionUpdateWithoutOrderInput = {
    id?: StringFieldUpdateOperationsInput | string
    walletType?: StringFieldUpdateOperationsInput | string
    amount?: FloatFieldUpdateOperationsInput | number
    type?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    balanceBefore?: FloatFieldUpdateOperationsInput | number
    balanceAfter?: FloatFieldUpdateOperationsInput | number
    status?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    adminWallet?: AdminWalletUpdateOneWithoutTransactionsNestedInput
    agentWallet?: AgentWalletUpdateOneWithoutTransactionsNestedInput
  }

  export type WalletTransactionUncheckedUpdateWithoutOrderInput = {
    id?: StringFieldUpdateOperationsInput | string
    walletType?: StringFieldUpdateOperationsInput | string
    adminWalletId?: NullableStringFieldUpdateOperationsInput | string | null
    agentWalletId?: NullableStringFieldUpdateOperationsInput | string | null
    amount?: FloatFieldUpdateOperationsInput | number
    type?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    balanceBefore?: FloatFieldUpdateOperationsInput | number
    balanceAfter?: FloatFieldUpdateOperationsInput | number
    status?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type WalletTransactionUncheckedUpdateManyWithoutOrderInput = {
    id?: StringFieldUpdateOperationsInput | string
    walletType?: StringFieldUpdateOperationsInput | string
    adminWalletId?: NullableStringFieldUpdateOperationsInput | string | null
    agentWalletId?: NullableStringFieldUpdateOperationsInput | string | null
    amount?: FloatFieldUpdateOperationsInput | number
    type?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    balanceBefore?: FloatFieldUpdateOperationsInput | number
    balanceAfter?: FloatFieldUpdateOperationsInput | number
    status?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type WalletTransactionCreateManyAdminWalletInput = {
    id?: string
    walletType: string
    agentWalletId?: string | null
    orderId?: string | null
    amount: number
    type: string
    description?: string | null
    balanceBefore: number
    balanceAfter: number
    status?: string
    createdAt?: Date | string
  }

  export type WalletTransactionUpdateWithoutAdminWalletInput = {
    id?: StringFieldUpdateOperationsInput | string
    walletType?: StringFieldUpdateOperationsInput | string
    amount?: FloatFieldUpdateOperationsInput | number
    type?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    balanceBefore?: FloatFieldUpdateOperationsInput | number
    balanceAfter?: FloatFieldUpdateOperationsInput | number
    status?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    agentWallet?: AgentWalletUpdateOneWithoutTransactionsNestedInput
    order?: OrderUpdateOneWithoutWalletTransactionsNestedInput
  }

  export type WalletTransactionUncheckedUpdateWithoutAdminWalletInput = {
    id?: StringFieldUpdateOperationsInput | string
    walletType?: StringFieldUpdateOperationsInput | string
    agentWalletId?: NullableStringFieldUpdateOperationsInput | string | null
    orderId?: NullableStringFieldUpdateOperationsInput | string | null
    amount?: FloatFieldUpdateOperationsInput | number
    type?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    balanceBefore?: FloatFieldUpdateOperationsInput | number
    balanceAfter?: FloatFieldUpdateOperationsInput | number
    status?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type WalletTransactionUncheckedUpdateManyWithoutAdminWalletInput = {
    id?: StringFieldUpdateOperationsInput | string
    walletType?: StringFieldUpdateOperationsInput | string
    agentWalletId?: NullableStringFieldUpdateOperationsInput | string | null
    orderId?: NullableStringFieldUpdateOperationsInput | string | null
    amount?: FloatFieldUpdateOperationsInput | number
    type?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    balanceBefore?: FloatFieldUpdateOperationsInput | number
    balanceAfter?: FloatFieldUpdateOperationsInput | number
    status?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type WalletTransactionCreateManyAgentWalletInput = {
    id?: string
    walletType: string
    adminWalletId?: string | null
    orderId?: string | null
    amount: number
    type: string
    description?: string | null
    balanceBefore: number
    balanceAfter: number
    status?: string
    createdAt?: Date | string
  }

  export type WalletPayoutCreateManyAgentWalletInput = {
    id?: string
    agentId: string
    amount: number
    periodStart: Date | string
    periodEnd: Date | string
    status?: string
    paymentMethod?: string | null
    transactionId?: string | null
    bankAccount?: string | null
    upiId?: string | null
    processedAt?: Date | string | null
    failedAt?: Date | string | null
    failureReason?: string | null
    notes?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type WalletTransactionUpdateWithoutAgentWalletInput = {
    id?: StringFieldUpdateOperationsInput | string
    walletType?: StringFieldUpdateOperationsInput | string
    amount?: FloatFieldUpdateOperationsInput | number
    type?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    balanceBefore?: FloatFieldUpdateOperationsInput | number
    balanceAfter?: FloatFieldUpdateOperationsInput | number
    status?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    adminWallet?: AdminWalletUpdateOneWithoutTransactionsNestedInput
    order?: OrderUpdateOneWithoutWalletTransactionsNestedInput
  }

  export type WalletTransactionUncheckedUpdateWithoutAgentWalletInput = {
    id?: StringFieldUpdateOperationsInput | string
    walletType?: StringFieldUpdateOperationsInput | string
    adminWalletId?: NullableStringFieldUpdateOperationsInput | string | null
    orderId?: NullableStringFieldUpdateOperationsInput | string | null
    amount?: FloatFieldUpdateOperationsInput | number
    type?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    balanceBefore?: FloatFieldUpdateOperationsInput | number
    balanceAfter?: FloatFieldUpdateOperationsInput | number
    status?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type WalletTransactionUncheckedUpdateManyWithoutAgentWalletInput = {
    id?: StringFieldUpdateOperationsInput | string
    walletType?: StringFieldUpdateOperationsInput | string
    adminWalletId?: NullableStringFieldUpdateOperationsInput | string | null
    orderId?: NullableStringFieldUpdateOperationsInput | string | null
    amount?: FloatFieldUpdateOperationsInput | number
    type?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    balanceBefore?: FloatFieldUpdateOperationsInput | number
    balanceAfter?: FloatFieldUpdateOperationsInput | number
    status?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type WalletPayoutUpdateWithoutAgentWalletInput = {
    id?: StringFieldUpdateOperationsInput | string
    amount?: FloatFieldUpdateOperationsInput | number
    periodStart?: DateTimeFieldUpdateOperationsInput | Date | string
    periodEnd?: DateTimeFieldUpdateOperationsInput | Date | string
    status?: StringFieldUpdateOperationsInput | string
    paymentMethod?: NullableStringFieldUpdateOperationsInput | string | null
    transactionId?: NullableStringFieldUpdateOperationsInput | string | null
    bankAccount?: NullableStringFieldUpdateOperationsInput | string | null
    upiId?: NullableStringFieldUpdateOperationsInput | string | null
    processedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    failedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    failureReason?: NullableStringFieldUpdateOperationsInput | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    agent?: AgentUpdateOneRequiredWithoutWalletPayoutsNestedInput
  }

  export type WalletPayoutUncheckedUpdateWithoutAgentWalletInput = {
    id?: StringFieldUpdateOperationsInput | string
    agentId?: StringFieldUpdateOperationsInput | string
    amount?: FloatFieldUpdateOperationsInput | number
    periodStart?: DateTimeFieldUpdateOperationsInput | Date | string
    periodEnd?: DateTimeFieldUpdateOperationsInput | Date | string
    status?: StringFieldUpdateOperationsInput | string
    paymentMethod?: NullableStringFieldUpdateOperationsInput | string | null
    transactionId?: NullableStringFieldUpdateOperationsInput | string | null
    bankAccount?: NullableStringFieldUpdateOperationsInput | string | null
    upiId?: NullableStringFieldUpdateOperationsInput | string | null
    processedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    failedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    failureReason?: NullableStringFieldUpdateOperationsInput | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type WalletPayoutUncheckedUpdateManyWithoutAgentWalletInput = {
    id?: StringFieldUpdateOperationsInput | string
    agentId?: StringFieldUpdateOperationsInput | string
    amount?: FloatFieldUpdateOperationsInput | number
    periodStart?: DateTimeFieldUpdateOperationsInput | Date | string
    periodEnd?: DateTimeFieldUpdateOperationsInput | Date | string
    status?: StringFieldUpdateOperationsInput | string
    paymentMethod?: NullableStringFieldUpdateOperationsInput | string | null
    transactionId?: NullableStringFieldUpdateOperationsInput | string | null
    bankAccount?: NullableStringFieldUpdateOperationsInput | string | null
    upiId?: NullableStringFieldUpdateOperationsInput | string | null
    processedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    failedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    failureReason?: NullableStringFieldUpdateOperationsInput | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }



  /**
   * Batch Payload for updateMany & deleteMany & createMany
   */

  export type BatchPayload = {
    count: number
  }

  /**
   * DMMF
   */
  export const dmmf: runtime.BaseDMMF
}